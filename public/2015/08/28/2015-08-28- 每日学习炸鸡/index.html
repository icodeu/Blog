<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>每日学习炸鸡 | 把编程当做一种爱</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="每天都会看些文章视频等学习资料，看的多了有时候当时记住了，但是过后也许就忘了，所以要记录一下，以巩固知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="每日学习炸鸡">
<meta property="og:url" content="http://icodeyou.com/2015/08/28/2015-08-28- 每日学习炸鸡/index.html">
<meta property="og:site_name" content="把编程当做一种爱">
<meta property="og:description" content="每天都会看些文章视频等学习资料，看的多了有时候当时记住了，但是过后也许就忘了，所以要记录一下，以巩固知识。">
<meta property="og:image" content="http://7xivx9.com1.z0.glb.clouddn.com/sort.png">
<meta property="og:image" content="http://img.blog.csdn.net/20150104183450879">
<meta property="og:image" content="http://img.blog.csdn.net/20150622212835554">
<meta property="og:image" content="http://img.blog.csdn.net/20150622212856011">
<meta property="og:image" content="http://img.blog.csdn.net/20150622212916054">
<meta property="og:image" content="http://farm4.staticflickr.com/3686/9449083513_a56b59b17d_o.jpg">
<meta property="og:image" content="http://img.ptcms.csdn.net/article/201509/18/55fbe22546ba6.jpg">
<meta property="og:image" content="http://hukai.me/images/android_perf_2_ondraw_paint.png">
<meta property="og:image" content="http://hukai.me/images/android_perf_2_pixel_format.png">
<meta property="og:image" content="http://hukai.me/images/android_perf_2_pixel_decode.png">
<meta property="og:image" content="http://hukai.me/images/android_perf_2_sacle_bitmap_code.png">
<meta property="og:image" content="http://hukai.me/images/android_perf_2_sacle_bitmap_inscale.png">
<meta property="og:image" content="http://hukai.me/images/android_perf_2_sacle_bitmap_injust.png">
<meta property="og:image" content="http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png">
<meta property="og:updated_time" content="2015-10-26T13:52:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="每日学习炸鸡">
<meta name="twitter:description" content="每天都会看些文章视频等学习资料，看的多了有时候当时记住了，但是过后也许就忘了，所以要记录一下，以巩固知识。">
  
    <link rel="alternative" href="/atom.xml" title="把编程当做一种爱" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://buru.u.qiniudn.com/firebase-2.0.5.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars1.githubusercontent.com/u/7385129?v=3&amp;s=460" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">icodeyou</a></h1>
		</hgroup>

		
		<p class="header-subtitle">待我代码编成 娶你为妻可好</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/videos">视频教程</a></li>
				        
							<li><a href="/citstar">科技之星</a></li>
				        
							<li><a href="/works">作品</a></li>
				        
							<li><a href="/timeline">时间线</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/icodeu" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:icodeyou@sina.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AES/" style="font-size: 10px;">AES</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/GBN/" style="font-size: 10px;">GBN</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Java/" style="font-size: 18.57px;">Java</a> <a href="/tags/Linux/" style="font-size: 12.86px;">Linux</a> <a href="/tags/Mac/" style="font-size: 12.86px;">Mac</a> <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/Octopress/" style="font-size: 10px;">Octopress</a> <a href="/tags/Pycharm/" style="font-size: 10px;">Pycharm</a> <a href="/tags/Python/" style="font-size: 12.86px;">Python</a> <a href="/tags/SMTP/" style="font-size: 10px;">SMTP</a> <a href="/tags/Socket/" style="font-size: 11.43px;">Socket</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Wireshark/" style="font-size: 11.43px;">Wireshark</a> <a href="/tags/android/" style="font-size: 14.29px;">android</a> <a href="/tags/frp/" style="font-size: 10px;">frp</a> <a href="/tags/icodeyou/" style="font-size: 12.86px;">icodeyou</a> <a href="/tags/netwox/" style="font-size: 10px;">netwox</a> <a href="/tags/密码学/" style="font-size: 15.71px;">密码学</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/数据结构与算法/" style="font-size: 14.29px;">数据结构与算法</a> <a href="/tags/极客学院/" style="font-size: 17.14px;">极客学院</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/路由算法/" style="font-size: 10px;">路由算法</a> <a href="/tags/迪杰斯特拉/" style="font-size: 10px;">迪杰斯特拉</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.lynahex.com/">我大哥的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://zacharyjia.github.io/">牛B的学弟</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cdxy.me/">cdxy</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">不断成长的 程序员</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">icodeyou</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars1.githubusercontent.com/u/7385129?v=3&amp;s=460" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">icodeyou</h1>
			</hgroup>
			
			<p class="header-subtitle">待我代码编成 娶你为妻可好</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/videos">视频教程</a></li>
		        
					<li><a href="/citstar">科技之星</a></li>
		        
					<li><a href="/works">作品</a></li>
		        
					<li><a href="/timeline">时间线</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/icodeu" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:icodeyou@sina.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-2015-08-28- 每日学习炸鸡" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/28/2015-08-28- 每日学习炸鸡/" class="article-date">
  	<time datetime="2015-08-28T14:18:44.000Z" itemprop="datePublished">2015-08-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      每日学习炸鸡
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>每天都会看些文章视频等学习资料，看的多了有时候当时记住了，但是过后也许就忘了，所以要记录一下，以巩固知识。</p>
<a id="more"></a>
<ul>
<li><p>n个结点的哈夫曼树，叶子结点有 （n/2+1） 个</p>
</li>
<li><p>排序算法总结</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">排序法</th>
<th style="text-align:center">平均</th>
<th style="text-align:center">最差</th>
<th style="text-align:center">辅助</th>
<th style="text-align:center">是否稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡</td>
<td style="text-align:center">O(n*n)</td>
<td style="text-align:center">O(n*n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快排</td>
<td style="text-align:center">O(n*logn)</td>
<td style="text-align:center">O(n*n)</td>
<td style="text-align:center">O(logn)-O(n)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">选择</td>
<td style="text-align:center">O(n*n)</td>
<td style="text-align:center">O(n*n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">插入</td>
<td style="text-align:center">O(n*n)</td>
<td style="text-align:center">O(n*n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排</td>
<td style="text-align:center">O(n*logn)</td>
<td style="text-align:center">O(n*logn)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<p><img src="http://7xivx9.com1.z0.glb.clouddn.com/sort.png" alt="sort"></p>
<ul>
<li><p>关于广播</p>
<ul>
<li>静态注册广播最大优先级为 2147483647</li>
<li>生命周期只有十秒左右，如果在 onReceive() 内做超过十秒内的事情，就会报ANR(Application No Response) 程序无响应的错误信息，如果需要完成一项比较耗时的工作 , 应该通过发送 Intent 给 Service, 由Service 来完成 . 这里不能使用子线程来解决 , 因为 BroadcastReceiver 的生命周期很短 , 子线程可能还没有结束BroadcastReceiver 就先结束了 .BroadcastReceiver 一旦结束 , 此时 BroadcastReceiver 的所在进程很容易在系统需要内存时被优先杀死 , 因为它属于空进程 ( 没有任何活动组件的进程 ). 如果它的宿主进程被杀死 , 那么正在工作的子线程也会被杀死 . 所以采用子线程来解决是不可靠的。</li>
</ul>
</li>
<li><p>Service 运行在主线程中，不能执行耗时操作。要区分 后台 和 子线程 的概念：Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。你可能又会问，前面不是刚刚验证过Service是运行在主线程里的么？在这里一直执行着心跳连接，难道就不会阻塞主线程的运行吗？当然会，但是我们可以在Service中再创建一个子线程，然后在这里去处理耗时逻辑就没问题了。既然在Service里也要创建一个子线程，那为什么不直接在Activity里创建呢？这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。</p>
</li>
<li><p>布局原则</p>
<ul>
<li>尽量多使用RelativeLayout和LinearLayout, 不要使用绝对布局AbsoluteLayout，在布局层次一样的情况下， 建议使用LinearLayout代替RelativeLayout, 因为LinearLayout性能要稍高一点，但往往RelativeLayout可以简单实现LinearLayout嵌套才能实现的布局；</li>
<li>将可复用的组件抽取出来并通过include标签使用；</li>
<li>使用ViewStub标签来加载一些不常用的布局；</li>
<li>使用merge标签减少布局的嵌套层次。</li>
</ul>
</li>
<li><p>Hander、Message、Looper 的关系</p>
<ul>
<li>Looper:<br>每个线程有且最多只能有一个Looper对象，它是一个ThreadLocal<br>Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行<br>Looper使一个线程变成Looper线程</li>
<li>Handler:<br>handler扮演了往MQ上添加消息和处理消息的角色（只处理由自己发出的消息），即通知MQ它要执行一个任务(sendMessage)，并在loop到自己的时候执行该任务(handleMessage)，整个过程是异步的。handler创建时会关联一个looper，默认的构造方法将关联当前线程的looper，不过这也是可以set的。</li>
<li>Message:<br>尽管Message有public的默认构造方法，但是你应该通过Message.obtain()来从消息池中获得空消息对象，以节省资源。<br>如果你的message只需要携带简单的int信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存<br>擅用message.what来标识信息，以便用不同方式处理message。</li>
</ul>
</li>
<li><p>AsyncTask<br>  在3.0之前的AsyncTask可以同时有5个任务在执行(再缓存128个)，而3.0之后的AsyncTask同时只能有1个任务在执行。为什么升级之后可以同时执行的任务数反而变少了呢？这是因为更新后的AsyncTask已变得更加灵活，如果不想使用默认的线程池，还可以自由地进行配置。比如使用如下的代码来启动任务：这样就可以使用我们自定义的一个Executor来执行任务，而不是使用SerialExecutor。上述代码的效果允许在同一时刻有15个任务正在执行，并且最多能够存储200个任务。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executor exec = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">15</span>, <span class="number">200</span>, <span class="number">10</span>,  </span><br><span class="line">  	TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());  </span><br><span class="line"><span class="keyword">new</span> DownloadTask().executeOnExecutor(exec);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Async 的问题</p>
<ul>
<li><p>cancel方法实现不是很好.<br>如果你调用了AsyncTask的cancel(false)，doInBackground()仍然会执行到方法结束，只是不会去调用onPostExecute()方法。但是实际上这是让应用程序执行了没有意义的操作。那么是不是我们调用cancel(true)前面的问题就能解决呢？并非如此。如果mayInterruptIfRunning设置为true，会使任务尽早结束，但是如果的doInBackground()有不可打断的方法会失效，比如这个BitmapFactory.decodeStream() IO操作。但是你可以提前关闭IO流并捕获这样操作抛出的异常。但是这样会使得cancel()方法没有任何意义</p>
</li>
<li><p>内存泄露问题<br>还有一种常见的情况就是，在Activity中使用非静态匿名内部AsyncTask类，由于Java内部类的特点，AsyncTask内部类会持有外部类的隐式引用。由于AsyncTask的生命周期可能比Activity的长，当Activity进行销毁AsyncTask还在执行时，由于AsyncTask持有Activity的引用，导致Activity对象无法回收，进而产生内存泄露。</p>
</li>
<li><p>结果丢失<br>另一个问题就是在屏幕旋转等造成Activity重新创建时AsyncTask数据丢失的问题。当Activity销毁并创新创建后，还在运行的AsyncTask会持有一个Activity的非法引用即之前的Activity实例。导致onPostExecute()没有任何作用。</p>
</li>
<li><p>串行并行多版本不一致<br>1.6之前为串行，1.6到2.3为并行，3.0之后又改回为串行，但是可以通过executeOnExecutor(Executor)实现并行处理任务。</p>
</li>
</ul>
</li>
<li><p>子线程中更新UI的三种方法</p>
<ul>
<li>Handler</li>
<li>runOnUiThread(Runnable r)</li>
<li>View.post(Runnable r)</li>
</ul>
</li>
<li><p>Jackson 是一个将java对象转换成JSON与JSON转化java类的类库。Gson 是解决这个问题的流行方案，然而我们发现Jackson更高效,因为它支持替代的方法处理JSON:流、内存树模型,和传统JSON-POJO数据绑定。不过，请记住， Jsonkson库比起GSON更大，所以根据你的情况选择，你可能选择GSON来避免APP 65k个方法限制。</p>
</li>
<li><p>小心关于WebViews的问题. 如果你必须显示一个web视图， 比如说对于一个新闻文章，避免做客户端处理HTML的工作， 最好让后端工程师协助，让他返回一个 “纯” HTML。 <a href="http://stackoverflow.com/questions/3130654/memory-leak-in-webview" target="_blank" rel="external">WebViews 也能导致内存泄露</a> 当保持引他们的Activity，而不是被绑定到ApplicationContext中的时候。</p>
</li>
<li><p>Android 内存泄露总结</p>
</li>
<li><p><a href="https://github.com/futurice/android-best-practices/blob/master/translations/Chinese/README.cn.md" target="_blank" rel="external">Android 开发最佳实践</a></p>
</li>
<li><p>HttpURLConnection 和 AndroidHttpClient(HttpClient 的封装)如何选择及原因：<br>在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，所以在 Froyo 之前使用 HttpURLConnection 需要关闭 keepAlive。<br>另外在 Gingerbread(2.3) HttpURLConnection 默认开启了 gzip 压缩，提高了 HTTPS 的性能，Ice Cream Sandwich(4.0) HttpURLConnection 支持了请求结果缓存。<br>再加上 HttpURLConnection 本身 API 相对简单，所以对 Android 来说，在 2.3 之后建议使用 HttpURLConnection，之前建议使用 AndroidHttpClient。</p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=Hzs6OBcvNQE&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">不要使用 enum</a></p>
</li>
<li><p>启动页的splash如何实现<br>对该Activity应用主题</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="property">name</span>=<span class="string">"customBackground"</span> parent=<span class="string">"@android:style/Theme.Holo.Light"</span>&gt;</span><br><span class="line">    &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowBackground"</span>&gt;@drawable/start_app&lt;/<span class="property">item</span>&gt;</span><br><span class="line">    &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:windowNoTitle"</span>&gt;<span class="constant">true</span>&lt;/<span class="property">item</span>&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Android的定时任务一般有两种方式实现，其一是Java API的<code>Timer</code>，另外是Android的<code>Alarm</code>。但Timer有一个明显的短板，并不太适用于那些需要长期在后台运行的定时任务。Android会在长时间不用的情况下为了省电使CPU进入睡眠状态，可能导致Timer中的定时任务无法执行。而Alarm机制不存在此种问题，它可以唤醒CPU。</p>
</li>
</ul>
<p>-Activity间通过Intent传递数据大小有没有限制？<br>貌似是40K。</p>
<ul>
<li><p>Android APK 50M大小限制</p>
</li>
<li><p>启动一个程序，可以主界面点击图标进入，也可以从一个程序中跳转过去，二者有什么区别？</p>
</li>
</ul>
<p>因为启动程序（主界面也是一个app），发现了在这个程序中存在一个设置为<category android:name="android.intent.category.LAUNCHER">的activity,</category></p>
<p>所以这个launcher会把icon提出来，放在主界面上。当用户点击icon的时候，发出一个Intent：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="type">intent</span> = mActivity.getPackageManager().getLaunchIntentForPackage(packageName);</span><br><span class="line">mActivity.startActivity(<span class="type">intent</span>);</span><br></pre></td></tr></table></figure>
<p>跳过去可以跳到任意允许的页面，如一个程序可以下载，那么真正下载的页面可能不是首页（也有可能是首页），这时还是构造一个Intent，startActivity.</p>
<p>这个intent中的action可能有多种view,download都有可能。系统会根据第三方程序向系统注册的功能，为你的Intent选择可以打开的程序或者页面。所以唯一的一点</p>
<p><code>不同的是从icon的点击启动的intent的action是相对单一的，从程序中跳转或者启动可能样式更多一些。本质是相同的。</code></p>
<ul>
<li>程序之间的亲和性的理解。</li>
</ul>
<p>1、默认情况下一个应用的所有Activity都是具有相同的affinity，都是从application中继承，application的<code>affinity默认就是manifest的包名</code>。</p>
<p>2、<code>affinity对Activity来说，就像是身份证一样，可以告诉所在的Task，自己属于其中的一员。</code></p>
<p>3、应用场合：</p>
<p>a:根据affinity重新为Activity选择合适的宿主Task;</p>
<p>b:与allowTaskReparenting属性配合;</p>
<p>c:启动Activity使用Intent设置了FLAG_ACTIVITY_NEW_TASK标记。</p>
<ul>
<li>下面这段代码有内存泄露，能找出来吗？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.zhy._01;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * 使用数组模拟栈</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyStack</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> DEFAULT_INIT_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object[] eles = <span class="keyword">new</span> Object[DEFAULT_INIT_SIZE];</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 当前栈顶索引</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> currentIndex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 弹栈</span><br><span class="line">   * </span><br><span class="line">   * @return</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span><br><span class="line">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentIndex == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"stack is empty"</span>);</span><br><span class="line">    <span class="keyword">return</span> eles[--currentIndex];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 压栈</span><br><span class="line">   * </span><br><span class="line">   * @param o</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span></span><br><span class="line">  </span>&#123;</span><br><span class="line">    ensureCapacity();</span><br><span class="line">    eles[currentIndex++] = o;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span><br><span class="line">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eles.length == currentIndex)</span><br><span class="line">    &#123;</span><br><span class="line">      eles = Arrays.copyOf(eles, currentIndex * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用Fragment，一定要清楚这些方法，哪个会销毁视图，哪个会销毁实例，哪个仅仅只是隐藏，这样才能更好的使用它们。</li>
</ul>
<p>a、比如：我在FragmentA中的EditText填了一些数据，当切换到FragmentB时，如果希望会到A还能看到数据，则适合你的就是hide和show；也就是说，希望保留用户操作的面板，你可以使用hide和show，当然了不要使劲在那new实例，进行下非null判断。</p>
<p>b、再比如：我不希望保留用户操作，你可以使用remove()，然后add()；或者使用replace()这个和remove,add是相同的效果。</p>
<p>c、remove和detach有一点细微的区别，在不考虑回退栈的情况下，remove会销毁整个Fragment实例，而detach则只是销毁其视图结构，实例并不会被销毁。那么二者怎么取舍使用呢？如果你的当前Activity一直存在，那么在不希望保留用户操作的时候，你可以优先使用detach。</p>
<ul>
<li><p>transaction.remove()<br>从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈，这个Fragment实例将会被销毁。</p>
</li>
<li><p>Handler总结：<br>1、首先Looper.prepare()在本线程中保存一个Looper实例，然后该实例中保存一个MessageQueue对象；因为Looper.prepare()在一个线程中只能调用一次，所以MessageQueue在一个线程中只会存在一个。</p>
</li>
</ul>
<p>2、Looper.loop()会让当前线程进入一个无限循环，不端从MessageQueue的实例中读取消息，然后回调msg.target.dispatchMessage(msg)方法。</p>
<p>3、<code>Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联</code>。</p>
<p>4、Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。</p>
<p>5、在构造Handler实例时，我们会重写handleMessage方法，也就是msg.target.dispatchMessage(msg)最终调用的方法。</p>
<ul>
<li>在3.0以前，最大支持128个线程的并发，10个任务的等待。在3.0以后，无论有多少任务，都会在其内部单线程执行；</li>
</ul>
<ul>
<li>EventBus.getDefault().register(this);意思是让EventBus扫描当前类，把所有onEvent开头的方法记录下来，如何记录呢？使用Map，Key为方法的参数类型，Value中包含我们的方法。然后当子线程执行完毕，调用EventBus.getDefault().post(new ItemListEvent(Item.ITEMS))时，EventBus会根据post中实参的类型，去Map中查找对于的方法，于是找到了我们的onEventMainThread，最终调用反射去执行我们的方法。</li>
</ul>
<ul>
<li>关于Activity和Application的Context<br><img src="http://img.blog.csdn.net/20150104183450879" alt="image"><br>有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释：</li>
</ul>
<p>数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐。</p>
<p>数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。</p>
<p>数字3：在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）</p>
<p>注：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。</p>
<p>看下表格，重点看Activity和Application，可以看到，和UI相关的方法基本都不建议或者不可使用Application，并且，前三个操作基本不可能在Application中出现。实际上，只要把握住一点，凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</p>
<ul>
<li>MVP<br><img src="http://img.blog.csdn.net/20150622212835554" alt="image"><br>转换为<br><img src="http://img.blog.csdn.net/20150622212856011" alt="image"></li>
</ul>
<p><img src="http://img.blog.csdn.net/20150622212916054" alt="image"></p>
<p>其实最明显的区别就是，MVC中是允许Model和View进行交互的，而MVP中很明显，Model与View之间的交互由Presenter完成。还有一点就是Presenter与View之间的交互是通过接口的。<a href="http://blog.csdn.net/lmj623565791/article/details/46596109" target="_blank" rel="external">参考文章</a></p>
<ul>
<li>Reflection<br>获取类中方法：<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取 <span class="class"><span class="keyword">Class</span> 对象中指定函数名和参数的函数，参数一为函数名，参数 2 为参数类型列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">Method</span> <span class="title">getDeclaredMethod</span> (</span>String name, <span class="class"><span class="keyword">Class</span>...&lt;\?&gt; <span class="title">parameterTypes</span>)</span></span><br><span class="line"></span><br><span class="line">// 获取该 <span class="class"><span class="keyword">Class</span> 对象中的所有函数( 不包含从父类继承的函数 )</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">Method</span>[] <span class="title">getDeclaredMethods</span> (</span>)</span><br><span class="line"></span><br><span class="line">// 获取指定的 <span class="class"><span class="keyword">Class</span> 对象中的**公有**函数，参数一为函数名，参数 2 为参数类型列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">Method</span> <span class="title">getMethod</span> (</span>String name, <span class="class"><span class="keyword">Class</span>...&lt;\?&gt; <span class="title">parameterTypes</span>)</span></span><br><span class="line"></span><br><span class="line">// 获取该 <span class="class"><span class="keyword">Class</span> 对象中的所有**公有**函数 ( 包含从父类和接口类集成下来的函数 )</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">Method</span>[] <span class="title">getMethods</span> (</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里需要注意的是 getDeclaredMethod 和 getDeclaredMethods 包含 private、protected、default、public 的函数，并且通过这两个函数获取到的只是在自身中定义的函数，从父类中集成的函数不能够获取到。而 getMethod 和 getMethods 只包含 public 函数，父类中的公有函数也能够获取到。</p>
<p>获取类中属性：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取 <span class="class"><span class="keyword">Class</span> 对象中指定属性名的属性，参数一为属性名</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">Method</span> <span class="title">getDeclaredField</span> (</span>String name)</span><br><span class="line"></span><br><span class="line">// 获取该 <span class="class"><span class="keyword">Class</span> 对象中的所有属性( 不包含从父类继承的属性 )</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">Method</span>[] <span class="title">getDeclaredFields</span> (</span>)</span><br><span class="line"></span><br><span class="line">// 获取指定的 <span class="class"><span class="keyword">Class</span> 对象中的**公有**属性，参数一为属性名</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">Method</span> <span class="title">getField</span> (</span>String name)</span><br><span class="line"></span><br><span class="line">// 获取该 <span class="class"><span class="keyword">Class</span> 对象中的所有**公有**属性 ( 包含从父类和接口类集成下来的公有属性 )</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">Method</span>[] <span class="title">getFields</span> (</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是 getDeclaredField 和 getDeclaredFields 包含 private、protected、default、public 的属性，并且通过这两个函数获取到的只是在自身中定义的属性，从父类中集成的属性不能够获取到。而 getField 和 getFields 只包含 public 属性，父类中的公有属性也能够获取到。</p>
<p>获取父类<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">"mr.simple"</span>);</span><br><span class="line">    <span class="keyword">Class</span>&lt;\?&gt; superClass = student.getClass().getSuperclass();</span><br><span class="line">    <span class="keyword">while</span> (superClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"Student's super class is : "</span> + superClass.getName());</span><br><span class="line">        <span class="comment">// 再获取父类的上一层父类，直到最后的 Object 类，Object 的父类为 null</span></span><br><span class="line">        superClass = superClass.getSuperclass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取接口<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> showInterfaces() &#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"mr.simple"</span>);</span><br><span class="line">        <span class="keyword">Class</span>&lt;\?&gt;[] interfaceses = student.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;\?&gt; class1 : interfaceses) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"Student's interface is : "</span> + class1.getName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><a href="http://a.codekk.com/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="external">依赖注入</a></p>
</li>
<li><p><a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="external">Java Collections 系类学习</a></p>
</li>
<li><p><a href="http://www.trinea.cn/android/arraylist-linkedlist-loop-performance/" target="_blank" rel="external">ArrayList 和 LinkedList 各种遍历方式比较</a></p>
</li>
<li><p>Dalvik根据屏幕尺寸和密度决定应用程序的heap size，例如Android4.0.3的应用默认最小内存如下：<br><img src="http://farm4.staticflickr.com/3686/9449083513_a56b59b17d_o.jpg" alt="image"></p>
</li>
<li><p>ScrollView 只允许包含一个子 View</p>
</li>
<li><p><a href="http://www.trinea.cn/android/textview-add-link/" target="_blank" rel="external">TextView 添加链接</a></p>
</li>
<li><p><a href="http://www.trinea.cn/android/android-boot_completed-not-work/" target="_blank" rel="external">Android应用如何开机自启动、自启动失败原因</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice/" target="_blank" rel="external">关于Android线程优先级</a></p>
</li>
<li><p>有时候写的 BroadcastReceiver 中让线程 Thread.sleep(60*1000) 也不会出现 ANR，是因为确实发生了 ANR，只是没有弹窗而已，这种是 Background ANR，可以通过过滤日志验证，或者在开发者选项中勾选 “显示应用程序无响应” 对话框即可。</p>
</li>
<li><p>在Java中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用。静态的内部类不会持有外部类的引用</p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/?droid_refer=random_recommend" target="_blank" rel="external">Handler引起的内存泄露</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2015/06/13/talk-show-about-dependency-injection/?droid_refer=ninki_posts" target="_blank" rel="external">依赖注入</a> 开始看这个名字的时候我还以为是安全性问题，读过文章之后才知道这是设计模式中依赖倒置的问题。先看段代码，看看有什么问题：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Energy</span> </span>&#123;     </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GasEnergy</span> <span class="keyword">implements</span> <span class="title">Energy</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  Energy energy = <span class="keyword">new</span> GasEnergy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用组合依赖的形式本就是设计模式所推荐的，这无可厚非，可问题出现在直接 new 具体对象了，导致了耦合度增加，假如以后要修改具体对象类型了，此时还得修改 Car 类，这绝对不符合开闭原则，所以也就有了依赖注入，代码不写了，给三种方法：<code>构造器注入</code>,<code>Setters 方法注入</code>,<code>接口注入(接口里有 set 方法)</code></p>
<p>注入框架：<br>（1）Guice采用的是运行时读取注解，通过反射的形式生成依赖并进行注入。这种形式不太适合Android移动设备，毕竟这些操作都在运行时处理，对性能要求较高。<br>（2）Dagger则是Android开发适合的依赖注入库，其同样采用类注解的形式，不同的是它是在编译时生成辅助类，等到在运行时使用生成的辅助类完成依赖注入。</p>
<ul>
<li><p>我知道 Reader、Writer 字符流比 InputStream、OutputStream 多了一个缓存（缓冲）的特点，原来就是有些情况不调用 flush、close 的话不会将数据真正发送出去，才明白</p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/06/15/what-will-be-removed-if-you-click-clear-data-button-in-system-application-item/" target="_blank" rel="external">Android 系统设置中的清除数据究竟会清除哪些数据</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/07/04/attentions-when-adding-permission-for-android-application/" target="_blank" rel="external">申请权限支持设备不减少</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/07/12/load-url-with-extra-header-in-android-webview-chinese-edition/" target="_blank" rel="external">Webview加载网页时发送HTTP头信息</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/07/12/ding-bu-dai-jin-du-tiao-de-webview/" target="_blank" rel="external">顶部带进度条的Webview</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/07/27/capture-link-click-event-in-text-on-android/" target="_blank" rel="external">捕获Android文本中链接点击事件</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/08/13/create-fignerprint-for-weibo-or-wechat-in-the-easiest-way/" target="_blank" rel="external">超简单生成微博微信应用签名</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/archives/" target="_blank" rel="external">终于可以使用Markdown写邮件啦</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/" target="_blank" rel="external">有关 Java 字符串的拼接</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/09/12/get-resource-id-by-name-in-android/" target="_blank" rel="external">Android根据资源名获取资源ID</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android/" target="_blank" rel="external">Android中Java和JavaScript交互</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/" target="_blank" rel="external">细话Java：”失效”的private修饰符</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/" target="_blank" rel="external">Java 四种引用类型</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/" target="_blank" rel="external">糟糕的 AsyncTask</a></p>
</li>
<li><p><a href="http://developer.android.com/intl/zh-cn/guide/components/loaders.html" target="_blank" rel="external">如何使用 Loaders</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/11/08/understanding-garbage-collection-output-messages-in-android/" target="_blank" rel="external">Android 垃圾回收日志</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app/" target="_blank" rel="external">自定义 Toast 自己实现下</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/" target="_blank" rel="external">Java 中堆和栈的区别 非常好的总结</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/12/14/substring-memory-issue-in-java/" target="_blank" rel="external">关于 subString() 引起的”内存泄露”</a> </p>
</li>
<li><p><a href="http://droidyue.com/blog/2014/12/21/java-runtime-data-areas/" target="_blank" rel="external">JVM运行时的数据区</a></p>
</li>
<li><p>字符串常量池中存储的是字符串引用，而不是字符串本身，因为在 Java 中，对象都创建在堆内存中，<a href="http://droidyue.com/blog/2014/12/21/string-literal-pool-in-java/" target="_blank" rel="external">参考文章</a></p>
</li>
<li><p>对于使用new创建的字符串，如果也想将其引用放到字符串常量池中，可以使用intern方法</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">str4 </span>= <span class="keyword">str3.intern();</span><br><span class="line"></span><span class="label">System.out.println</span>(<span class="keyword">str4 </span>== <span class="keyword">str1);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://droidyue.com/blog/2014/12/28/static-biding-and-dynamic-binding-in-java/" target="_blank" rel="external">Java 中的动态绑定和静态绑定</a>。可以简单理解就是，重载是静态绑定，覆写是动态绑定。<a href="http://www.cnblogs.com/dolphin0520/p/3803432.html" target="_blank" rel="external">又一动态绑定</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2015/01/11/looking-into-singleton/" target="_blank" rel="external">单例模式双重加锁时也要记得给instace加上volatile</a>。另外 IoDH 技术可以用静态内部类实现在类加载时对instance进行初始化，类似于 Holder。</p>
</li>
<li><p><a href="http://droidyue.com/blog/2015/01/11/looking-into-singleton/" target="_blank" rel="external">单例模式可以被打破</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/" target="_blank" rel="external">AutoBoxing UnBoxing == 与 Integer缓存-128~127的坑</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2015/04/12/avoid-memory-leaks-on-context-in-android/" target="_blank" rel="external">Context 泄露</a>。其中也说到了Drawable引起的内存泄露。</p>
</li>
<li><p><a href="http://droidyue.com/blog/2015/05/30/android-http-clients/" target="_blank" rel="external">关于 HttpUrlConnection 和 HttpClient 的区别</a></p>
</li>
<li><p><a href="http://droidyue.com/blog/2015/07/25/use-android-lint-to-find-higher-api-usage/" target="_blank" rel="external">关于 lint</a></p>
</li>
<li><p>android:sharedUserId是指共用一个uid</p>
</li>
<li><p>大多数static的数据被mmapped到一个进程中。这不仅仅让同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被paged out。常见的static数据包括Dalvik Code、app resources、so文件等。</p>
</li>
<li><p>Bitmap decode format 解码格式的差异？</p>
</li>
<li><p>利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率</p>
</li>
<li><p><a href="http://www.csdn.net/article/2015-09-18/2825737/4" target="_blank" rel="external">内存泄露</a></p>
</li>
<li><p>谨慎使用static对象。因为static的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在Android中应该谨慎使用static对象<br><img src="http://img.ptcms.csdn.net/article/201509/18/55fbe22546ba6.jpg" alt="image"></p>
</li>
<li><p><a href="http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/" target="_blank" rel="external">LeakCanary</a></p>
</li>
<li><p><a href="http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/" target="_blank" rel="external">MAT的使用</a></p>
</li>
<li><p><a href="http://androidperformance.com/" target="_blank" rel="external">Android Performance 中文</a></p>
</li>
<li><p><a href="http://developer.android.com/intl/zh-cn/reference/android/app/job/JobScheduler.html" target="_blank" rel="external">JobScheduler</a></p>
</li>
<li><p>如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。<br><img src="http://hukai.me/images/android_perf_2_ondraw_paint.png" alt="image"></p>
</li>
<li><p><a href="http://hukai.me/android-performance-patterns-season-2/" target="_blank" rel="external">Strict Mode 防止出现ANR 第11部分</a> </p>
</li>
<li><p>尽量使用ClipRect等方法来提高绘制的性能 ?</p>
</li>
<li><p>执行延时任务的三种方式：AlarmManager、SyncAdapter、JobSchedulor</p>
</li>
<li><p>Android 图片解码格式<br><img src="http://hukai.me/images/android_perf_2_pixel_format.png" alt="image"></p>
</li>
<li><p>Android 图片解码率<br><img src="http://hukai.me/images/android_perf_2_pixel_decode.png" alt="image"></p>
</li>
<li><p>一种新的图片格式：Webp，它是由Google推出的一种既保留png格式的优点，又能够减少图片大小的一种新型图片格式</p>
</li>
<li><p>缩放Bitmap的几种方式比较<br>createScaledBitmap(),这种方法能够快速得到一张经过缩放的图片，可是这个方法能够执行的前提是，原图片需要事先加载到内存中，如果原图片过大，很可能导致OOM；<br>inSampleSize能够等比的缩放显示图片，同时还避免了需要先把原图加载进内存的缺点；<br><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_code.png" alt="image"><br>还可以使用inScaled，inDensity，inTargetDensity的属性来对图片解码做处理；<br><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_inscale.png" alt="image"><br>使用inJustDecodeBounds，可以事先获取到图片的大小而不至于占用内存。<br><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_injust.png" alt="image"></p>
</li>
<li><p>inBitmap</p>
</li>
<li><p>Glide 库</p>
</li>
<li><p>对象池？</p>
</li>
<li><p><a href="http://www.cnblogs.com/dolphin0520/p/3803432.html" target="_blank" rel="external">继承中的隐藏和覆盖</a></p>
</li>
<li><p>单线程私有：程序计数器、JVM栈、本地方法栈<br>多线程共享：堆内存、方法区、运行时常量池</p>
</li>
<li><p>子 View 可以通过调用 getParent().requestDisallowInterceptTouchEvent(true);  阻止 ViewGroup 对其 MOVE 或者 UP 事件进行拦截。</p>
</li>
<li><p>产生 ANR 的前提是要有输入事件，如果用户没有触发任何输入事件，即便是主线程阻塞了，也不会产生 ANR，因为 InputDispatcher 没有分发事件给应用程序，当然也不会检测处理超时和报告ANR了。</p>
</li>
<li><p>不会参与对象序列化的是：类的静态成员变量和 transient 关键字标记的。</p>
</li>
<li><p>类 ServiceConnection 中的 onServiceDisconnected() 方法在正常情况下是不被调用的，它的调用时机是当 Service 服务被异外销毁时，例如内存的资源不足时这个方法才被自动调用。</p>
</li>
</ul>
<h3 id="个人GitHub:_http://github-com/icodeu">个人GitHub:  <a href="http://github.com/icodeu" target="_blank" rel="external">http://github.com/icodeu</a></h3><h3 id="CSDN博客：http://blog-csdn-net/icodeyou">CSDN博客：<a href="http://blog.csdn.net/icodeyou" target="_blank" rel="external">http://blog.csdn.net/icodeyou</a></h3><h3 id="个人微信号：qqwanghuan_技术交流">个人微信号：<code>qqwanghuan</code>  技术交流</h3><p><img src="http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png" alt="image"></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/08/30/2015-08-30- mac下抓包工具--Charles/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          mac抓包工具--Charles
        
      </div>
    </a>
  
  
    <a href="/2015/08/24/2015-08-24-【视频教程】Android 开发实战：自动检测更新功能的实现/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">【视频教程】Android 开发实战：自动检测更新功能的实现</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="2015-08-28- 每日学习炸鸡" data-title="每日学习炸鸡" data-url="http://icodeyou.com/2015/08/28/2015-08-28- 每日学习炸鸡/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"icodeyou"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 icodeyou
    	</div>

      <div class="footer-right">
      	<a href="http://icodeyou.com/" target="_blank">以大多数人的努力程度之低，根本轮不到拼天赋</a>
        <font id="sum_counter"></font>
        <font id="detail_counter"></font>        
      </div>
    </div>
  </div>

  <script>
  var io10blogFirebase = new Firebase("https://icodeyou.firebaseio.com/");

  // 明细由当前页面的url表示，将反斜线替换成下划线，并将中文decode出来
  var current_url = decodeURI(window.location.pathname.replace(new RegExp('\\/|\\.', 'g'),"_"));
  // 获取总数，并将总访问量展示在页面上
  io10blogFirebase.child("sum").on("value", function(data) {
    var current_counter = data.val();
    if( $("#sum_counter").length > 0  && current_counter >1 ){
        $("#sum_counter").html(
          "&nbsp;|&nbsp;总访问量&nbsp;<font style='color:gray'>"+ current_counter +"</font>&nbsp;次"
         );
    };
  });
  // 获取明细，并将明细也展示在页面上
  io10blogFirebase.child("detail/"+current_url).on("value", function(data){
    var detail_counter = data.val();
    if($("#detail_counter").length > 0 && detail_counter > 1){
      $("#detail_counter").html(
        "&nbsp;本页访问量&nbsp;<font style='color:gray'>"+ detail_counter +"</font>&nbsp;次"
      );
    }
  });

  // 总数+1
  io10blogFirebase.child("sum").transaction(function (current_counter) {
    return (current_counter || 0) + 1;
  });
  // 明细+1
  io10blogFirebase.child("detail/"+current_url).transaction(function (current_counter) {
    return (current_counter || 0) + 1;
  });
  </script>

</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254722126'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/stat.php%3Fid%3D1254722126%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
  </div>
</body>
</html>