{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":0},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":0},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":0},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":0},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":0},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":0},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":0},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":0},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":0},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":0},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":0},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":0},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":0},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":0},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":0},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":0},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":0},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":0},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":0},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":0},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":0},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":0},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":0},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":0},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0},{"_id":"source/citstar/images/citstar7.JPG","path":"citstar/images/citstar7.JPG","modified":0},{"_id":"source/citstar/images/citstar6.JPG","path":"citstar/images/citstar6.JPG","modified":0},{"_id":"source/citstar/images/citstar5.JPG","path":"citstar/images/citstar5.JPG","modified":0},{"_id":"source/citstar/images/citstar4.JPG","path":"citstar/images/citstar4.JPG","modified":0},{"_id":"source/citstar/images/citstar3.JPG","path":"citstar/images/citstar3.JPG","modified":0},{"_id":"source/citstar/images/citstar2.JPG","path":"citstar/images/citstar2.JPG","modified":0},{"_id":"source/citstar/images/citstar1.JPG","path":"citstar/images/citstar1.JPG","modified":0}],"Cache":[{"_id":"source/_drafts/Atom快捷键.txt","shasum":"ddcb1648a703498eb1abf13b33a61a3d940c7433","modified":1458458886000},{"_id":"source/_drafts/android-getlocationonscreen.markdown","shasum":"d3083a75c47eab77d8a02ba441d5cc8323b32802","modified":1456539979000},{"_id":"source/_drafts/listview-optimize.md","shasum":"af3b5ef7c03d3942167122b88c28719f4b56c2db","modified":1446725348000},{"_id":"source/_drafts/android-textview-fontmetrics.markdown","shasum":"a942955499b0e8682c99d3a1cbdb614ac7e26632","modified":1453685670000},{"_id":"source/_posts/2014-10-18-浅谈用 Java 搭建 web 服务器之 Socket 编程——更好的理解 Apache、Tomcat 等软件的工作模式.markdown","shasum":"1d63ab5500d50edfbd74ba8eec253ca9d5f5d2e7","modified":1440411675000},{"_id":"source/_drafts/timestamp-android.markdown","shasum":"c14d5087537b3940ec6c9affcab3ae3a0e425aa0","modified":1456667187000},{"_id":"source/_drafts/记录的AS快捷键.markdown","shasum":"2a44080504a141fedacc9ede8178ef4e11f7c937","modified":1458459541000},{"_id":"source/_posts/2014-10-25-使用 Wireshark 抓包分析的思考.markdown","shasum":"65fc78edb60ca8648f64e123b62df17b9252fa4f","modified":1440411945000},{"_id":"source/_posts/2014-10-20-再谈用 Java 实现 SMTP 发送邮件之 Socket 编程.markdown","shasum":"1201dffe2d830d772aa283e31fb44916a43813c8","modified":1440411704000},{"_id":"source/_posts/2014-10-31-Java 实现 AES 算法.markdown","shasum":"2b55313c98576709f6f9284c4dd74848974d31b9","modified":1440411960000},{"_id":"source/_posts/2014-11-27-编程实现路由算法--迪杰斯特拉算法.markdown","shasum":"e0e34ed4573be15348cde9c4a9cf57d4ebdfb4c6","modified":1440411973000},{"_id":"source/_posts/2014-11-29-编程实现可靠数据传输原理 Go-Back-N.markdown","shasum":"020eab6faa6833311975967c24ef056c44b81e62","modified":1449368345000},{"_id":"source/_posts/2014-12-04-AndroidCollection.markdown","shasum":"af4c351517c8c04212f2e120ea4d2f143a3b3a7d","modified":1449368427000},{"_id":"source/_posts/2014-12-19-【视频教程】Android 扫描二维码实现网页登录.markdown","shasum":"44cca00d67a21ddf4ebef613619b953d3024612a","modified":1440412008000},{"_id":"source/_posts/2014-12-22-ThreadSynchronization.markdown","shasum":"e3581196086000d35179c3b186d310128096a10c","modified":1446295365000},{"_id":"source/_posts/2014-12-30-【视频教程】Android 侧滑菜单之 DrawerLayout 的使用.markdown","shasum":"0f15acb0d9d9fd29954f14c7d08244f6ab53b822","modified":1440412014000},{"_id":"source/_posts/2015-02-28-【视频教程】Android 项目开发实战--新闻客户端.markdown","shasum":"fba9493959f8783ab1f3536b3267ed073dfa2a47","modified":1440412025000},{"_id":"source/_posts/2015-01-15-【视频教程】Android 中 Action Bar 的使用.markdown","shasum":"25cbbface7310509f09e8a81d27110ea53dccd3a","modified":1440412020000},{"_id":"source/_posts/2015-04-10- 在 Mac 下安装 mysql for python.markdown","shasum":"3b0790e8f85825bc628449ee25853959445ba60f","modified":1440411898000},{"_id":"source/_posts/2015-03-15-【视频教程】Fedora 升级 Kernel 至最新版本.markdown","shasum":"2742bd33ca8f350df0524134c0087f3f7c65a6e9","modified":1440412041000},{"_id":"source/_posts/2015-04-16-【视频教程】Base64编码的编程使用.markdown","shasum":"1f926445843212731205f0be7e111bbd75f0de1e","modified":1440412073000},{"_id":"source/_posts/2015-04-18-二叉树总结.markdown","shasum":"0729642696e2a6ab144003593512e2c0c72eefbf","modified":1444966326000},{"_id":"source/_posts/2015-04-18-图总结.markdown","shasum":"8726da3ee5a259cc000c1d18bdbebcb2afdc7a33","modified":1445002251000},{"_id":"source/_posts/2015-04-18-排序算法总结.markdown","shasum":"9ecd211afbd24f8ea2388133fd0aaaac5f866684","modified":1444963610000},{"_id":"source/_posts/2015-04-28-【视频教程】消息摘要的编程使用.markdown","shasum":"3c70c1f3b001f93ad7b7331d7dd37405831fa70b","modified":1440412081000},{"_id":"source/_posts/2015-05-04-【视频教程】对称密码的编程使用.markdown","shasum":"1c0f1841d30e0f72e9ae5506387a29184914db2e","modified":1440412089000},{"_id":"source/_posts/2015-04-18-算法之数组.markdown","shasum":"bc75c11731d36ae8a0c0e1d8ff0a87876ba408cb","modified":1444963632000},{"_id":"source/_posts/2015-05-03- Ubuntu1204无法登录桌面.markdown","shasum":"8d339fa46296bff4338396e30f5e7592b20ea1ac","modified":1440412115000},{"_id":"source/_posts/2015-05-15- Android常用网络请求框架的使用.markdown","shasum":"808b9119ff79f9797bcea16eb6f045a991b49432","modified":1440412136000},{"_id":"source/_posts/2015-05-13-【视频教程】Octopress 搭建静态博客网站.markdown","shasum":"79ec34664f4e7b579b3e735c957cc96a8679764e","modified":1440412129000},{"_id":"source/_posts/2015-06-02-【视频教程】数字签名的编程使用.markdown","shasum":"6bf8ecc1206ce0e5490d963a8c1a021558581821","modified":1440412100000},{"_id":"source/_posts/2015-05-21-【视频教程】非对称密码的编程使用.markdown","shasum":"68ce760523479bfe122163d6fa476dd9b17244b2","modified":1440412095000},{"_id":"source/_posts/2015-06-05- helen.markdown","shasum":"6cd11b3ecae4197c0f97fa7e888b22f5bb2c957a","modified":1448781453000},{"_id":"source/_posts/2015-06-04-【视频教程】证书的概念和使用.markdown","shasum":"21d5cee4e3bcbcb241ec75f4642ef52ebbde3507","modified":1440412106000},{"_id":"source/_posts/2015-06-05- 获取微信聊天记录.markdown","shasum":"1e895a61c278a0d872841dad5d12419a33406933","modified":1440412144000},{"_id":"source/_posts/2015-06-10- wireshark找不到interface.markdown","shasum":"3e2227eec8e5dc08421418a9807161abc31f0dc2","modified":1440412186000},{"_id":"source/_posts/2015-06-10- 典型tcp攻击实验.markdown","shasum":"46048fb3fb6edc67ec7203d3c9d142fa48841613","modified":1440412167000},{"_id":"source/_posts/2015-06-17- 【视频教程】安全协议和认证服务.markdown","shasum":"675bc66ef1ebb140e15d051acd6b882b6b970d12","modified":1440412746000},{"_id":"source/_posts/2015-06-23- 网站登录模块开发安全加固.markdown","shasum":"8e6e7c676b7760f86daa723625af5db2b028dfcc","modified":1440412900000},{"_id":"source/_posts/2015-06-23- 【视频教程】网站登录模块开发安全加固.markdown","shasum":"8e6e7c676b7760f86daa723625af5db2b028dfcc","modified":1440412757000},{"_id":"source/_posts/2015-08-15- mac下抓包工具--Debookee.markdown","shasum":"c5f50b1b71daf0130df78662e61455c402545c6c","modified":1440901715000},{"_id":"source/_posts/2015-07-25- python-urllib超时.markdown","shasum":"0efc653d4d138a80c3302184a588f416497ade48","modified":1440411834000},{"_id":"source/_posts/2015-08-24-【视频教程】Android 开发实战：自动检测更新功能的实现.markdown","shasum":"06c9f0a6df24e0e17299fedf9665171ab2d6c495","modified":1440412206000},{"_id":"source/_posts/2015-08-28- 每日学习炸鸡.markdown","shasum":"b824249cdce93e3dbbe2e0d3acc50879b15cfce1","modified":1445867540000},{"_id":"source/_posts/2015-08-30- mac下抓包工具--Charles.markdown","shasum":"5abd6f1295d3eb0588704361772b1b7a2c0f926d","modified":1440902047000},{"_id":"source/_posts/2015-09-06- Android开发中的大坑.markdown","shasum":"6dd6f0de12343efd2508c2371b29e7dafb38d3d8","modified":1441507183000},{"_id":"source/_posts/2015-09-13- Java字符集与编码.markdown","shasum":"7f277ac776f48f679e92b02590e68d5651622cee","modified":1442495783000},{"_id":"source/_posts/2015-09-14- Android 进阶-导图.markdown","shasum":"887b760ad57607c1e29f4657978ac01acf572c01","modified":1442237754000},{"_id":"source/_posts/2015-09-14- Java 基础知识-导图.markdown","shasum":"6db600f0039494aabdd370032a1cf3a911929add","modified":1442237775000},{"_id":"source/_posts/2015-09-14- 单链表逆置.markdown","shasum":"e54befd1a019466f6a5ff1be8bb8044b564aa7e6","modified":1443797431000},{"_id":"source/_posts/2015-09-14- 数据结构-导图.markdown","shasum":"5bc7f8bd1d1714ee39d3754de2c6b8a22813f0ad","modified":1442237739000},{"_id":"source/_posts/2015-09-14- 第一行代码-导图.markdown","shasum":"818dcdf488531f9aedac267bf97606e1694d7240","modified":1442237547000},{"_id":"source/_posts/2015-09-14-ConcurrentHashMap.markdown","shasum":"1e0a2091deb7cc9707a12c54d33dd91726b5a24c","modified":1444829103000},{"_id":"source/_posts/2015-09-14- 设计模式-导图.markdown","shasum":"d267e20992a5d682d06861943fc7f0d427ec74a5","modified":1442237727000},{"_id":"source/_posts/2015-09-14-CopyOnWrite.markdown","shasum":"f6c5a7707d1f73f747c0e1dc360b28eb72c52040","modified":1444832694000},{"_id":"source/_posts/2015-09-16- JIT 学习笔记.markdown","shasum":"17b31866a7d0665af404ef54e577cddbb27ae98e","modified":1442369413000},{"_id":"source/_posts/2015-09-16-BlockingQueue.markdown","shasum":"303f82ec84970ea7f0ed90b581da3fa92d169dae","modified":1444877240000},{"_id":"source/_posts/2015-10-08- 自己真正读过的好书.markdown","shasum":"1a655a73e21b9b9053716e7212c01c784426b3df","modified":1444565546000},{"_id":"source/_posts/2015-10-06- Android群英传.markdown","shasum":"f2ecf8a16e3228070b3cb0878a363aa66b19645c","modified":1444187085000},{"_id":"source/_posts/2015-10-07- Android开发艺术探索.markdown","shasum":"3ab03c2d7ab86962f4656b9277cc4cb1b6ce651e","modified":1444831361000},{"_id":"source/_posts/2015-10-09- Java笔试题随记.markdown","shasum":"fede89646dd6aa387b2690b0ae6f77774ec662ac","modified":1445004004000},{"_id":"source/_posts/2015-10-11-HandlerThread源码解析.markdown","shasum":"d6a8ac400caa9e6cab615402b26611b6bbf66f0e","modified":1450602532000},{"_id":"source/_posts/2015-10-11-IntentService源码解析.markdown","shasum":"686942368047900f2bedd2c0d641aa94a8671ada","modified":1444571070000},{"_id":"source/_posts/2015-10-11-getMainLooper.markdown","shasum":"f208487604999ac9a14242413f96468f98ffc3c2","modified":1444788966000},{"_id":"source/_posts/2015-10-22-ViewMeasure.markdown","shasum":"755d9da2d251c87a7cd00af427bb868f5ff5b9a8","modified":1445505300000},{"_id":"source/_posts/2015-10-28-AIDL.markdown","shasum":"fb21b637fc2d935ca34142704a59f69ddabaa302","modified":1446037550000},{"_id":"source/_posts/2015-10-28-Messenger.markdown","shasum":"abda8dfc8c83513bcb3c2f5a02c9e636ada4fae6","modified":1446037518000},{"_id":"source/_posts/2015-11-11-QTFMService.markdown","shasum":"7d5d5fb8ec6191ee1b3648df647fcf12a9b18c85","modified":1447662421000},{"_id":"source/_posts/2015-11-29-manuscript.markdown","shasum":"5e9b56520fbfcbe57d30b5c2f6ee8673f2a34f30","modified":1448781233000},{"_id":"source/_posts/2015-12-13-AndroidStudioShortCuts.markdown","shasum":"a1b12513e0f0551bb9098bac8e88e3fe18095517","modified":1460431016000},{"_id":"source/_posts/2015-12-15-AndroidStudioSerialVersionUID.markdown","shasum":"2f447329009086235df46665d3d4090c1c0edeb9","modified":1450229461000},{"_id":"source/_posts/2015-12-23-AndroidLibraryJitPack.markdown","shasum":"b7524c75aa845dc35e62713ff7e7ce2bc288447c","modified":1459241358000},{"_id":"source/_posts/mactools.markdown","shasum":"6ada976bbdcc72a5f77ef0ac8c6b9b8ccb92eec0","modified":1456539955000},{"_id":"source/_posts/ssh-add-mac.markdown","shasum":"d0e14b50a97565cf93eed2b50be23b879f5f4836","modified":1453028263000},{"_id":"source/timeline/index.html","shasum":"03dce4655f9280f5879219c5cbaf4dddf64209e1","modified":1480738147000},{"_id":"source/citstar/index.html","shasum":"81e790a4e2e64c12c8856622f58e8f8b75dcbba3","modified":1433564294000},{"_id":"source/citstar/index.md","shasum":"3499e887eb971014dcae4677d191d65b677b6741","modified":1440345449000},{"_id":"source/timeline/index.md","shasum":"22b63bd23c9650f9bf659888323f1d65e3421256","modified":1480339186000},{"_id":"source/works/index.html","shasum":"1d7d8502d9e726e57aec55dd3f2c19680c2cf42b","modified":1459243301000},{"_id":"source/works/index.md","shasum":"a4a4cebd0f8cf733c864f41f9ad5a6a019f1ec85","modified":1440345711000},{"_id":"themes/yilia/_config.yml","shasum":"68fe748cd1028145dd5f755c592b5fbc161eb303","modified":1489741340000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","shasum":"7f261a47ff582fcf2d2dceaab0d147d388f7ed76","modified":1440498376000},{"_id":"themes/yilia/README.md","shasum":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/archive.ejs","shasum":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","shasum":"8dfb6d68aa8a0661d26c32ce1ce1f45815364c3a","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/article.ejs","shasum":"ef8dd558f908f293c34123c0b7ff879d2fd0c09f","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/footer.ejs","shasum":"7eb2e9e5220fb14d5fb397e07d3c628be02adb2b","modified":1459434738000},{"_id":"themes/yilia/layout/_partial/head.ejs","shasum":"2dca7a3b2d047798d21b264660852dcc59c3ca86","modified":1459434863000},{"_id":"themes/yilia/layout/_partial/header.ejs","shasum":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","shasum":"70a9951e4e2d30aabba88e75c3fa54b9235ce6a6","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","shasum":"cd0af87ee781ac9c2b0e6a2a05b063d4bd497d9c","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","shasum":"54fab4d3d64cb937d6baec7324ffabf9f202b883","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","shasum":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","shasum":"c0c988334e857a77ba455a056dfa21809e7e76a5","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","shasum":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","shasum":"da39b4ba0c0ce4e1932fd45c5aee10e8aca41f28","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","shasum":"d19dee2082528e1844bed3aa4e4bd59f15fd7a7a","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","shasum":"78612cfc091d7d861a70455a0dc8c3036e460879","modified":1437569174000},{"_id":"themes/yilia/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1437569174000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1437569174000},{"_id":"themes/yilia/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1437569174000},{"_id":"themes/yilia/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1437569174000},{"_id":"themes/yilia/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1437569174000},{"_id":"themes/yilia/layout/layout.ejs","shasum":"4a5566f704f3246f5ef77badddf18d2e16750328","modified":1437569174000},{"_id":"themes/yilia/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1437569174000},{"_id":"themes/yilia/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1437569174000},{"_id":"themes/yilia/package.json","shasum":"00357ef6f24eb049074da81809e98f973f528cca","modified":1437569174000},{"_id":"themes/yilia/source/css/_extend.styl","shasum":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/archive.styl","shasum":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/article.styl","shasum":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/header.styl","shasum":"67e59feb18eee6026717cb440d86ab9551782628","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/footer.styl","shasum":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/highlight.styl","shasum":"8cadf8437ce6f372802d3d28617a1ab97e7c818e","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/instagram.styl","shasum":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/main.styl","shasum":"4268f759920106a576c6037264076b36018ff73b","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","shasum":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/page.styl","shasum":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/scroll.styl","shasum":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/mobile.styl","shasum":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/share.styl","shasum":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","shasum":"af0115de5c6455f899a2e09225b50224982c039d","modified":1437569174000},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","shasum":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1437569174000},{"_id":"themes/yilia/source/css/_util/grid.styl","shasum":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1437569174000},{"_id":"themes/yilia/source/css/_util/mixin.styl","shasum":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1437569174000},{"_id":"themes/yilia/source/css/_variables.styl","shasum":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1437569174000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1437569174000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1437569174000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","shasum":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1437569174000},{"_id":"themes/yilia/source/css/style.styl","shasum":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1437569174000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","shasum":"a82597493d75ea989ca586e09173cff332efe41e","modified":1437569174000},{"_id":"themes/yilia/source/img/coderwall.png","shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1437569174000},{"_id":"themes/yilia/source/img/delicious.png","shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1437569174000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1437569174000},{"_id":"themes/yilia/source/img/facebook.png","shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1437569174000},{"_id":"themes/yilia/source/img/douban.png","shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1437569174000},{"_id":"themes/yilia/source/img/github.png","shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1437569174000},{"_id":"themes/yilia/source/img/google.png","shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1437569174000},{"_id":"themes/yilia/source/img/img-err.png","shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1437569174000},{"_id":"themes/yilia/source/img/img-loading.png","shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1437569174000},{"_id":"themes/yilia/source/img/linkedin.png","shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1437569174000},{"_id":"themes/yilia/source/img/mail.png","shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1437569174000},{"_id":"themes/yilia/source/img/pinterest.png","shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1437569174000},{"_id":"themes/yilia/source/img/pinboard.png","shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1437569174000},{"_id":"themes/yilia/source/img/rss.png","shasum":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1437569174000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1437569174000},{"_id":"themes/yilia/source/img/stackoverflow.png","shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1437569174000},{"_id":"themes/yilia/source/img/weibo.png","shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1437569174000},{"_id":"themes/yilia/source/img/twitter.png","shasum":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1437569174000},{"_id":"themes/yilia/source/img/zhihu.png","shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1437569174000},{"_id":"themes/yilia/source/js/instagram.js","shasum":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1437569174000},{"_id":"themes/yilia/source/js/jquery.lazyload.js","shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1437569174000},{"_id":"themes/yilia/source/js/mobile.js","shasum":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1437569174000},{"_id":"themes/yilia/source/js/main.js","shasum":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1437569174000},{"_id":"themes/yilia/source/js/pc.js","shasum":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1437569174000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1437569174000},{"_id":"source/citstar/images/citstar2.JPG","shasum":"140901457762358913a987d18933983695703152","modified":1427558642000},{"_id":"source/citstar/images/citstar3.JPG","shasum":"9c37d103bbb0e0299a85fa57bd416cbbe99be715","modified":1427558615000},{"_id":"source/citstar/images/citstar1.JPG","shasum":"201f411237c80a439ba940df8129d4d5d93e7aea","modified":1427558599000},{"_id":"source/citstar/images/citstar4.JPG","shasum":"8a46e46359a6fef77af083c2c34eea0b530c4c62","modified":1428049693000},{"_id":"source/citstar/images/citstar5.JPG","shasum":"d86a36092ae3345a25b8a0d54385f7c33a2ab788","modified":1427558697000},{"_id":"source/citstar/images/citstar6.JPG","shasum":"c61a5fc990d8813556efebc33f359b34768b3542","modified":1427558625000},{"_id":"source/citstar/images/citstar7.JPG","shasum":"4bdba207cf7a6592b8bb4f5811287c43d259e9ed","modified":1427558724000},{"_id":"public/js/pc.js","modified":1480337900500,"shasum":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10"},{"_id":"public/js/mobile.js","modified":1480337900503,"shasum":"b68cc01d24e80973c48205f551da87f3f3427644"},{"_id":"public/js/main.js","modified":1480337900504,"shasum":"0640b68a76fab3c693b3cd1e4d04d14be1e53940"},{"_id":"public/js/jquery.lazyload.js","modified":1480337900505,"shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799"},{"_id":"public/js/instagram.js","modified":1480337900506,"shasum":"f19adbcc0dac33536bc6660598059048ec901882"},{"_id":"public/img/zhihu.png","modified":1480337900511,"shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d"},{"_id":"public/img/weibo.png","modified":1480337900515,"shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b"},{"_id":"public/img/twitter.png","modified":1480337900516,"shasum":"14dbb8e62d056525253bc0de13acd1723da7a934"},{"_id":"public/img/stackoverflow.png","modified":1480337900517,"shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2"},{"_id":"public/img/scrollbar_arrow.png","modified":1480337900517,"shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0"},{"_id":"public/img/rss.png","modified":1480337900518,"shasum":"430fd47340e75214c081abd05cd7410cf7c71b86"},{"_id":"public/img/pinterest.png","modified":1480337900520,"shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630"},{"_id":"public/img/pinboard.png","modified":1480337900521,"shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0"},{"_id":"public/img/mail.png","modified":1480337900522,"shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7"},{"_id":"public/img/linkedin.png","modified":1480337900523,"shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c"},{"_id":"public/img/img-loading.png","modified":1480337900524,"shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031"},{"_id":"public/img/img-err.png","modified":1480337900525,"shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b"},{"_id":"public/img/google.png","modified":1480337900526,"shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d"},{"_id":"public/img/github.png","modified":1480337900527,"shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d"},{"_id":"public/img/facebook.png","modified":1480337900528,"shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54"},{"_id":"public/img/douban.png","modified":1480337900529,"shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e"},{"_id":"public/img/delicious.png","modified":1480337900531,"shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd"},{"_id":"public/img/coderwall.png","modified":1480337900532,"shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1480337900534,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1480337900536,"shasum":"a82597493d75ea989ca586e09173cff332efe41e"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1480337900538,"shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1480337900540,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1480337900541,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1480337900542,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1480337900544,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1480337900545,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1480337900547,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1480337900548,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1480337900550,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1480337900551,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1480337900552,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1480337900553,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1480337900554,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1480337901082,"shasum":"e56554c624d9d49e9429eeeb9222488f8df634ec"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1480337901262,"shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1480337901264,"shasum":"1480b8101b02da9bc4c60341b5e185e63e585064"},{"_id":"public/css/fonts/fontawesome-webfont.svgz","modified":1480337901265,"shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1480337901268,"shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1480337901274,"shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6"},{"_id":"public/citstar/images/citstar7.JPG","modified":1480337901297,"shasum":"4bdba207cf7a6592b8bb4f5811287c43d259e9ed"},{"_id":"public/citstar/images/citstar6.JPG","modified":1480337901326,"shasum":"c61a5fc990d8813556efebc33f359b34768b3542"},{"_id":"public/citstar/images/citstar5.JPG","modified":1480337901353,"shasum":"d86a36092ae3345a25b8a0d54385f7c33a2ab788"},{"_id":"public/citstar/images/citstar4.JPG","modified":1480337901387,"shasum":"8a46e46359a6fef77af083c2c34eea0b530c4c62"},{"_id":"public/citstar/images/citstar3.JPG","modified":1480337901413,"shasum":"9c37d103bbb0e0299a85fa57bd416cbbe99be715"},{"_id":"public/citstar/images/citstar2.JPG","modified":1480337901434,"shasum":"140901457762358913a987d18933983695703152"},{"_id":"public/citstar/images/citstar1.JPG","modified":1480337901457,"shasum":"201f411237c80a439ba940df8129d4d5d93e7aea"},{"_id":"public/works/index.html","modified":1542964640982,"shasum":"6fbc6746fe0c9d72820c9b7339c0ec9d6dbeb505"},{"_id":"public/timeline/index.html","modified":1542964640989,"shasum":"bc08665c6b239eb328ac6001252f06810dfb93ae"},{"_id":"public/citstar/index.html","modified":1542964640998,"shasum":"7a754f1f88b23aa9fcf227d1b255790f0d53b97d"},{"_id":"public/2016/02/06/mactools/index.html","modified":1542964641033,"shasum":"e5b8a564395546810d96797e08993401b41d02f6"},{"_id":"public/2016/01/17/ssh-add-mac/index.html","modified":1542964641040,"shasum":"9cf896277057d26bbb6d8ef3aa42f7da5028e501"},{"_id":"public/2015/12/23/2015-12-23-AndroidLibraryJitPack/index.html","modified":1542964641047,"shasum":"45a16c6e65ac42cb263cbba84cde2f94f105db5c"},{"_id":"public/2015/12/15/2015-12-15-AndroidStudioSerialVersionUID/index.html","modified":1542964641055,"shasum":"e48595c1f73ded718d673d21461cf6acb3f73cfc"},{"_id":"public/2015/12/13/2015-12-13-AndroidStudioShortCuts/index.html","modified":1542964641064,"shasum":"6b4cef6f813d9cc91052aa5278101ee123ab5229"},{"_id":"public/2015/11/29/2015-11-29-manuscript/index.html","modified":1542964641070,"shasum":"e5906946ae439f2f8816d2ace4cc0476dca66ac3"},{"_id":"public/2015/11/11/2015-11-11-QTFMService/index.html","modified":1542964641079,"shasum":"bdb1d498b7e4849a2ffb4fa12ee34a2487c2d2db"},{"_id":"public/2015/10/28/2015-10-28-AIDL/index.html","modified":1542964641093,"shasum":"82ffd685144ff8757faf4900c46bea26c13c1907"},{"_id":"public/2015/10/28/2015-10-28-Messenger/index.html","modified":1542964641107,"shasum":"ecba6e76b53323111c2c6d0901822d5c01672a3b"},{"_id":"public/2015/10/22/2015-10-22-ViewMeasure/index.html","modified":1542964641116,"shasum":"be177f645db1051b44aff09343b2d5e5765a967d"},{"_id":"public/2015/10/11/2015-10-11-getMainLooper/index.html","modified":1542964641128,"shasum":"83df54ae3a0ed01bdb8d3718ab456fc32a19af65"},{"_id":"public/2015/10/11/2015-10-11-IntentService源码解析/index.html","modified":1542964641123,"shasum":"0e95a2dce760b7069bda2a0d89b13cc77dfbf360"},{"_id":"public/2015/10/11/2015-10-11-HandlerThread源码解析/index.html","modified":1542964641136,"shasum":"b61fbcbe4896ae1be784d9bac8c779fff18f6968"},{"_id":"public/2015/10/09/2015-10-09- Java笔试题随记/index.html","modified":1542964641141,"shasum":"3e13c59b0da1d2723791dfc08ce89b8921ee6a30"},{"_id":"public/2015/10/08/2015-10-08- 自己真正读过的好书/index.html","modified":1542964641148,"shasum":"1f2f6687994299080421cfdc5b92e653cdf9fc5f"},{"_id":"public/2015/10/07/2015-10-07- Android开发艺术探索/index.html","modified":1542964641157,"shasum":"9fd7a89bd788f7ff8c3f65188882f00abeb5fc7a"},{"_id":"public/2015/10/06/2015-10-06- Android群英传/index.html","modified":1542964641162,"shasum":"684f65563f19089140e8d8981604eed7c4193e79"},{"_id":"public/2015/09/16/2015-09-16- JIT 学习笔记/index.html","modified":1542964641175,"shasum":"0d87cbb9adf8b47f39086030b30a9b2faf6b7017"},{"_id":"public/2015/09/15/2015-09-16-BlockingQueue/index.html","modified":1542964641182,"shasum":"ed963b0286cf187657bbcae9389bd8e0dfd09d17"},{"_id":"public/2015/09/14/2015-09-14-CopyOnWrite/index.html","modified":1542964641194,"shasum":"51ace5fecc7ec0035a054537335f1f4ad691a839"},{"_id":"public/2015/09/14/2015-09-14- 设计模式-导图/index.html","modified":1542964641226,"shasum":"b66012ee77e8cb80c3f236dbd04d7079ceb27ae5"},{"_id":"public/2015/09/14/2015-09-14- 第一行代码-导图/index.html","modified":1542964641187,"shasum":"637e310e0b8c480a512599d93cc91bcd7f718595"},{"_id":"public/2015/09/14/2015-09-14- 数据结构-导图/index.html","modified":1542964641233,"shasum":"90bb9be066e88eeee14f698b0bb5bf5e26fb9a67"},{"_id":"public/2015/09/14/2015-09-14- 单链表逆置/index.html","modified":1542964641200,"shasum":"2479e0decbd2b59f184e0255f5d4861a4e8a36a0"},{"_id":"public/2015/09/14/2015-09-14- Java 基础知识-导图/index.html","modified":1542964641210,"shasum":"d279ab9c74cc4fa5fe5e101d7179b587982ab204"},{"_id":"public/2015/09/14/2015-09-14- Android 进阶-导图/index.html","modified":1542964641216,"shasum":"515b3a220a9a6ac835cfab02b7005b7f981427c8"},{"_id":"public/2015/09/14/2015-09-14-ConcurrentHashMap/index.html","modified":1542964641221,"shasum":"bee8d36503e04cd0bdf05d8d7ec7b3cf435e6ed5"},{"_id":"public/2015/09/13/2015-09-13- Java字符集与编码/index.html","modified":1542964641239,"shasum":"53cb699fa2965535674e522ca4f443412a30ddb9"},{"_id":"public/2015/09/06/2015-09-06- Android开发中的大坑/index.html","modified":1542964641246,"shasum":"6e743b06f7cb08947dce06d5b2f3b2ee2055aee9"},{"_id":"public/2015/08/30/2015-08-30- mac下抓包工具--Charles/index.html","modified":1542964641253,"shasum":"158aefc1ca93687e164f60a9cfd6c4d918fc1c35"},{"_id":"public/2015/08/28/2015-08-28- 每日学习炸鸡/index.html","modified":1542964641263,"shasum":"27be122906d7f226aa504c3f2984753e9ab334ab"},{"_id":"public/2015/08/24/2015-08-24-【视频教程】Android 开发实战：自动检测更新功能的实现/index.html","modified":1542964641269,"shasum":"3e0d048c0d5829b9241f4c59bad7a5fd3b55248c"},{"_id":"public/2015/08/23/2015-08-15- mac下抓包工具--Debookee/index.html","modified":1542964641273,"shasum":"c8d86522e55a9e090489bdc794097a4b1b9fe55f"},{"_id":"public/2015/07/25/2015-07-25- python-urllib超时/index.html","modified":1542964641279,"shasum":"444a87c279188d39c637cc249ff32db775d2654a"},{"_id":"public/2015/06/23/2015-06-23- 网站登录模块开发安全加固/index.html","modified":1542964641287,"shasum":"8b110baca4c0c82c2907c2d49815575a84bf684e"},{"_id":"public/2015/06/23/2015-06-23- 【视频教程】网站登录模块开发安全加固/index.html","modified":1542964641294,"shasum":"a489240f24bdeff8610e0a8f64acba32b31663e9"},{"_id":"public/2015/06/17/2015-06-17- 【视频教程】安全协议和认证服务/index.html","modified":1542964641301,"shasum":"6f0820e666eb760864ab013be3c83380013cbdaa"},{"_id":"public/2015/06/10/2015-06-10- 典型tcp攻击实验/index.html","modified":1542964641317,"shasum":"6240d5511577fdc0ecb57c103aa89b3a1b625f01"},{"_id":"public/2015/06/10/2015-06-10- wireshark找不到interface/index.html","modified":1542964641306,"shasum":"6a40ae323a2903d0913b66b5460f67b47d2c0a2b"},{"_id":"public/2015/06/05/2015-06-05- helen/index.html","modified":1542964641321,"shasum":"7da8afbabd7df93c2ba2bb22d20a8433a726d4f5"},{"_id":"public/2015/06/05/2015-06-05- 获取微信聊天记录/index.html","modified":1542964641326,"shasum":"b3f7cdcd6966f2def6562c9cec432581ee41a317"},{"_id":"public/2015/06/04/2015-06-04-【视频教程】证书的概念和使用/index.html","modified":1542964641334,"shasum":"b9306bb2dfb49abee694f3d64a26abc11ce6a4f6"},{"_id":"public/2015/06/02/2015-06-02-【视频教程】数字签名的编程使用/index.html","modified":1542964641339,"shasum":"79c351c1e1e3fa357db2680d7b8ff3741aa631eb"},{"_id":"public/2015/05/21/2015-05-21-【视频教程】非对称密码的编程使用/index.html","modified":1542964641347,"shasum":"00c2d83c087ada56d2988c553d57687c6148ef58"},{"_id":"public/2015/05/13/2015-05-13-【视频教程】Octopress 搭建静态博客网站/index.html","modified":1542964641352,"shasum":"33593bb78506e944bc2997aba5e2b69147bf9f53"},{"_id":"public/2015/05/04/2015-05-04-【视频教程】对称密码的编程使用/index.html","modified":1542964641357,"shasum":"63bb80066338976bad1cb7b09943d69f066f5fa8"},{"_id":"public/2015/05/03/2015-05-15- Android常用网络请求框架的使用/index.html","modified":1542964641367,"shasum":"bde9ccc5673c1a89802b0007eea281ae735d5bd0"},{"_id":"public/2015/05/03/2015-05-03- Ubuntu1204无法登录桌面/index.html","modified":1542964641361,"shasum":"70b6f065fcea92c7461dc2b76acd1dc835edd7ec"},{"_id":"public/2015/04/28/2015-04-28-【视频教程】消息摘要的编程使用/index.html","modified":1542964641371,"shasum":"dc42cdd7716c273b828d7785e669f843b0ec9e5a"},{"_id":"public/2015/04/18/2015-04-18-算法之数组/index.html","modified":1542964641390,"shasum":"128741bc03f94076983a6575e82b563129d82b68"},{"_id":"public/2015/04/18/2015-04-18-排序算法总结/index.html","modified":1542964641384,"shasum":"35c3a43bdc1a5a8976b253618347fd13570f6ab6"},{"_id":"public/2015/04/18/2015-04-18-图总结/index.html","modified":1542964641395,"shasum":"9cea8a58d8f566fe554a3f9e5e07ccba5eeac958"},{"_id":"public/2015/04/18/2015-04-18-二叉树总结/index.html","modified":1542964641378,"shasum":"859b4aaefacc521072bab1438a85da309cd8af60"},{"_id":"public/2015/04/16/2015-04-16-【视频教程】Base64编码的编程使用/index.html","modified":1542964641402,"shasum":"1eaf6244fe5dcf82d25d1a91f0f729161b5237b8"},{"_id":"public/2015/04/10/2015-04-10- 在 Mac 下安装 mysql for python/index.html","modified":1542964641407,"shasum":"04e85c52f255a4edd3636a53cf9673a40f3c5f28"},{"_id":"public/2015/03/15/2015-03-15-【视频教程】Fedora 升级 Kernel 至最新版本/index.html","modified":1542964641416,"shasum":"e58d380f0de805509d5fac707df5414c836910ee"},{"_id":"public/2015/02/28/2015-02-28-【视频教程】Android 项目开发实战--新闻客户端/index.html","modified":1542964641424,"shasum":"f08ca1728caf99d009005b7be255118d25bde820"},{"_id":"public/2015/01/15/2015-01-15-【视频教程】Android 中 Action Bar 的使用/index.html","modified":1542964641430,"shasum":"150b017649173dc73f922a7cadebf4a3c76b8b99"},{"_id":"public/2014/12/30/2014-12-30-【视频教程】Android 侧滑菜单之 DrawerLayout 的使用/index.html","modified":1542964641436,"shasum":"253d03868b0d34555ee97d6b87b3c88988be7379"},{"_id":"public/2014/12/19/2014-12-19-【视频教程】Android 扫描二维码实现网页登录/index.html","modified":1542964641445,"shasum":"ce67f7206b90ed5d8e8c9652eee55dde26839d4a"},{"_id":"public/2014/12/04/2014-12-04-AndroidCollection/index.html","modified":1542964641455,"shasum":"b028be4c3b40594f8ede80ce9fd6bc35ec61a241"},{"_id":"public/2014/11/29/2014-11-29-编程实现可靠数据传输原理 Go-Back-N/index.html","modified":1542964641461,"shasum":"750a74d63a246c2fec3723bc604d5324a6951f2a"},{"_id":"public/2014/11/27/2014-11-27-编程实现路由算法--迪杰斯特拉算法/index.html","modified":1542964641468,"shasum":"24b2097f46deedd76f7d1651680376e07fb42c3e"},{"_id":"public/2014/10/31/2014-10-31-Java 实现 AES 算法/index.html","modified":1542964641474,"shasum":"7a877da5203296dbce6d8f43634add0a9de3dfed"},{"_id":"public/2014/10/25/2014-10-25-使用 Wireshark 抓包分析的思考/index.html","modified":1542964641478,"shasum":"084f8cb5a12a784a164048e25edf3835f8c51307"},{"_id":"public/2014/10/22/2014-12-22-ThreadSynchronization/index.html","modified":1542964641484,"shasum":"d5a89a31eda47b2927691efe45d84e257d145910"},{"_id":"public/2014/10/20/2014-10-20-再谈用 Java 实现 SMTP 发送邮件之 Socket 编程/index.html","modified":1542964641492,"shasum":"3d747e30cec2fd0fa28dbd699cc6fdb3098cfe1e"},{"_id":"public/2014/10/18/2014-10-18-浅谈用 Java 搭建 web 服务器之 Socket 编程——更好的理解 Apache、Tomcat 等软件的工作模式/index.html","modified":1542964641500,"shasum":"629e213f37e9047ec56e15bd96e737509140e7c1"},{"_id":"public/archives/index.html","modified":1542964641517,"shasum":"723f61f898ead0dda34ead05d64347ab33b03a7c"},{"_id":"public/archives/page/2/index.html","modified":1542964641527,"shasum":"11c73ab3a40288f840af3e8ea42cf427fd435b4d"},{"_id":"public/archives/page/3/index.html","modified":1542964641538,"shasum":"d0681127031619e4eac494b065c70240aac7aa77"},{"_id":"public/archives/page/4/index.html","modified":1542964641548,"shasum":"dfbcf6897112013a900af3fa428b4981d1add74a"},{"_id":"public/archives/page/5/index.html","modified":1542964641560,"shasum":"ffc13872518ea0c6c51f5cebd8033b957570c262"},{"_id":"public/archives/page/6/index.html","modified":1542964641571,"shasum":"357a26c34673f30c6eec2d4457f42fc024e8af04"},{"_id":"public/archives/page/7/index.html","modified":1542964641585,"shasum":"0663e518214892edc0a8324b2c94061f0844d3e5"},{"_id":"public/archives/2014/index.html","modified":1542964641600,"shasum":"d0889b0e83fb3cf08d74577fdbe45e2fec747e78"},{"_id":"public/archives/2014/10/index.html","modified":1542964641606,"shasum":"bc8e684eed1b0fb8f868648ec523068ae50bbb84"},{"_id":"public/archives/2014/11/index.html","modified":1542964641609,"shasum":"d58df87d53c5904c0d5513765815388dd01fa901"},{"_id":"public/archives/2014/12/index.html","modified":1542964641613,"shasum":"8c0dab2e7f940db678aeb4abe72cabd7307c0867"},{"_id":"public/archives/2015/index.html","modified":1542964641623,"shasum":"9be8ae5b04e9662a3fe9781398aa058cfe85783b"},{"_id":"public/archives/2015/page/2/index.html","modified":1542964641633,"shasum":"deb097c6fe81ec65daf7628cbf3eda4a874ddb2c"},{"_id":"public/archives/2015/page/3/index.html","modified":1542964641644,"shasum":"1cbabf5010097c47a320dcecf66d457929c04d0f"},{"_id":"public/archives/2015/page/4/index.html","modified":1542964641655,"shasum":"3ebadec305b58d4cfddb7d67d14e4d6e0d7954ce"},{"_id":"public/archives/2015/page/5/index.html","modified":1542964641666,"shasum":"6fe0b9cb2676d5cc256b6ed5e3d97d2cf097a15b"},{"_id":"public/archives/2015/page/6/index.html","modified":1542964641673,"shasum":"da1ae17afc5a708f0ac5d55ee0c31a650f0796d2"},{"_id":"public/archives/2015/01/index.html","modified":1542964641676,"shasum":"321171d543123c7cadea3924e8e6d8fa9013fa55"},{"_id":"public/archives/2015/02/index.html","modified":1542964641680,"shasum":"c749361dd90237ff2c78cb69d5f9500190859310"},{"_id":"public/archives/2015/03/index.html","modified":1542964641683,"shasum":"cf665b2494e32c065d58888ee205e95018737f4d"},{"_id":"public/archives/2015/04/index.html","modified":1542964641690,"shasum":"154dd2f717e31f42728eacbda7d3bd779f8a8aab"},{"_id":"public/archives/2015/05/index.html","modified":1542964641696,"shasum":"0854a4e7fd2ac803db27f7ef13b1fabacf1fb4eb"},{"_id":"public/archives/2015/06/index.html","modified":1542964641711,"shasum":"158ec2e6079f2fd7716406139bbf68d61bf81630"},{"_id":"public/archives/2015/07/index.html","modified":1542964641718,"shasum":"46eda9bea1f76cf19a28b7545cf707cfe2fa1013"},{"_id":"public/archives/2015/08/index.html","modified":1542964641723,"shasum":"832a71d64068f251da145aa2ce4031a652260b9d"},{"_id":"public/archives/2015/09/index.html","modified":1542964641733,"shasum":"c30a98e2ccfbf4d35e0dc4c4a99d458b6d73b7b4"},{"_id":"public/archives/2015/09/page/2/index.html","modified":1542964641736,"shasum":"b5fe868626fb3d3f13f233d89ad239300c2bc87d"},{"_id":"public/archives/2015/10/index.html","modified":1542964641746,"shasum":"0632fb11636e37c47b30daf263c58fa18229468a"},{"_id":"public/archives/2015/11/index.html","modified":1542964641751,"shasum":"ca937b5efffb62b3e517ff65116ecee0f1a06a8e"},{"_id":"public/archives/2015/12/index.html","modified":1542964641756,"shasum":"934d940fbc745a283bb0ac802cfd46484ed23edb"},{"_id":"public/archives/2016/index.html","modified":1542964641760,"shasum":"3a66e005a59d5e263035d50584a2568825c06929"},{"_id":"public/archives/2016/01/index.html","modified":1542964641764,"shasum":"b119c7a0b15c31b6cd7b18cd2d2029f06a804824"},{"_id":"public/archives/2016/02/index.html","modified":1542964641768,"shasum":"29361b634a3092595c014fe1d363b730390dc318"},{"_id":"public/index.html","modified":1542964641969,"shasum":"f8f7d216e43fcd8023d77b5b910026f2b96c0e42"},{"_id":"public/page/2/index.html","modified":1542964641979,"shasum":"73ec6b30322043553205aa7c9db4133626b0d889"},{"_id":"public/page/3/index.html","modified":1542964641989,"shasum":"6724173dbdb7d48ccbefd07b36cad9c4a4116d86"},{"_id":"public/page/4/index.html","modified":1542964641999,"shasum":"f7363b60755e862c7976b8fc48584f79771d4de3"},{"_id":"public/page/5/index.html","modified":1542964642010,"shasum":"2b12aa65cc55e1fefd8b3cdee7c225a3bf6897f3"},{"_id":"public/page/6/index.html","modified":1542964642021,"shasum":"af5bcdb6ee000a6cf6aa31f39f1f7090feadcf85"},{"_id":"public/page/7/index.html","modified":1542964642031,"shasum":"f7a8fe7aff7d3d34a6c6507a6d580b99a17d987c"},{"_id":"public/tags/Git/index.html","modified":1542964641785,"shasum":"60b29a15b46b128a89a45344353a1c616655b092"},{"_id":"public/tags/Mac/index.html","modified":1542964641789,"shasum":"aedccc36ea7dcc84b911eaaa370dff332be4550a"},{"_id":"public/tags/android/index.html","modified":1542964641794,"shasum":"d358d19d3a78a429f16144053735062921df8472"},{"_id":"public/tags/icodeyou/index.html","modified":1542964641803,"shasum":"28d3c4ef3d2beab873f8715b5828d3583dd4b2fe"},{"_id":"public/tags/Android/index.html","modified":1542964641815,"shasum":"2cdc878ce7c3f292fedd1b284127f79e9f2f82fb"},{"_id":"public/tags/Android/page/2/index.html","modified":1542964641825,"shasum":"3d9ed2b79930ea9bc4c81b3645a97c536cd16df7"},{"_id":"public/tags/Android/page/3/index.html","modified":1542964641830,"shasum":"eb14577d1804f1a36dbe3d269b07cd9308403e73"},{"_id":"public/tags/Java/index.html","modified":1542964641843,"shasum":"108e267c4eebb80e7e7a503a3c111fb3a959b431"},{"_id":"public/tags/Java/page/2/index.html","modified":1542964641853,"shasum":"92166fd32008f9a86645cbc0b7745a79bf2929fa"},{"_id":"public/tags/设计模式/index.html","modified":1542964641856,"shasum":"c82e652e7ffcb366a381ecf5241b27e9a0abe050"},{"_id":"public/tags/数据结构/index.html","modified":1542964641859,"shasum":"b12e54bd40685ec9dae73de517f78599687134df"},{"_id":"public/tags/数据结构与算法/index.html","modified":1542964641864,"shasum":"c520f7d6725001330c722e14284739297345f60c"},{"_id":"public/tags/极客学院/index.html","modified":1542964641876,"shasum":"15c97768c14deb3f6f6544c58a7b17a234adcfdb"},{"_id":"public/tags/极客学院/page/2/index.html","modified":1542964641882,"shasum":"0f0e2622a8de97a06ab5193d8b19087c94e7f456"},{"_id":"public/tags/Python/index.html","modified":1542964641888,"shasum":"7e5d702b07a324f10778e720e95a2aadf3970900"},{"_id":"public/tags/密码学/index.html","modified":1542964641897,"shasum":"5b5a227b3f0a877a8578d16023f016974c10d797"},{"_id":"public/tags/TCP/index.html","modified":1542964641902,"shasum":"3835dc9ba8e9811ba6514b730f50697bb7d739e5"},{"_id":"public/tags/netwox/index.html","modified":1542964641906,"shasum":"54b9b22a4c38dd6e726e4957844b2a6c4feb5f18"},{"_id":"public/tags/Linux/index.html","modified":1542964641910,"shasum":"af85ddfc7e134f24a3c628ce4c40fb56fd6a1d62"},{"_id":"public/tags/Wireshark/index.html","modified":1542964641915,"shasum":"31e9f6f930e03160792fda363dbdfd52d9a8365c"},{"_id":"public/tags/Octopress/index.html","modified":1542964641922,"shasum":"8236545ff8de6ea3e3996fe8a15f7d02ef8302aa"},{"_id":"public/tags/算法/index.html","modified":1542964641926,"shasum":"a5767a12b26e4aa898dba79b705a9a66c9b0b538"},{"_id":"public/tags/Mysql/index.html","modified":1542964641929,"shasum":"32594f787f12ce9cbc19d566af4834b02588b5dc"},{"_id":"public/tags/GBN/index.html","modified":1542964641932,"shasum":"57740d7b4eca7bcefc18b6ec9380190a85c25b3b"},{"_id":"public/tags/路由算法/index.html","modified":1542964641935,"shasum":"0bf3c538e86a91b3aeb3a51d574e8b306cf29dc1"},{"_id":"public/tags/迪杰斯特拉/index.html","modified":1542964641938,"shasum":"a7752f805424217d16a5d230e5059eb580a28fe0"},{"_id":"public/tags/AES/index.html","modified":1542964641941,"shasum":"f6e3d9cf18d3f84e163b200113d1380ae128f31f"},{"_id":"public/tags/Socket/index.html","modified":1542964641945,"shasum":"a46e3625c995d68110a418a2ffa71e003fc1dab3"},{"_id":"public/tags/SMTP/index.html","modified":1542964641947,"shasum":"e7c765f4dd5b5df73239547da5e8b56d32d78861"},{"_id":"source/videos/index.html","shasum":"743c5e9843bc17411c3e02ad04915a2b01de129d","modified":1489741530000},{"_id":"source/videos/index.md","shasum":"6b4319cd481ab0e4771ec0d4d5ddab7394a27553","modified":1480339176000},{"_id":"public/videos/index.html","modified":1542964641002,"shasum":"b3314b398644ee78c6672fdd6a7bc2f2047ddb69"},{"_id":"source/_drafts/Pycharm远程调试及内网穿透.graffle","shasum":"2acd361f6c0dc84d7f25f31239dbbebf05ddd35b","modified":1542959344777},{"_id":"source/_posts/python-remotedebug.markdown","shasum":"39fe5955eb913bfcf1a004454b407a667a713211","modified":1542964626635},{"_id":"source/_posts/AndroidStudioFindBugs.markdown","shasum":"82331d479e18fccd8d5ec5b6af2001a8ff888b05","modified":1491448598000},{"_id":"public/2018/11/22/python-remotedebug/index.html","modified":1542964641012,"shasum":"85ee80d251b5a661899d226b035d5730f2f30a45"},{"_id":"public/2017/04/06/AndroidStudioFindBugs/index.html","modified":1542964641026,"shasum":"61094c7e536a6072af0f344ed5d53fb8a48a9647"},{"_id":"public/archives/2017/index.html","modified":1542964641771,"shasum":"bb775af6cb41ebcdc2f17095d154c8e6e3e6f21f"},{"_id":"public/archives/2017/04/index.html","modified":1542964641774,"shasum":"177ea5c63be783de876309e3f2902a2150fdfca8"},{"_id":"public/archives/2018/index.html","modified":1542964641778,"shasum":"8c4c1061d22fdc343d0df7b6312b57ea769f55ae"},{"_id":"public/archives/2018/11/index.html","modified":1542964641781,"shasum":"da055a95fe7e934bb2a202e7e05503eb2cac636c"},{"_id":"public/tags/Python-Pycharm-frp/index.html","modified":1542962230425,"shasum":"bdeffd21b0a35f8b1bce4c16faddc8b775f806c1"},{"_id":"public/tags/Pycharm/index.html","modified":1542964641952,"shasum":"d6a8d242d55521e9a6b75ae6f033fd65889b286a"},{"_id":"public/tags/frp/index.html","modified":1542964641956,"shasum":"e906a560434ba505e7a7d1b8147560e5265857d6"}],"Category":[],"Data":[],"Page":[{"title":"works","date":"2015-08-23T16:01:51.000Z","_content":"","source":"works/index.md","raw":"title: works\ndate: 2015-08-24 00:01:51\n---\n","updated":"2015-08-23T16:01:51.000Z","path":"works/index.html","comments":1,"layout":"page","_id":"ciw22ynx80000ek5xndgxosf7"},{"layout":"page","title":"Works","date":"2015-03-27T10:41:00.000Z","comments":1,"sharing":true,"footer":true,"_content":"\n<h4>这个页面许久不更新了。。。</h4>\n\n<h4>Android 口袋编程</h4>\n\n<h4>基于 Android 的点到点安全通信</h4>\n\n<h4>Android 共享课堂</h4>\n\n<h4><a href=\"http://2.lovematch.sinaapp.com\" target=\"_blank\">创意表白应用“捅破窗户纸”  前24h PV：10W   &nbsp;&nbsp;&nbsp;UIP：3W</a></h4>\n\n<h4><a href=\"http://photoplus.sinaapp.com\" target=\"_blank\">微信头像 Anyone+ 应用  前24h PV：40W  &nbsp;&nbsp;&nbsp;UIP：8W</a></h4>\n\n<h4><a href=\"http://bjtuteacher.sinaapp.com\" target=\"_blank\">交大教师节送祝福应用</a></h4>\n\n<h4><a href=\"http://lovegrass.sinaapp.com\" target=\"_blank\">交大追校草应用</a></h4>\n\n<h4><a href=\"http://propaganda.sinaapp.com\" target=\"_blank\">计算机学院团委宣传部招新应用</a></h4>\n\n<h4>Word电子文档密级标识与检测工具（大创竞赛）</h4>\n\n<h4>发现并提交某微信平台 XSS 漏洞，得到采纳</h4>\n\n<h4>发现并提交北京xx大学xx奖学金投票系统漏洞，得到采纳</h4>\n\n<!-- <h4>发现并提交学院科技之星投票系统漏洞，得到采纳</h4> -->\n","source":"works/index.html","raw":"---\nlayout: page\ntitle: \"Works\"\ndate: 2015-03-27 18:41\ncomments: true\nsharing: true\nfooter: true\n---\n\n<h4>这个页面许久不更新了。。。</h4>\n\n<h4>Android 口袋编程</h4>\n\n<h4>基于 Android 的点到点安全通信</h4>\n\n<h4>Android 共享课堂</h4>\n\n<h4><a href=\"http://2.lovematch.sinaapp.com\" target=\"_blank\">创意表白应用“捅破窗户纸”  前24h PV：10W   &nbsp;&nbsp;&nbsp;UIP：3W</a></h4>\n\n<h4><a href=\"http://photoplus.sinaapp.com\" target=\"_blank\">微信头像 Anyone+ 应用  前24h PV：40W  &nbsp;&nbsp;&nbsp;UIP：8W</a></h4>\n\n<h4><a href=\"http://bjtuteacher.sinaapp.com\" target=\"_blank\">交大教师节送祝福应用</a></h4>\n\n<h4><a href=\"http://lovegrass.sinaapp.com\" target=\"_blank\">交大追校草应用</a></h4>\n\n<h4><a href=\"http://propaganda.sinaapp.com\" target=\"_blank\">计算机学院团委宣传部招新应用</a></h4>\n\n<h4>Word电子文档密级标识与检测工具（大创竞赛）</h4>\n\n<h4>发现并提交某微信平台 XSS 漏洞，得到采纳</h4>\n\n<h4>发现并提交北京xx大学xx奖学金投票系统漏洞，得到采纳</h4>\n\n<!-- <h4>发现并提交学院科技之星投票系统漏洞，得到采纳</h4> -->\n","updated":"2016-03-29T09:21:41.000Z","path":"works/index.html","_id":"ciw22ynxb0001ek5xc4kcndsm"},{"title":"timeline","date":"2016-11-28T12:18:29.000Z","_content":"","source":"timeline/index.md","raw":"title: timeline\ndate: 2016-11-28 20:18:29\n---","updated":"2016-11-28T13:19:46.000Z","path":"timeline/index.html","_id":"ciw22ynxc0002ek5xycf095jf","comments":1,"layout":"page"},{"layout":"page","title":"时间线","date":"2016-11-28T12:18:00.000Z","comments":1,"sharing":true,"footer":true,"_content":"\n<h4>2016-11 参加北京GDG，认识了最小演讲者<a href=\"http://chengdazhi.com/\">程大治同学</a>，目前北理工大二在读，佩服至极</h4>\n<h4>2016-06 百度Android入职</h4>\n<h4>2016-04 大四下，所写文章<a href=\"http://androidblog.cn/index.php/Index/detail/id/20\">《Android 窃取手机中微信聊天记录》</a>被 AndroidBlog.cn#19 收录</h4>\n<h4>2016-04 大四下，成为掘金联合编辑(Co-Editor)</h4>\n<h4>2016-01 大四上，搜狐新闻Android实习</h4>\n<h4>2015-11 大四上，楚楚街Android实习</h4>\n<h4>2015-09 大四上，阿里校招B+、P5，终拥抱变化</h4>\n<h4>2015-08 大三下，极客学院就业班实战教练</h4>\n<h4>2015-08 大三下，河南SEC网络安全集训营成员</h4>\n<h4>2015-07 大三下，江苏天创红客训练营成员</h4>\n<h4>2014-12 大三上，获评学校科技之星</h4>\n<h4>2014-12 大三上，担任极客学院Android&信息安全讲师</h4>\n<h4>2014-12 大三上，发现并提交学院科技之星投票系统漏洞，得到采纳</h4>\n<h4>2014-12 大三上，发现并提交北京xx大学思源奖学金投票系统漏洞，得到采纳</h4>\n<h4>2014-12 大三上，发现并提交团xx旗下 MYxxth 微信平台 XSS 漏洞，得到采纳</h4>\n<h4>2014-08 大二下，微信头像 Anyone+ 应用 前24h PV：40W UIP：8W</h4>\n<h4>2014-08 大二下，创意表白应用“捅破窗户纸” 前24h PV：10W UIP：3W</h4>\n<h4>2014-07 大二下，台湾参加《物联网与大数据学术研讨会》</h4>\n<h4>2014-04 大二下，入手icodeyou.com并着手搭建个人网站</h4>\n<h4>2012，大一 北京交通大学信息安全</h4>\n<h4>2011，高三 放弃北大医，复读考计算机</h4>\n<h4>2010，高二 NOIP北京市三等奖</h4>\n<h4>2008，高一 学习谭教授的《C++程序设计》，感谢启蒙林老师</h4>","source":"timeline/index.html","raw":"---\nlayout: page\ntitle: \"时间线\"\ndate: 2016-11-28 20:18\ncomments: true\nsharing: true\nfooter: true\n---\n\n<h4>2016-11 参加北京GDG，认识了最小演讲者<a href=\"http://chengdazhi.com/\">程大治同学</a>，目前北理工大二在读，佩服至极</h4>\n<h4>2016-06 百度Android入职</h4>\n<h4>2016-04 大四下，所写文章<a href=\"http://androidblog.cn/index.php/Index/detail/id/20\">《Android 窃取手机中微信聊天记录》</a>被 AndroidBlog.cn#19 收录</h4>\n<h4>2016-04 大四下，成为掘金联合编辑(Co-Editor)</h4>\n<h4>2016-01 大四上，搜狐新闻Android实习</h4>\n<h4>2015-11 大四上，楚楚街Android实习</h4>\n<h4>2015-09 大四上，阿里校招B+、P5，终拥抱变化</h4>\n<h4>2015-08 大三下，极客学院就业班实战教练</h4>\n<h4>2015-08 大三下，河南SEC网络安全集训营成员</h4>\n<h4>2015-07 大三下，江苏天创红客训练营成员</h4>\n<h4>2014-12 大三上，获评学校科技之星</h4>\n<h4>2014-12 大三上，担任极客学院Android&信息安全讲师</h4>\n<h4>2014-12 大三上，发现并提交学院科技之星投票系统漏洞，得到采纳</h4>\n<h4>2014-12 大三上，发现并提交北京xx大学思源奖学金投票系统漏洞，得到采纳</h4>\n<h4>2014-12 大三上，发现并提交团xx旗下 MYxxth 微信平台 XSS 漏洞，得到采纳</h4>\n<h4>2014-08 大二下，微信头像 Anyone+ 应用 前24h PV：40W UIP：8W</h4>\n<h4>2014-08 大二下，创意表白应用“捅破窗户纸” 前24h PV：10W UIP：3W</h4>\n<h4>2014-07 大二下，台湾参加《物联网与大数据学术研讨会》</h4>\n<h4>2014-04 大二下，入手icodeyou.com并着手搭建个人网站</h4>\n<h4>2012，大一 北京交通大学信息安全</h4>\n<h4>2011，高三 放弃北大医，复读考计算机</h4>\n<h4>2010，高二 NOIP北京市三等奖</h4>\n<h4>2008，高一 学习谭教授的《C++程序设计》，感谢启蒙林老师</h4>","updated":"2016-12-03T04:09:07.000Z","path":"timeline/index.html","_id":"ciw22ynxd0003ek5xsm91sb9p"},{"title":"citstar","date":"2015-08-23T15:57:29.000Z","_content":"","source":"citstar/index.md","raw":"title: citstar\ndate: 2015-08-23 23:57:29\n---\n","updated":"2015-08-23T15:57:29.000Z","path":"citstar/index.html","comments":1,"layout":"page","_id":"ciw22ynxe0004ek5x8umuvur6"},{"layout":"page","title":"科技之星","date":"2015-03-27T11:35:00.000Z","comments":1,"sharing":true,"footer":true,"_content":"\n<link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css\">\n<link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap-theme.min.css\">\n<script src=\"http://cdn.bootcss.com/jquery/1.11.2/jquery.min.js\"></script>\n<script src=\"http://cdn.bootcss.com/bootstrap/3.3.4/js/bootstrap.min.js\"></script>\n\n\n\t<p><a href=\"http://icodeyou.qiniudn.com/科技之星王欢新.ppsx\">科技之星答辩PPT</a></p>\n\n\t<div class=\"video-container\">\n\t\t<video src = \"http://icodeyou.qiniudn.com/完成版.mp4\" controls=\"controls\">\n\t\t</video>\n\t</div>\n\n\n\t<hr />\n\n\n<div id=\"carousel-example-generic\" class=\"carousel slide\" data-ride=\"carousel\">\n  <!-- Indicators -->\n  <ol class=\"carousel-indicators\">\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"0\" class=\"active\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"1\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"2\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"3\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"4\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"5\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"6\"></li>\n  </ol>\n\n  <!-- Wrapper for slides -->\n  <div class=\"carousel-inner\" role=\"listbox\">\n    <div class=\"item active\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar1.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar2.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar3.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar4.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar5.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar5.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar7.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n  </div>\n\n  <!-- Controls -->\n  <a class=\"left carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"prev\">\n    <span class=\"glyphicon glyphicon-chevron-left\" aria-hidden=\"true\"></span>\n    <span class=\"sr-only\">Previous</span>\n  </a>\n  <a class=\"right carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"next\">\n    <span class=\"glyphicon glyphicon-chevron-right\" aria-hidden=\"true\"></span>\n    <span class=\"sr-only\">Next</span>\n  </a>\n</div>\n\n\n\n\n","source":"citstar/index.html","raw":"---\nlayout: page\ntitle: \"科技之星\"\ndate: 2015-03-27 19:35\ncomments: true\nsharing: true\nfooter: true\n---\n\n<link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css\">\n<link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap-theme.min.css\">\n<script src=\"http://cdn.bootcss.com/jquery/1.11.2/jquery.min.js\"></script>\n<script src=\"http://cdn.bootcss.com/bootstrap/3.3.4/js/bootstrap.min.js\"></script>\n\n\n\t<p><a href=\"http://icodeyou.qiniudn.com/科技之星王欢新.ppsx\">科技之星答辩PPT</a></p>\n\n\t<div class=\"video-container\">\n\t\t<video src = \"http://icodeyou.qiniudn.com/完成版.mp4\" controls=\"controls\">\n\t\t</video>\n\t</div>\n\n\n\t<hr />\n\n\n<div id=\"carousel-example-generic\" class=\"carousel slide\" data-ride=\"carousel\">\n  <!-- Indicators -->\n  <ol class=\"carousel-indicators\">\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"0\" class=\"active\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"1\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"2\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"3\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"4\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"5\"></li>\n    <li data-target=\"#carousel-example-generic\" data-slide-to=\"6\"></li>\n  </ol>\n\n  <!-- Wrapper for slides -->\n  <div class=\"carousel-inner\" role=\"listbox\">\n    <div class=\"item active\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar1.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar2.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar3.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar4.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar5.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar5.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n    <div class=\"item\">\n      <img src=\"http://icodeyou.qiniudn.com/citstar7.JPG\">\n      <div class=\"carousel-caption\">\n        把编程当做一种爱\n      </div>\n    </div>\n  </div>\n\n  <!-- Controls -->\n  <a class=\"left carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"prev\">\n    <span class=\"glyphicon glyphicon-chevron-left\" aria-hidden=\"true\"></span>\n    <span class=\"sr-only\">Previous</span>\n  </a>\n  <a class=\"right carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"next\">\n    <span class=\"glyphicon glyphicon-chevron-right\" aria-hidden=\"true\"></span>\n    <span class=\"sr-only\">Next</span>\n  </a>\n</div>\n\n\n\n\n","updated":"2015-06-06T04:18:14.000Z","path":"citstar/index.html","_id":"ciw22ynxf0005ek5xhq1pl24r"},{"layout":"page","title":"视频教程","date":"2015-03-27T12:02:00.000Z","comments":1,"sharing":true,"footer":true,"_content":"\n<div>\n\n<h4><a href=\"../2015/08/24/2015-08-24-【视频教程】Android%20开发实战：自动检测更新功能的实现/\">Android 开发实战：自动检测更新功能的实现</a></h4>\n\n<h4><a href=\"../2015/06/10/2015-06-10-%20典型tcp攻击实验/\">典型 TCP 攻击实验</a></h4>\n\n<h4><a href=\"../2015/05/13/2015-05-13-【视频教程】Octopress%20搭建静态博客网站/\">Octopress 搭建静态博客网站</a></h4>\n\n<h4><a href=\"../2015/06/23/2015-06-23-%20【视频教程】网站登录模块开发安全加固/\">网站登录模块开发安全加固</a></h4>\n\n<h4><a href=\"../2015/06/17/2015-06-17-%20【视频教程】安全协议和认证服务/\">安全协议和认证服务</a></h4>\n\n<h4><a href=\"../2015/06/04/2015-06-04-【视频教程】证书的概念和使用/\">证书的概念和使用</a></h4>\n\n<h4><a href=\"../2015/06/02/2015-06-02-【视频教程】数字签名的编程使用/\">数字签名的编程使用</a></h4>\n\n<h4><a href=\"../2015/05/21/2015-05-21-【视频教程】非对称密码的编程使用/\">非对称密码的编程使用</a></h4>\n\n<h4><a href=\"../2015/05/04/2015-05-04-【视频教程】对称密码的编程使用/\">对称密码的编程使用</a></h4>\n\n<h4><a href=\"../2015/04/28/2015-04-28-【视频教程】消息摘要的编程使用/\">消息摘要的编程使用</a></h4>\n\n<h4><a href=\"../2015/04/16/2015-04-16-【视频教程】Base64编码的编程使用/\">Base64 编码的编程使用</a></h4>\n\n<h4><a href=\"../2015/03/15/2015-03-15-【视频教程】Fedora%20升级%20Kernel%20至最新版本/\">Fedora 升级 Kernel</a></h4>\n\n<h4><a href=\"../2015/02/28/2015-02-28-【视频教程】Android%20项目开发实战--新闻客户端/\">Android 项目开发实战--新闻客户端</a></h4>\n\n<h4><a href=\"../2015/01/15/2015-01-15-【视频教程】Android%20中%20Action%20Bar%20的使用/\">Android 中 Action Bar 的使用</a></h4>\n\n<h4><a href=\"../2014/12/30/2014-12-30-【视频教程】Android%20侧滑菜单之%20DrawerLayout%20的使用/\">Android 侧滑菜单之 DrawerLayout 的使用</a></h4>\n\n<h4><a href=\"../2014/12/19/2014-12-19-【视频教程】Android%20扫描二维码实现网页登录/\">Android 扫描二维码实现网页登录</a></h4>\n\n</div>","source":"videos/index.html","raw":"---\nlayout: page\ntitle: \"视频教程\"\ndate: 2015-03-27 20:02\ncomments: true\nsharing: true\nfooter: true\n---\n\n<div>\n\n<h4><a href=\"../2015/08/24/2015-08-24-【视频教程】Android%20开发实战：自动检测更新功能的实现/\">Android 开发实战：自动检测更新功能的实现</a></h4>\n\n<h4><a href=\"../2015/06/10/2015-06-10-%20典型tcp攻击实验/\">典型 TCP 攻击实验</a></h4>\n\n<h4><a href=\"../2015/05/13/2015-05-13-【视频教程】Octopress%20搭建静态博客网站/\">Octopress 搭建静态博客网站</a></h4>\n\n<h4><a href=\"../2015/06/23/2015-06-23-%20【视频教程】网站登录模块开发安全加固/\">网站登录模块开发安全加固</a></h4>\n\n<h4><a href=\"../2015/06/17/2015-06-17-%20【视频教程】安全协议和认证服务/\">安全协议和认证服务</a></h4>\n\n<h4><a href=\"../2015/06/04/2015-06-04-【视频教程】证书的概念和使用/\">证书的概念和使用</a></h4>\n\n<h4><a href=\"../2015/06/02/2015-06-02-【视频教程】数字签名的编程使用/\">数字签名的编程使用</a></h4>\n\n<h4><a href=\"../2015/05/21/2015-05-21-【视频教程】非对称密码的编程使用/\">非对称密码的编程使用</a></h4>\n\n<h4><a href=\"../2015/05/04/2015-05-04-【视频教程】对称密码的编程使用/\">对称密码的编程使用</a></h4>\n\n<h4><a href=\"../2015/04/28/2015-04-28-【视频教程】消息摘要的编程使用/\">消息摘要的编程使用</a></h4>\n\n<h4><a href=\"../2015/04/16/2015-04-16-【视频教程】Base64编码的编程使用/\">Base64 编码的编程使用</a></h4>\n\n<h4><a href=\"../2015/03/15/2015-03-15-【视频教程】Fedora%20升级%20Kernel%20至最新版本/\">Fedora 升级 Kernel</a></h4>\n\n<h4><a href=\"../2015/02/28/2015-02-28-【视频教程】Android%20项目开发实战--新闻客户端/\">Android 项目开发实战--新闻客户端</a></h4>\n\n<h4><a href=\"../2015/01/15/2015-01-15-【视频教程】Android%20中%20Action%20Bar%20的使用/\">Android 中 Action Bar 的使用</a></h4>\n\n<h4><a href=\"../2014/12/30/2014-12-30-【视频教程】Android%20侧滑菜单之%20DrawerLayout%20的使用/\">Android 侧滑菜单之 DrawerLayout 的使用</a></h4>\n\n<h4><a href=\"../2014/12/19/2014-12-19-【视频教程】Android%20扫描二维码实现网页登录/\">Android 扫描二维码实现网页登录</a></h4>\n\n</div>","updated":"2017-03-17T09:05:30.000Z","path":"videos/index.html","_id":"ciw23qscr0000kw5xj2c4abqu"},{"title":"videos","date":"2015-08-23T16:01:29.000Z","_content":"","source":"videos/index.md","raw":"title: videos\ndate: 2015-08-24 00:01:29\n---","updated":"2016-11-28T13:19:36.000Z","path":"videos/index.html","comments":1,"layout":"page","_id":"ciw23qsdp0001kw5xrx89rurm"}],"Post":[{"title":"Mac 上 ssh-add 永久将私钥添加到 Keychain","date":"2016-01-17T07:04:44.000Z","_content":"\n两种连接 Git 服务器的方式，分别为 HTTPS 和 SSH，显然更推荐后者，所以我们经常使用命令 `ssh-keygen -t rsa -C “me@icodeyou.com”` 来生成 SSH 的公钥和私钥，之后执行 `ssh-add privateKey` 将 SSH 的私钥添加进去，但是发现了一个问题就是`每次重启电脑后都需要重新 ssh-add`，显然每次重启后都需要重新添加让我等程序员肯定受不了，解决办法就是在添加 ssh 私钥的时候使用如下命令： `ssh-add -K privateKey`，即可一劳永逸将私钥添加进 Mac 本身的钥匙串中，即 Keychain。下面简单解释下原理。\n\n<!--more-->\n\n首先得了解一件事：ssh-add 这个命令不是用来永久性的记住你所使用的私钥的。实际上，它的作用只是把你指定的私钥添加到 ssh-agent 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent 服务也就重置了，session 会话也就失效了。\n\n既然 ssh-agent 是个临时的，那么对于 Mac 来说，哪里可以永久存储的，显然就是 Keychain 了，在执行 `ssh-add -K privateKey` 后可以打开偏好设置中的 Keychain来观察一下前后的变化，是不是多出了 SSH 的条目，见下图。\n\n![ssh-add-K](http://7xivx9.com1.z0.glb.clouddn.com/ssh-add-K.png)\n\n后记：其实我最开始以为是 zsh 的问题，看来我是冤枉我的好兄弟了。。。\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/ssh-add-mac.markdown","raw":"title: Mac 上 ssh-add 永久将私钥添加到 Keychain\ndate: 2016-01-17 15:04:44 \ntags: Git\n----\n\n两种连接 Git 服务器的方式，分别为 HTTPS 和 SSH，显然更推荐后者，所以我们经常使用命令 `ssh-keygen -t rsa -C “me@icodeyou.com”` 来生成 SSH 的公钥和私钥，之后执行 `ssh-add privateKey` 将 SSH 的私钥添加进去，但是发现了一个问题就是`每次重启电脑后都需要重新 ssh-add`，显然每次重启后都需要重新添加让我等程序员肯定受不了，解决办法就是在添加 ssh 私钥的时候使用如下命令： `ssh-add -K privateKey`，即可一劳永逸将私钥添加进 Mac 本身的钥匙串中，即 Keychain。下面简单解释下原理。\n\n<!--more-->\n\n首先得了解一件事：ssh-add 这个命令不是用来永久性的记住你所使用的私钥的。实际上，它的作用只是把你指定的私钥添加到 ssh-agent 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent 服务也就重置了，session 会话也就失效了。\n\n既然 ssh-agent 是个临时的，那么对于 Mac 来说，哪里可以永久存储的，显然就是 Keychain 了，在执行 `ssh-add -K privateKey` 后可以打开偏好设置中的 Keychain来观察一下前后的变化，是不是多出了 SSH 的条目，见下图。\n\n![ssh-add-K](http://7xivx9.com1.z0.glb.clouddn.com/ssh-add-K.png)\n\n后记：其实我最开始以为是 zsh 的问题，看来我是冤枉我的好兄弟了。。。\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"ssh-add-mac","published":1,"updated":"2016-01-17T10:57:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynxi0006ek5x9847gi72"},{"title":"我的 Mac 清单","date":"2016-02-06T07:04:44.000Z","_content":"\n我是一个 Android 程序员，使用 Mac 一年了，从各种地方搜集来了很多好用的软件，特此在此记录一下，既方便自己积累用，也供他人参考，本篇长期不定期更新。\n\n<!--more-->\n\n### 常用指数说明\n★★★★★ ： 每次开机必须要运行的\n★★★★  ： 需要时运行，且使用频率很好\n★★★   ： 需要时才会运行\n★★    ： 基本很少打开，但是还不会到卸载的地步\n\n## 开发相关\n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★   |   Dash   |   开发文档速查   |\n|   ★★★★★   |   Google Chrome Canary   |   可以与稳定版Chrome并存，我一般用来翻墙用   |\n|   ★★★★★   |   Kaleidoscope   |   Diff工具，与Git结合   |\n|   ★★★★★   |   Sublime Text   |      |\n|   ★★★★★   |   Bartender   |   让你的菜单栏右上角图标更简洁   |\n|   ★★★★★   |   iTerm + ohmyzsh   |   再好用不过的终端   |\n|   ★★★★★   |   Quiver   |   适合程序员的记录工具   |\n|   ★★★★★   |   SourceTree   |   Git管理工具，程序员离不开 Git 了吧   |\n|   ★★★★   |   Charles   |   一般用于手机代理抓包   |\n|   ★★★   |   SmartFinder for Android   |   锤子出品，Android手机文件传输   |\n|   ★★★   |   VMware Fusion   |   虚拟机   |\n|   ★★★   |   Sip   |   屏幕取色工具，用于自己验证颜色是否符合设计师的要求   |\n|   ★★★   |   Typora   |   MD写作工具   |\n|   ★★   |   Go2Shell   |   以Finder中的直接打开终端   |\n|   ★★   |   ArgoUML、StarUML   |   UML图   |\n|   ★★   |   SQLite Professional   |   SQLite数据库工具   |\n|   ★★   |   Debookee   |   局域网抓包神奇，基于ARP欺骗   |\n|   ★★   |   Cyberduck   |   FTP工具   |\n|   ★   |   Wireshark   |   通用抓包   |\n\n\n## 效率类\n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★★★★★★   |   Alfred 2 2.x [SP]   |   不解释   |\n|   ★★★★★   |   1Password    |   保存密码   |\n|   ★★★★★   |   Paste   |   剪贴板神奇   |\n|   ★★★★★   |   Contexts   |   窗口切换工具   |\n|   ★★★★   |   Snip   |   截图工具，腾讯出品   |\n\n\n## 工具类  \n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★   |   moom   |   窗口大小调整   |\n|   ★★★★★   |   Scroll Reverser   |   鼠标反转   |\n|   ★★★★★   |   Synergy   |   用一个鼠标控制PC&Mac&Linux   |\n|   ★★★★★   |   Unclutter   |   临时记录、临时文件存储   |\n|   ★★★★★   |   The Unarchiver   |   解压   |\n|   ★★★★★   |   Karabiner   |   键盘映射工具，待出个博客专门来讲解一下   |\n|   ★★★★   |   Reeder   |   RSS阅读器   |\n|   ★★★★   |   Pocket   |   稍候阅读   |\n|   ★★★   |   licecap   |   Gif屏幕录制   |\n|   ★★★   |   MindMaple Lite   |   思维导图   |\n|   ★★   |   pixeImator   |   图片处理   |\n|   ★★   |   ScreenFlow   |   屏幕录制   |\n|   ★★   |   Camtasia 2    |   屏幕录制   |\n|   ★★   |   Caffeine   |   保持电脑不进入睡眠   |\n|   ★★   |   Mark Man   |   设计师必备工具，图片标注、测量   |\n\n## 一些小技巧\n\n给Dock加分隔线\nhttp://www.jianshu.com/p/29749e8a759e\n\nAndroid博客订阅（我用的订阅app是上面工具类中的Reeder）\nhttps://github.com/Gracker/Rss-IT\n\n纯文本粘贴\nShift + Option + Cmd + V\n\n命令行中\ndate   ：显示当前日期，如 2016年 2月27日 星期六 10时16分55秒 CST\ncal    ：显示当月日历\nuptime ：显示当前开机时间，如 10:17  up 20 mins, 2 users, load averages: 1.69 1.65 1.27\n\n开挂的 Option\n右键文件，按住 Option 可以设置默认程序、拷贝路径、显示检查器\n点击右上角的电源、网络等按住Option看到更多信息\n\nAlfred Workflow\nChrome Bookmarks、Copy Path、Dash、Kill Process、SourceTree、Youdao Translate\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/mactools.markdown","raw":"title: 我的 Mac 清单\ndate: 2016-02-06 15:04:44 \ntags: Mac\n----\n\n我是一个 Android 程序员，使用 Mac 一年了，从各种地方搜集来了很多好用的软件，特此在此记录一下，既方便自己积累用，也供他人参考，本篇长期不定期更新。\n\n<!--more-->\n\n### 常用指数说明\n★★★★★ ： 每次开机必须要运行的\n★★★★  ： 需要时运行，且使用频率很好\n★★★   ： 需要时才会运行\n★★    ： 基本很少打开，但是还不会到卸载的地步\n\n## 开发相关\n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★   |   Dash   |   开发文档速查   |\n|   ★★★★★   |   Google Chrome Canary   |   可以与稳定版Chrome并存，我一般用来翻墙用   |\n|   ★★★★★   |   Kaleidoscope   |   Diff工具，与Git结合   |\n|   ★★★★★   |   Sublime Text   |      |\n|   ★★★★★   |   Bartender   |   让你的菜单栏右上角图标更简洁   |\n|   ★★★★★   |   iTerm + ohmyzsh   |   再好用不过的终端   |\n|   ★★★★★   |   Quiver   |   适合程序员的记录工具   |\n|   ★★★★★   |   SourceTree   |   Git管理工具，程序员离不开 Git 了吧   |\n|   ★★★★   |   Charles   |   一般用于手机代理抓包   |\n|   ★★★   |   SmartFinder for Android   |   锤子出品，Android手机文件传输   |\n|   ★★★   |   VMware Fusion   |   虚拟机   |\n|   ★★★   |   Sip   |   屏幕取色工具，用于自己验证颜色是否符合设计师的要求   |\n|   ★★★   |   Typora   |   MD写作工具   |\n|   ★★   |   Go2Shell   |   以Finder中的直接打开终端   |\n|   ★★   |   ArgoUML、StarUML   |   UML图   |\n|   ★★   |   SQLite Professional   |   SQLite数据库工具   |\n|   ★★   |   Debookee   |   局域网抓包神奇，基于ARP欺骗   |\n|   ★★   |   Cyberduck   |   FTP工具   |\n|   ★   |   Wireshark   |   通用抓包   |\n\n\n## 效率类\n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★★★★★★   |   Alfred 2 2.x [SP]   |   不解释   |\n|   ★★★★★   |   1Password    |   保存密码   |\n|   ★★★★★   |   Paste   |   剪贴板神奇   |\n|   ★★★★★   |   Contexts   |   窗口切换工具   |\n|   ★★★★   |   Snip   |   截图工具，腾讯出品   |\n\n\n## 工具类  \n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★   |   moom   |   窗口大小调整   |\n|   ★★★★★   |   Scroll Reverser   |   鼠标反转   |\n|   ★★★★★   |   Synergy   |   用一个鼠标控制PC&Mac&Linux   |\n|   ★★★★★   |   Unclutter   |   临时记录、临时文件存储   |\n|   ★★★★★   |   The Unarchiver   |   解压   |\n|   ★★★★★   |   Karabiner   |   键盘映射工具，待出个博客专门来讲解一下   |\n|   ★★★★   |   Reeder   |   RSS阅读器   |\n|   ★★★★   |   Pocket   |   稍候阅读   |\n|   ★★★   |   licecap   |   Gif屏幕录制   |\n|   ★★★   |   MindMaple Lite   |   思维导图   |\n|   ★★   |   pixeImator   |   图片处理   |\n|   ★★   |   ScreenFlow   |   屏幕录制   |\n|   ★★   |   Camtasia 2    |   屏幕录制   |\n|   ★★   |   Caffeine   |   保持电脑不进入睡眠   |\n|   ★★   |   Mark Man   |   设计师必备工具，图片标注、测量   |\n\n## 一些小技巧\n\n给Dock加分隔线\nhttp://www.jianshu.com/p/29749e8a759e\n\nAndroid博客订阅（我用的订阅app是上面工具类中的Reeder）\nhttps://github.com/Gracker/Rss-IT\n\n纯文本粘贴\nShift + Option + Cmd + V\n\n命令行中\ndate   ：显示当前日期，如 2016年 2月27日 星期六 10时16分55秒 CST\ncal    ：显示当月日历\nuptime ：显示当前开机时间，如 10:17  up 20 mins, 2 users, load averages: 1.69 1.65 1.27\n\n开挂的 Option\n右键文件，按住 Option 可以设置默认程序、拷贝路径、显示检查器\n点击右上角的电源、网络等按住Option看到更多信息\n\nAlfred Workflow\nChrome Bookmarks、Copy Path、Dash、Kill Process、SourceTree、Youdao Translate\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"mactools","published":1,"updated":"2016-02-27T02:25:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynxp0009ek5x92j3is2e"},{"title":"写自己的开源库，发布到 JitPack.io","date":"2015-12-23T07:04:44.000Z","_content":"\n之前一直在用别人的开源库，尤其有了 Gradle 后，依赖别人的开源库就更简单了，只需要在项目的 build.gradle 文件中添加上类似 `compile 'com.github.icodeu:CommonAdapter:v1.0'` 的就好了，剩下的就可以交给 Gradle 帮助我们完成 library 依赖了。但这个是怎么做的，如果你也想学习怎么写自己的 library，然后能够提供给别人使用的话，可跟着本篇博客学习一下。本篇分为两个部分，首先讲解如何单纯的写个 library 并在本地自己依赖着(玩)，然后进入主题讲解怎么使用 JitPack.io 来发布我们自己的 library，所以如果你已经知道了怎么写 library，可以直接跳到第二部分。\n\n<!--more-->\n\n我也试图在网上找一些关于使用 JitPack.io 的教程，但是搜出来的基本是[这篇](http://www.tuicool.com/articles/Vv6jEb)的复制品，根本没讲什么实质性的东西，所以一切只好自己来了。\n\n本项目源码地址: [GitHub/icodeu/HelloLibrary](https://github.com/icodeu/HelloLibrary)\n\n## 如何写 library\n\n在本节，我们一起来新建个 library，打开 Android Studio，New Project，在此工程名为 Hellolibrary，此后一直点击 next 直至 finish 即可。此时应该是只有一个 module 名为 app，一会我们会把它当做依赖 library 的示例模块来使用，暂时先不管，我们先来创建一个 library，File->New->Module，选择 Android library，之后起个名字，在此叫做 library，finish 即可，此时工程目录如下所示，其中 app 用来依赖使用 library。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack00.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack01.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack02.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack03.png)\n\n怎么指定一个 module 到底是普通的 application 还是 library 呢？打开 module 对应的 build.gradle 文件，看第一行 `apply plugin: xxx`，如果是 application 的话，plugin 就是 'com.android.application'，library 的话就是 'com.android.library'，就这么简单，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack22.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack23.png)\n\n接下来在 library 中 New->Java Class，在此就是演示，所以我们就尽可能把不重要的东西简单化，名字就叫做 CustomUtil，只有一个静态方法，如下图所示：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack04.png)\n\n其实到此最简单的 library 就写好了，下面就在 app 中来依赖刚才的这个 library 看看效果。打开 app 的 build.gradle，在最后的 dependencies 节点添加一行，`compile project(':library')`，再 Sync 一下 Gradle即可，这样 app 就完成了对 library 的依赖。另外还有一种方法去依赖 library，右键 app 这个 module，选择 Open Module Settings，切换到最后一个Tab:Dependencies，点击左下角的加号->Module dependency->选择 library，这样也能完成 app 对 library 的依赖。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack05.png)\n\n那怎么能在代码上看出来 app 确实成功依赖了 library 呢？我们打开 app 中的 MainActivity，输入 CustomUtil 试一下，如果发现像下图那样给你智能提示了，那就OK了，从下图还能看到 CustomUtil 类所在的包是 com.icodeyou.library。我们调用一下它吧，如下图也很简单，不解释了。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack06.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack07.png)\n\n到此为止我们就自己写了一个最简单的 library 并完成了自己本地的依赖调用，这都是自己玩玩，那怎么能让别人也用上咱们刚才那个高大上的 library 呢，继续往下看。\n\n\n## 如何在 JitPack.io Publish Android Library\n\n首先来概览一下我们要完成的最终效果是什么，我之前有一个开源库，地址在 [https://github.com/icodeu/CommonAdapter](https://github.com/icodeu/CommonAdapter)，打开 JitPack.io 的网站，将我的开源库地址粘贴进去，Look up->Get it，即可看到熟悉的 compile 了，按照下面那个提示复制到相应的 build.gradle 文件中就可以完成 library 的依赖了，不信你试试啊。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack08.png)\n\n下面就来具体讲解一下如何将刚才本地的 library 与 JitPack.io 结合起来，JitPack 的官方文档在这里 [Publish Android library](https://jitpack.io/docs/ANDROID/)\n\n打开 Project 的 root build.gradle，在 dependencies 节点添加一个 classpath：`classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'`，再打开 library 的 build.gradle，在文件起始添加如下两行 `apply plugin: 'com.github.dcendents.android-maven'` `group='com.github.icodeu'`(注意这是你GitHub的用户名)，两个文件的示意图如下：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack09.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack10.png)\n\n下面检查你的Project目录是否存在 gradle/wrapper/gradle-wrapper.jar、gradle-wrapper.properties 这两个文件，如果存在可跳过下面这步，如果不存在，请按下面的进行操作。打开当前项目的 Terminal，先后执行 `gradle wrapper` 和 `./gradlew install` 两个命令，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack11.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack20.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack21.png)\n\n\n从 JitPack 首页也能看出来，其实我们是要粘贴一个 GitHub 项目地址进去，所以我们接下来就要把 library 先上传到 GitHub 上面。\n\n在 GitHub 上新建一个仓库，这里命名为 HelloLibrary，之后 clone 到本地，再把 Project 目录所有的文件复制进去，比如在我这里，仓库 clone 到了桌面的 HelloLibrary 文件夹，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack12.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack13.png)\n\n把这些文件 push 到 GitHub 上，push 成功之后，点击项目的 releases->Create a new release，填写好版本号等内容，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack15.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack16.png)\n\n填写好后点击 Publish release 即可，然后我们复制下图红框中的项目地址，粘贴到 JitPack.io 上面，Look up->Get it，在下面就能看到使用方法了。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack17.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack18.png)\n\n首先打开 Project root 的 build.gradle，在 repositories 节点添加上 `maven { url \"https://jitpack.io\" }`，之后打开想依赖这个 library 的模块，比如这里我们是 app 这个 module，在 dependencies 节点添加上 `compile 'com.github.icodeu:Hellolibrary:v1.0'`，Sync 一下 Gradle，这样就可以了。如果 Sync 成功了，那我们在 app 中就成功依赖了 GitHub 上的 library，此时可以打开 app 的 Module Settings，看一下它的 Dependencies，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack24.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack25.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack19.png)\n\n好了，到此就完成了使用 JitPack.io + GitHub 发布开源库了，相比 jCenter 和 MavenCentral 方式简直爽的不要不要的\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-12-23-AndroidLibraryJitPack.markdown","raw":"title: 写自己的开源库，发布到 JitPack.io\ndate: 2015-12-23 15:04:44 \ntags: android\n----\n\n之前一直在用别人的开源库，尤其有了 Gradle 后，依赖别人的开源库就更简单了，只需要在项目的 build.gradle 文件中添加上类似 `compile 'com.github.icodeu:CommonAdapter:v1.0'` 的就好了，剩下的就可以交给 Gradle 帮助我们完成 library 依赖了。但这个是怎么做的，如果你也想学习怎么写自己的 library，然后能够提供给别人使用的话，可跟着本篇博客学习一下。本篇分为两个部分，首先讲解如何单纯的写个 library 并在本地自己依赖着(玩)，然后进入主题讲解怎么使用 JitPack.io 来发布我们自己的 library，所以如果你已经知道了怎么写 library，可以直接跳到第二部分。\n\n<!--more-->\n\n我也试图在网上找一些关于使用 JitPack.io 的教程，但是搜出来的基本是[这篇](http://www.tuicool.com/articles/Vv6jEb)的复制品，根本没讲什么实质性的东西，所以一切只好自己来了。\n\n本项目源码地址: [GitHub/icodeu/HelloLibrary](https://github.com/icodeu/HelloLibrary)\n\n## 如何写 library\n\n在本节，我们一起来新建个 library，打开 Android Studio，New Project，在此工程名为 Hellolibrary，此后一直点击 next 直至 finish 即可。此时应该是只有一个 module 名为 app，一会我们会把它当做依赖 library 的示例模块来使用，暂时先不管，我们先来创建一个 library，File->New->Module，选择 Android library，之后起个名字，在此叫做 library，finish 即可，此时工程目录如下所示，其中 app 用来依赖使用 library。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack00.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack01.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack02.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack03.png)\n\n怎么指定一个 module 到底是普通的 application 还是 library 呢？打开 module 对应的 build.gradle 文件，看第一行 `apply plugin: xxx`，如果是 application 的话，plugin 就是 'com.android.application'，library 的话就是 'com.android.library'，就这么简单，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack22.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack23.png)\n\n接下来在 library 中 New->Java Class，在此就是演示，所以我们就尽可能把不重要的东西简单化，名字就叫做 CustomUtil，只有一个静态方法，如下图所示：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack04.png)\n\n其实到此最简单的 library 就写好了，下面就在 app 中来依赖刚才的这个 library 看看效果。打开 app 的 build.gradle，在最后的 dependencies 节点添加一行，`compile project(':library')`，再 Sync 一下 Gradle即可，这样 app 就完成了对 library 的依赖。另外还有一种方法去依赖 library，右键 app 这个 module，选择 Open Module Settings，切换到最后一个Tab:Dependencies，点击左下角的加号->Module dependency->选择 library，这样也能完成 app 对 library 的依赖。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack05.png)\n\n那怎么能在代码上看出来 app 确实成功依赖了 library 呢？我们打开 app 中的 MainActivity，输入 CustomUtil 试一下，如果发现像下图那样给你智能提示了，那就OK了，从下图还能看到 CustomUtil 类所在的包是 com.icodeyou.library。我们调用一下它吧，如下图也很简单，不解释了。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack06.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack07.png)\n\n到此为止我们就自己写了一个最简单的 library 并完成了自己本地的依赖调用，这都是自己玩玩，那怎么能让别人也用上咱们刚才那个高大上的 library 呢，继续往下看。\n\n\n## 如何在 JitPack.io Publish Android Library\n\n首先来概览一下我们要完成的最终效果是什么，我之前有一个开源库，地址在 [https://github.com/icodeu/CommonAdapter](https://github.com/icodeu/CommonAdapter)，打开 JitPack.io 的网站，将我的开源库地址粘贴进去，Look up->Get it，即可看到熟悉的 compile 了，按照下面那个提示复制到相应的 build.gradle 文件中就可以完成 library 的依赖了，不信你试试啊。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack08.png)\n\n下面就来具体讲解一下如何将刚才本地的 library 与 JitPack.io 结合起来，JitPack 的官方文档在这里 [Publish Android library](https://jitpack.io/docs/ANDROID/)\n\n打开 Project 的 root build.gradle，在 dependencies 节点添加一个 classpath：`classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'`，再打开 library 的 build.gradle，在文件起始添加如下两行 `apply plugin: 'com.github.dcendents.android-maven'` `group='com.github.icodeu'`(注意这是你GitHub的用户名)，两个文件的示意图如下：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack09.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack10.png)\n\n下面检查你的Project目录是否存在 gradle/wrapper/gradle-wrapper.jar、gradle-wrapper.properties 这两个文件，如果存在可跳过下面这步，如果不存在，请按下面的进行操作。打开当前项目的 Terminal，先后执行 `gradle wrapper` 和 `./gradlew install` 两个命令，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack11.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack20.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack21.png)\n\n\n从 JitPack 首页也能看出来，其实我们是要粘贴一个 GitHub 项目地址进去，所以我们接下来就要把 library 先上传到 GitHub 上面。\n\n在 GitHub 上新建一个仓库，这里命名为 HelloLibrary，之后 clone 到本地，再把 Project 目录所有的文件复制进去，比如在我这里，仓库 clone 到了桌面的 HelloLibrary 文件夹，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack12.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack13.png)\n\n把这些文件 push 到 GitHub 上，push 成功之后，点击项目的 releases->Create a new release，填写好版本号等内容，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack15.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack16.png)\n\n填写好后点击 Publish release 即可，然后我们复制下图红框中的项目地址，粘贴到 JitPack.io 上面，Look up->Get it，在下面就能看到使用方法了。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack17.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack18.png)\n\n首先打开 Project root 的 build.gradle，在 repositories 节点添加上 `maven { url \"https://jitpack.io\" }`，之后打开想依赖这个 library 的模块，比如这里我们是 app 这个 module，在 dependencies 节点添加上 `compile 'com.github.icodeu:Hellolibrary:v1.0'`，Sync 一下 Gradle，这样就可以了。如果 Sync 成功了，那我们在 app 中就成功依赖了 GitHub 上的 library，此时可以打开 app 的 Module Settings，看一下它的 Dependencies，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack24.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack25.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack19.png)\n\n好了，到此就完成了使用 JitPack.io + GitHub 发布开源库了，相比 jCenter 和 MavenCentral 方式简直爽的不要不要的\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-12-23-AndroidLibraryJitPack","published":1,"updated":"2016-03-29T08:49:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynxr000cek5xf0a9m3g2"},{"title":"AndroidStudio 自动生成 SerialVersionUID","date":"2015-12-15T07:04:44.000Z","_content":"\n关于 SerialVersionUID 的概念和作用就不多说了，自行搜索即可，本篇简单说一下如何在 Android Studio 中自动帮助我们生成(不重复的) SerialVersionUID。\n\n<!--more-->\n\n打开 Settings，切换到 Editor->Inspections->Java->Serialization issues，找到 Serializationzable class without 'serialVersionUID'，将其勾选即可，如图：\n![img](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_serialVersionUID1.jpg)\n\n其实这个意思就是在代码检查时看是否有 serialVersionUID 这个字段，没有就提示你。\n\n之后在实现了 Serializable 接口的类名上打开 Android Studio 的智能提示(智能检查)，就会多出了 Add 'serialVersionUID' field，如图： \n![img](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_serialVersionUID2.png)\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-12-15-AndroidStudioSerialVersionUID.markdown","raw":"title: AndroidStudio 自动生成 SerialVersionUID\ndate: 2015-12-15 15:04:44 \ntags: android\n----\n\n关于 SerialVersionUID 的概念和作用就不多说了，自行搜索即可，本篇简单说一下如何在 Android Studio 中自动帮助我们生成(不重复的) SerialVersionUID。\n\n<!--more-->\n\n打开 Settings，切换到 Editor->Inspections->Java->Serialization issues，找到 Serializationzable class without 'serialVersionUID'，将其勾选即可，如图：\n![img](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_serialVersionUID1.jpg)\n\n其实这个意思就是在代码检查时看是否有 serialVersionUID 这个字段，没有就提示你。\n\n之后在实现了 Serializable 接口的类名上打开 Android Studio 的智能提示(智能检查)，就会多出了 Add 'serialVersionUID' field，如图： \n![img](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_serialVersionUID2.png)\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-12-15-AndroidStudioSerialVersionUID","published":1,"updated":"2015-12-16T01:31:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynxs000fek5x7crmf8tl"},{"title":"大多数人都不知道的Android Studio快捷键","date":"2015-12-13T07:04:44.000Z","_content":"\n当然网上也有很多关于 Android Studio 快捷键的文章，但感觉太冗杂，而且不同的平台快捷键又不一样，导致对着 Mac 打 Win#Eclipse 的快捷键不起作用。所以本篇文章整理的目的在于，`列出使用频繁的快捷键`并`告诉你在哪里设置它们`，而且`文字看不懂的还有动画`，这样即使你用的键盘跟我不一样，你也知道应该去哪里设置相应的键位。\n\n<!--more-->\n\n全局说明：\n\n- 我用的是 Mac，键位是 Mac OS X 10.5+，如下图\n  \n- 若你要修改对应的快捷键，去 Settings->Keymap 中修改，如下图\n  \n  ![keymap](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_androidstudio-keymap.png)\n\n### 0x01 定位目标\n\n| 功能                                       | 快捷键          | 位置                                       |\n| ---------------------------------------- | ------------ | ---------------------------------------- |\n| [搜索类(Enter class name)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+O.gif) | Cmd+O        | Main menu->Navigate->Class               |\n| [搜索方法或字段(Enter symbol name)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Option+O.gif) | Cmd+Option+O | Main menu->Navigate->Symbol              |\n| [搜索文件、目录(Enter file name)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+O.gif) | Cmd+Shift+O  | Main menu->Navigate->File                |\n| [Search Everywhere](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Shift+Shift.gif) | Shift+Shift  |                                          |\n| [查看字段、方法、类、文件都在哪些地方被使用了(全局)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Option+F7.gif) | Option+F7    | Main menu->Edit->Find->Usages            |\n| [查看字段、方法、类、文件都在哪些地方被使用了(当前文件)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+F7.gif) | Cmd+F7       | Main menu->Edit->Find->Find Usages in File |\n| [搜索任意快捷键(Enter action or option name) 很强大！知道快捷操作关键字即可！](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+A.gif) | Cmd+Shift+A  | Main menu->Help->Find Action             |\n\n### 0x02 查看结构\n\n| 功能                                       | 快捷键                                      | 位置                                       |\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\n| [查看定义](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+B.gif) | Cmd+B                                    | Main menu->Navigate->Declaration         |\n| [智能选取](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Option+Up.gif) | Option+Up/Down                           | Editor Actions->Extend Selection/Shrink Selection |\n| 查看本类结构                                   | [Cmd+F12](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+F12.gif) [Cmd+7](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+7.gif) | Main menu->Navigate->File Structure   Other->Structure |\n| 查找和替换                                    | Cmd+F Cmd+R Cmd+Shift+F Cmd+Shift+R      | Main menu->Edit->Find/Replace            |\n| [查看doc](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_F1Ctrl+J.gif) | F1 Ctrl+J                                | Main menu->View->Quick Documentation     |\n\n### 0x03 视图切换\n\n| 功能                                       | 快捷键           | 位置                                       |\n| ---------------------------------------- | ------------- | ---------------------------------------- |\n| [显示目录窗口](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+1.gif) | Cmd+1         | Other->Project/Home Directory            |\n| [显示收藏窗口](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+2.gif) | Cmd+2         | Other->Favorites                         |\n| [显示AndroidMonitor](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+6.gif) | Cmd+6         | Other->Android Monitor                   |\n| [显示类结构](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+7.gif) | Cmd+7         | Other->Structure                         |\n| [最近查看文件窗口](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+E.gif) | Cmd+E         | Main menu->View->Recent Files            |\n| [最近修改文件窗口](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+E.gif) | Cmd+Shift+E   | Main menu->View->Recent Changed Files    |\n| [在当前编辑器切换标签](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+[%3A].gif) | Cmd+Shift+[/] | Main menu->Window->Editor Tabs->Select Previous Tab/Select Next Tab |\n| [切换到顶部导航栏](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Up.gif) | Cmd+Up/Down   | Main menu->Navigate->Jump to Navigation Bar/Jump to Source |\n| [视图切换Switcher](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+Tab.gif) | Ctrl+Tab      | Other->Switcher                          |\n| 最近修改的文件 | Cmd + Shift + E |  |\n\n\n### 0x04 编辑代码\n\n| 功能                                       | 快捷键                  | 位置                                       |\n| ---------------------------------------- | -------------------- | ---------------------------------------- |\n| [LiveTemplate](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+J.gif) | Cmd+J                | Main menu->Code->Insert Live Template    |\n| [Generate](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+N.gif) | Cmd+N                | Main menu->Code->Generate                |\n| [智能提示](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Option+Enter.gif) | Option+Enter         | Other->Show Intention Actions            |\n| [关闭当前活动窗口](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+W.gif) | Cmd+W                | Main menu->Window->Editor Tabs->Close    |\n| 格式化代码                                    | Cmd+Option+L         | Main menu->Code->Reformat Code           |\n| [将当前代码段上下移动](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+Up.gif) | Cmd+Shift+Up/Down    | Main menu->Code->Move Statement Up/Move Statement Down |\n| [将当前行上下移动](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Shift+Option+Up.gif) | Shift+Option+Up/Down | Main menu->Code->Move Line Up/Move Line Down |\n| [插入多个光标协同编辑](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Shift+Option+左键.gif) | Shift+Option+左键      |                                          |\n| [从当前位置剪切到末尾](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+K.gif) | Ctrl+K               | Editor Actions->Cut up to Line End       |\n\n### 0x05 重构\n\n| 功能                                       | 快捷键          | 位置                                    |\n| ---------------------------------------- | ------------ | ------------------------------------- |\n| [移动文件](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_F6.gif) | F6           | Main menu->Refactor->Move             |\n| [拷贝文件](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_F5.gif) | F5           | Main menu->Refactor->Copy             |\n| [重命名](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Shift+F6.gif) | Shift+F6     | Main menu->Refactor->Rename           |\n| [修改方法签名](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+F6.gif) | Cmd+F6       | Main menu->Refactor->Change Signature |\n| [修改参数类型](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+F6.gif) | Cmd+Shift+F6 | Main menu->Refactor->Type Migration   |\n| 引入一个局部变量                                 | Cmd+Shift+V  |                                       |\n| 引入一个参数                                   | Cmd+Shift+P  |                                       |\n| 引入一个类变量                                  | Cmd+Shift+F  |                                       |\n| 引入一个方法                                   | Cmd+Shift+M  |                                       |\n| 引入一个常量                                   | Cmd+Shift+C  |                                       |\n| [显示重构菜单](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+T.gif) | Ctrl+T       | Main menu->Refactor->Refactor This    |\n\n### 0x06 查看代码\n\n| 功能                                       | 快捷键                   | 位置                                       |\n| ---------------------------------------- | --------------------- | ---------------------------------------- |\n| [查询某方法参数信息](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+P.gif) | Cmd+P                 | Main menu->View->Parameter Info          |\n| [跳到方法定义](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+B.gif) | Cmd+B                 | Main menu->Navigate->Declaration         |\n| [跳到变量的定义类](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+B.gif) | Cmd+Shift+B           | Main menu->Navigate->Type Declaration    |\n| [跳到方法在父类或接口的定义处](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+U.gif) | Cmd+U                 | Main menu->Navigate->Super Method        |\n| [跳到上/下一方法](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+Up.gif) | Ctrl+Up/Down          | Main menu->Navigate->Previous Method/Next Method |\n| [跳到上/下一次光标查看处(阅读源代码时非常有用)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Option+Left.gif) | Cmd+Option+Left/Right | Main menu->Navigate->Back/Forward        |\n| [跳到指定行](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+L.gif) | Cmd+L                 | Main menu->Navigate->Line                |\n| [显示方法层级结构](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+H.gif) | Cmd+Shift+H           | Main menu->Navigate->Method Hierarchy    |\n| 调用层级结构                                   | Cmd+Option+H          | Main menu->Navigate->Imports Hierarchy   |\n| 添加查看书签                                   | 添加/移除书签：F3  添加/移除书签(带标记)：Alt + F3         | Main menu->Navigate->Bookmarks   |\n\n### 0x07 Run & Debug\n\n| 功能                                       | 快捷键       | 位置                        |\n| ---------------------------------------- | --------- | ------------------------- |\n| [Run](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+R.gif) | Ctrl+R    | Main menu->Run->Run       |\n| build                                    | Cmd+F9    |                           |\n| [Debug](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+D.gif) | Ctrl+D    | Main menu->Run->Debug     |\n| 单步进入                                     | F7        | Main menu->Run->Step Into |\n| 单步跳过                                     | F8        | Main menu->Run->Step Over |\n| 跳过本次debug                                | F9        | 有待商榷                      |\n| debug时执行选中的语句                            | Option+F8 | 有待商榷                      |\n\n### 0x08 Other but Useful\n| 功能                                       | 快捷键       | 位置                        |\n| ---------------------------------------- | --------- | ------------------------- |\n| 与剪切板比对 | Compare With Clipboard |  |\n| 与某个分支对比 | Compare with Branch |  |\n| 隐藏所有面板 | Cmd +Shift + F12 | Menu → Window → Active Tool Window → Hide All Windows |\n| 高亮一切 |  | Menu → Edit → Find → Highlight Usages in File |\n| 上一个编辑位置 |  | Cmd + Shift + Delete |\n| 在方法和内部类之间跳转 | Ctrl + Up/Down﻿ | Navigate → Next Method/Previous Method |\n| 在外部打开文件 | Cmd + 单击Tab |  |\n| 快速查看定义 | Alt + Space / Cmd + Y |  |\n\n###AndroidStudio插件\nAndroid Drawable Importer\n\nADB Idea\n\nAndroid Code Generator\n\nAndroid Parcelable code Generator\n\nCodota\n\nFindBugs-IDEA\n\nGsonFormat\t\n\nSelectorChapek for Android\n\nWakaTime\n\n\n","source":"_posts/2015-12-13-AndroidStudioShortCuts.markdown","raw":"title: 大多数人都不知道的Android Studio快捷键\ndate: 2015-12-13 15:04:44 \ntags: android\n----\n\n当然网上也有很多关于 Android Studio 快捷键的文章，但感觉太冗杂，而且不同的平台快捷键又不一样，导致对着 Mac 打 Win#Eclipse 的快捷键不起作用。所以本篇文章整理的目的在于，`列出使用频繁的快捷键`并`告诉你在哪里设置它们`，而且`文字看不懂的还有动画`，这样即使你用的键盘跟我不一样，你也知道应该去哪里设置相应的键位。\n\n<!--more-->\n\n全局说明：\n\n- 我用的是 Mac，键位是 Mac OS X 10.5+，如下图\n  \n- 若你要修改对应的快捷键，去 Settings->Keymap 中修改，如下图\n  \n  ![keymap](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_androidstudio-keymap.png)\n\n### 0x01 定位目标\n\n| 功能                                       | 快捷键          | 位置                                       |\n| ---------------------------------------- | ------------ | ---------------------------------------- |\n| [搜索类(Enter class name)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+O.gif) | Cmd+O        | Main menu->Navigate->Class               |\n| [搜索方法或字段(Enter symbol name)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Option+O.gif) | Cmd+Option+O | Main menu->Navigate->Symbol              |\n| [搜索文件、目录(Enter file name)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+O.gif) | Cmd+Shift+O  | Main menu->Navigate->File                |\n| [Search Everywhere](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Shift+Shift.gif) | Shift+Shift  |                                          |\n| [查看字段、方法、类、文件都在哪些地方被使用了(全局)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Option+F7.gif) | Option+F7    | Main menu->Edit->Find->Usages            |\n| [查看字段、方法、类、文件都在哪些地方被使用了(当前文件)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+F7.gif) | Cmd+F7       | Main menu->Edit->Find->Find Usages in File |\n| [搜索任意快捷键(Enter action or option name) 很强大！知道快捷操作关键字即可！](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+A.gif) | Cmd+Shift+A  | Main menu->Help->Find Action             |\n\n### 0x02 查看结构\n\n| 功能                                       | 快捷键                                      | 位置                                       |\n| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |\n| [查看定义](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+B.gif) | Cmd+B                                    | Main menu->Navigate->Declaration         |\n| [智能选取](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Option+Up.gif) | Option+Up/Down                           | Editor Actions->Extend Selection/Shrink Selection |\n| 查看本类结构                                   | [Cmd+F12](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+F12.gif) [Cmd+7](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+7.gif) | Main menu->Navigate->File Structure   Other->Structure |\n| 查找和替换                                    | Cmd+F Cmd+R Cmd+Shift+F Cmd+Shift+R      | Main menu->Edit->Find/Replace            |\n| [查看doc](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_F1Ctrl+J.gif) | F1 Ctrl+J                                | Main menu->View->Quick Documentation     |\n\n### 0x03 视图切换\n\n| 功能                                       | 快捷键           | 位置                                       |\n| ---------------------------------------- | ------------- | ---------------------------------------- |\n| [显示目录窗口](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+1.gif) | Cmd+1         | Other->Project/Home Directory            |\n| [显示收藏窗口](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+2.gif) | Cmd+2         | Other->Favorites                         |\n| [显示AndroidMonitor](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+6.gif) | Cmd+6         | Other->Android Monitor                   |\n| [显示类结构](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+7.gif) | Cmd+7         | Other->Structure                         |\n| [最近查看文件窗口](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+E.gif) | Cmd+E         | Main menu->View->Recent Files            |\n| [最近修改文件窗口](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+E.gif) | Cmd+Shift+E   | Main menu->View->Recent Changed Files    |\n| [在当前编辑器切换标签](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+[%3A].gif) | Cmd+Shift+[/] | Main menu->Window->Editor Tabs->Select Previous Tab/Select Next Tab |\n| [切换到顶部导航栏](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Up.gif) | Cmd+Up/Down   | Main menu->Navigate->Jump to Navigation Bar/Jump to Source |\n| [视图切换Switcher](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+Tab.gif) | Ctrl+Tab      | Other->Switcher                          |\n| 最近修改的文件 | Cmd + Shift + E |  |\n\n\n### 0x04 编辑代码\n\n| 功能                                       | 快捷键                  | 位置                                       |\n| ---------------------------------------- | -------------------- | ---------------------------------------- |\n| [LiveTemplate](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+J.gif) | Cmd+J                | Main menu->Code->Insert Live Template    |\n| [Generate](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+N.gif) | Cmd+N                | Main menu->Code->Generate                |\n| [智能提示](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Option+Enter.gif) | Option+Enter         | Other->Show Intention Actions            |\n| [关闭当前活动窗口](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+W.gif) | Cmd+W                | Main menu->Window->Editor Tabs->Close    |\n| 格式化代码                                    | Cmd+Option+L         | Main menu->Code->Reformat Code           |\n| [将当前代码段上下移动](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+Up.gif) | Cmd+Shift+Up/Down    | Main menu->Code->Move Statement Up/Move Statement Down |\n| [将当前行上下移动](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Shift+Option+Up.gif) | Shift+Option+Up/Down | Main menu->Code->Move Line Up/Move Line Down |\n| [插入多个光标协同编辑](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Shift+Option+左键.gif) | Shift+Option+左键      |                                          |\n| [从当前位置剪切到末尾](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+K.gif) | Ctrl+K               | Editor Actions->Cut up to Line End       |\n\n### 0x05 重构\n\n| 功能                                       | 快捷键          | 位置                                    |\n| ---------------------------------------- | ------------ | ------------------------------------- |\n| [移动文件](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_F6.gif) | F6           | Main menu->Refactor->Move             |\n| [拷贝文件](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_F5.gif) | F5           | Main menu->Refactor->Copy             |\n| [重命名](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Shift+F6.gif) | Shift+F6     | Main menu->Refactor->Rename           |\n| [修改方法签名](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+F6.gif) | Cmd+F6       | Main menu->Refactor->Change Signature |\n| [修改参数类型](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+F6.gif) | Cmd+Shift+F6 | Main menu->Refactor->Type Migration   |\n| 引入一个局部变量                                 | Cmd+Shift+V  |                                       |\n| 引入一个参数                                   | Cmd+Shift+P  |                                       |\n| 引入一个类变量                                  | Cmd+Shift+F  |                                       |\n| 引入一个方法                                   | Cmd+Shift+M  |                                       |\n| 引入一个常量                                   | Cmd+Shift+C  |                                       |\n| [显示重构菜单](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+T.gif) | Ctrl+T       | Main menu->Refactor->Refactor This    |\n\n### 0x06 查看代码\n\n| 功能                                       | 快捷键                   | 位置                                       |\n| ---------------------------------------- | --------------------- | ---------------------------------------- |\n| [查询某方法参数信息](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+P.gif) | Cmd+P                 | Main menu->View->Parameter Info          |\n| [跳到方法定义](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+B.gif) | Cmd+B                 | Main menu->Navigate->Declaration         |\n| [跳到变量的定义类](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+B.gif) | Cmd+Shift+B           | Main menu->Navigate->Type Declaration    |\n| [跳到方法在父类或接口的定义处](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+U.gif) | Cmd+U                 | Main menu->Navigate->Super Method        |\n| [跳到上/下一方法](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+Up.gif) | Ctrl+Up/Down          | Main menu->Navigate->Previous Method/Next Method |\n| [跳到上/下一次光标查看处(阅读源代码时非常有用)](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Option+Left.gif) | Cmd+Option+Left/Right | Main menu->Navigate->Back/Forward        |\n| [跳到指定行](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+L.gif) | Cmd+L                 | Main menu->Navigate->Line                |\n| [显示方法层级结构](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Cmd+Shift+H.gif) | Cmd+Shift+H           | Main menu->Navigate->Method Hierarchy    |\n| 调用层级结构                                   | Cmd+Option+H          | Main menu->Navigate->Imports Hierarchy   |\n| 添加查看书签                                   | 添加/移除书签：F3  添加/移除书签(带标记)：Alt + F3         | Main menu->Navigate->Bookmarks   |\n\n### 0x07 Run & Debug\n\n| 功能                                       | 快捷键       | 位置                        |\n| ---------------------------------------- | --------- | ------------------------- |\n| [Run](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+R.gif) | Ctrl+R    | Main menu->Run->Run       |\n| build                                    | Cmd+F9    |                           |\n| [Debug](http://7xivx9.com1.z0.glb.clouddn.com/androidstudio_Ctrl+D.gif) | Ctrl+D    | Main menu->Run->Debug     |\n| 单步进入                                     | F7        | Main menu->Run->Step Into |\n| 单步跳过                                     | F8        | Main menu->Run->Step Over |\n| 跳过本次debug                                | F9        | 有待商榷                      |\n| debug时执行选中的语句                            | Option+F8 | 有待商榷                      |\n\n### 0x08 Other but Useful\n| 功能                                       | 快捷键       | 位置                        |\n| ---------------------------------------- | --------- | ------------------------- |\n| 与剪切板比对 | Compare With Clipboard |  |\n| 与某个分支对比 | Compare with Branch |  |\n| 隐藏所有面板 | Cmd +Shift + F12 | Menu → Window → Active Tool Window → Hide All Windows |\n| 高亮一切 |  | Menu → Edit → Find → Highlight Usages in File |\n| 上一个编辑位置 |  | Cmd + Shift + Delete |\n| 在方法和内部类之间跳转 | Ctrl + Up/Down﻿ | Navigate → Next Method/Previous Method |\n| 在外部打开文件 | Cmd + 单击Tab |  |\n| 快速查看定义 | Alt + Space / Cmd + Y |  |\n\n###AndroidStudio插件\nAndroid Drawable Importer\n\nADB Idea\n\nAndroid Code Generator\n\nAndroid Parcelable code Generator\n\nCodota\n\nFindBugs-IDEA\n\nGsonFormat\t\n\nSelectorChapek for Android\n\nWakaTime\n\n\n","slug":"2015-12-13-AndroidStudioShortCuts","published":1,"updated":"2016-04-12T03:16:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynxu000hek5x1yns4n8u"},{"title":"要做挖掘机而非推土机","date":"2015-11-29T07:04:44.000Z","_content":"\n最近科协和团宣同时向我约稿，科协是让我回顾下去年科技之星，写写经验总结，团宣大体也类似，所以就有了下文，正好也有个机会有个时间写写非代码的东西，对这几年的学习经历经验做个简单的马后炮式总结。\n\n<!--more-->\n\n`兴趣仍然很重要。`“兴趣是最好的老师”现在有点太俗了，但对于编程来说绝对是真理。我也会承认，如果没有兴趣支撑，有时码代码确实挺无聊的，大多数人最开始学习编程也只是对着一个黑框框（命令行），所以就认为编程也就这样了，短期又看不到实际效果，很容易就放弃了。但越是这个时候，就越要有继续下去的兴趣与动力。我是初中开始接触电脑报刊，高中开始学习编程，我觉得编程很有意思，我认为计算机技术可以改变未来人类生活方式，并且我会为其贡献力量，可能这就是我最初的兴趣与动力的来源，并坚持到了现在。\n\n`编程是艺术而不是技术。`很多初学者学习了一两年的编程之后，会认为编程不就是代码的堆砌吗，不会的网上一搜复制粘贴能够运行就算ok了，所以也会管码农叫做搬砖工。其实，如果再往深层次去学习，尤其软件工程、设计模式等深入的思想，会发现编程其实是一门艺术。一个好的程序不是靠代码堆砌来组成的，而是有一种全局具备艺术的思想做整体支撑。这么说很抽象，但我们要学会面向抽象编程，而不是面向具体。每当我再回过头看之前所写过的代码，当时觉得还可以，但现在从艺术的角度看，充其量算个残次品。这个时候需要做的就是『代码重构』，将你的残次品再次变为艺术品，你会发现`代码简洁之道，设计模式之美。`\n\n`广泛学习并精于一门，横跨和纵深，先做推土机后做挖掘机。`我觉得在大学学习编程一种好的学习规划是，前两年广泛学习各种编程语言及相关知识，可以涵盖前后端以及移动端，不怕你学的多，你学的越广泛越好，你慢慢会觉得很多都是相通的，当你有了c++的基础后，你会发现十大谎言之一的“七天学会Java”竟然是真理。如果你真的这么做了两年，你所掌握的知识广度将是很多人都不及的，可能很多人都会崇拜你是什么都会的技术大牛。然而这个时候你并不能自满，如果你立刻出去找个大公司某研发岗的实习，我敢说十有八九都会被挂掉。为什么呢，都学了这么多语言了，面试官凭什么不要我？答案是，你对该岗位使用的语言或相关知识掌握的程度太肤浅，不够深入。也就是说，从大三开始，你要做出选择，选择你最感兴趣的一个方向学会去纵深，深入去学习。那什么是深入，Java课程考了100分就是深入吗？不一定，你再去阅读《Effective Java》 《Java核心思想》等书籍时，你会发现你会的只是冰山一角而已。深入没有一个绝对的标尺可以衡量，还有不会的，就要继续深入。这就是横跨与纵深，也就是推土机和挖掘机的区别，推土机只会推表面的土，希望你能做个挖掘机。\n\n`自学。`“互联网的东西变化太快，不自学跟不上脚步”，这句话你肯定不是第一次见了。借此说说另外一个现象：公司为什么不爱录用像北大青鸟这样出来的人才？我相信，在北大青鸟学半年之后，实践经历是要大于普通在校生的，而且他们会有拿得出手的作品，放到公司也立马能干活。但是一个最重要的点在于他们已经丧失了自学能力，我之前曾去达内(也是IT教育)偷偷蹭过课，老师就是手把手的教你每一行代码应该怎样写，但为什么这样写却不怎么说，学员也是跟着老师把项目做完了，但是要让他们自己再独立完成一遍却不行了。所以在校招时公司会看重你的自学能力和可塑造性，而不是必须要求你入职后立马能干活。也有很多人想自学，问我应该怎么自学，其实现在有很多的在线IT教育网站，比如极客学院等，上面有各种各样的课程，多花时间去学习，包括我也是这么走过来的。\n\n`积累。`编程这种东西很杂，比如你做Android，那其他的如数据库、网络等等你都得会才行，平时需要大量相关知识的积累。推荐几个移动端阅读类的APP，『开发者头条』、『掘金』、『简书』，这些我平时没事就会打开看看。另外也推荐搭建一个自己的博客网站，在上面记录总结学到的知识，比如我的是 [『www.icodeyou.com』](http://icodeyou.com)，之所以我要建博客网站是有两个原因，一个是分享，另一个是总结积累，搭建自己的博客是一种很好的方式。知识是要一点一点积累的，量变质变的道理。\n\n`重视大学里每一门专业课。`我可能都没资格这么说，因为我曾经也没有重视过有些课程，但我想以一种过来人的身份跟你们说这件事。之所以没重视也是觉得，这课没用以后又用不着吧啦吧啦的一堆借口吧，直到我大三暑假时去苏州和郑州参加网络安全集训和CTF的时候，那一个月的时间，我觉得不仅用到了大学所学的几乎所有专业课知识，而且我之前越是不重视的科目，越被这种知识上的漏洞疯狂打脸。所以我当时就比较懊悔，现在要对你们说重视每一门专业课。而且私认为计算机专业和其他有些专业不同的是，大学里的专业课对未来工作是真真真的有帮助。\n\n参加学习小组。我们新成立了一个学习小组，名为“EvalSafe”，既有安全又有开发，每周日晚上7点都会在机械楼D308有主题分享，大家遇到任何难题都可以一起讨论解决，有一个比较好的学习环境和氛围，有兴趣的也可以直接去参加。\n\n以上有些东西是马后炮式总结，开始我也不懂迷茫，到了大四经历过了之后才懂得，所以我想如果再给我四年时间，我会更知道怎么做，会比现在做的更好。但我是回不去了，而你正在开始。\n\n最后用一句话总结，以大多数人的努力程度之低，根本轮不到拼天赋。\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-11-29-manuscript.markdown","raw":"title: 要做挖掘机而非推土机\ndate: 2015-11-29 15:04:44 \ntags: icodeyou\n----\n\n最近科协和团宣同时向我约稿，科协是让我回顾下去年科技之星，写写经验总结，团宣大体也类似，所以就有了下文，正好也有个机会有个时间写写非代码的东西，对这几年的学习经历经验做个简单的马后炮式总结。\n\n<!--more-->\n\n`兴趣仍然很重要。`“兴趣是最好的老师”现在有点太俗了，但对于编程来说绝对是真理。我也会承认，如果没有兴趣支撑，有时码代码确实挺无聊的，大多数人最开始学习编程也只是对着一个黑框框（命令行），所以就认为编程也就这样了，短期又看不到实际效果，很容易就放弃了。但越是这个时候，就越要有继续下去的兴趣与动力。我是初中开始接触电脑报刊，高中开始学习编程，我觉得编程很有意思，我认为计算机技术可以改变未来人类生活方式，并且我会为其贡献力量，可能这就是我最初的兴趣与动力的来源，并坚持到了现在。\n\n`编程是艺术而不是技术。`很多初学者学习了一两年的编程之后，会认为编程不就是代码的堆砌吗，不会的网上一搜复制粘贴能够运行就算ok了，所以也会管码农叫做搬砖工。其实，如果再往深层次去学习，尤其软件工程、设计模式等深入的思想，会发现编程其实是一门艺术。一个好的程序不是靠代码堆砌来组成的，而是有一种全局具备艺术的思想做整体支撑。这么说很抽象，但我们要学会面向抽象编程，而不是面向具体。每当我再回过头看之前所写过的代码，当时觉得还可以，但现在从艺术的角度看，充其量算个残次品。这个时候需要做的就是『代码重构』，将你的残次品再次变为艺术品，你会发现`代码简洁之道，设计模式之美。`\n\n`广泛学习并精于一门，横跨和纵深，先做推土机后做挖掘机。`我觉得在大学学习编程一种好的学习规划是，前两年广泛学习各种编程语言及相关知识，可以涵盖前后端以及移动端，不怕你学的多，你学的越广泛越好，你慢慢会觉得很多都是相通的，当你有了c++的基础后，你会发现十大谎言之一的“七天学会Java”竟然是真理。如果你真的这么做了两年，你所掌握的知识广度将是很多人都不及的，可能很多人都会崇拜你是什么都会的技术大牛。然而这个时候你并不能自满，如果你立刻出去找个大公司某研发岗的实习，我敢说十有八九都会被挂掉。为什么呢，都学了这么多语言了，面试官凭什么不要我？答案是，你对该岗位使用的语言或相关知识掌握的程度太肤浅，不够深入。也就是说，从大三开始，你要做出选择，选择你最感兴趣的一个方向学会去纵深，深入去学习。那什么是深入，Java课程考了100分就是深入吗？不一定，你再去阅读《Effective Java》 《Java核心思想》等书籍时，你会发现你会的只是冰山一角而已。深入没有一个绝对的标尺可以衡量，还有不会的，就要继续深入。这就是横跨与纵深，也就是推土机和挖掘机的区别，推土机只会推表面的土，希望你能做个挖掘机。\n\n`自学。`“互联网的东西变化太快，不自学跟不上脚步”，这句话你肯定不是第一次见了。借此说说另外一个现象：公司为什么不爱录用像北大青鸟这样出来的人才？我相信，在北大青鸟学半年之后，实践经历是要大于普通在校生的，而且他们会有拿得出手的作品，放到公司也立马能干活。但是一个最重要的点在于他们已经丧失了自学能力，我之前曾去达内(也是IT教育)偷偷蹭过课，老师就是手把手的教你每一行代码应该怎样写，但为什么这样写却不怎么说，学员也是跟着老师把项目做完了，但是要让他们自己再独立完成一遍却不行了。所以在校招时公司会看重你的自学能力和可塑造性，而不是必须要求你入职后立马能干活。也有很多人想自学，问我应该怎么自学，其实现在有很多的在线IT教育网站，比如极客学院等，上面有各种各样的课程，多花时间去学习，包括我也是这么走过来的。\n\n`积累。`编程这种东西很杂，比如你做Android，那其他的如数据库、网络等等你都得会才行，平时需要大量相关知识的积累。推荐几个移动端阅读类的APP，『开发者头条』、『掘金』、『简书』，这些我平时没事就会打开看看。另外也推荐搭建一个自己的博客网站，在上面记录总结学到的知识，比如我的是 [『www.icodeyou.com』](http://icodeyou.com)，之所以我要建博客网站是有两个原因，一个是分享，另一个是总结积累，搭建自己的博客是一种很好的方式。知识是要一点一点积累的，量变质变的道理。\n\n`重视大学里每一门专业课。`我可能都没资格这么说，因为我曾经也没有重视过有些课程，但我想以一种过来人的身份跟你们说这件事。之所以没重视也是觉得，这课没用以后又用不着吧啦吧啦的一堆借口吧，直到我大三暑假时去苏州和郑州参加网络安全集训和CTF的时候，那一个月的时间，我觉得不仅用到了大学所学的几乎所有专业课知识，而且我之前越是不重视的科目，越被这种知识上的漏洞疯狂打脸。所以我当时就比较懊悔，现在要对你们说重视每一门专业课。而且私认为计算机专业和其他有些专业不同的是，大学里的专业课对未来工作是真真真的有帮助。\n\n参加学习小组。我们新成立了一个学习小组，名为“EvalSafe”，既有安全又有开发，每周日晚上7点都会在机械楼D308有主题分享，大家遇到任何难题都可以一起讨论解决，有一个比较好的学习环境和氛围，有兴趣的也可以直接去参加。\n\n以上有些东西是马后炮式总结，开始我也不懂迷茫，到了大四经历过了之后才懂得，所以我想如果再给我四年时间，我会更知道怎么做，会比现在做的更好。但我是回不去了，而你正在开始。\n\n最后用一句话总结，以大多数人的努力程度之低，根本轮不到拼天赋。\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-11-29-manuscript","published":1,"updated":"2015-11-29T07:13:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynxv000jek5x84h0rw4s"},{"title":"蜻蜓FM之 Service 流氓重生","date":"2015-11-11T14:18:44.000Z","_content":"\n近来蜻蜓FM事件让中国移动互联网变得更好玩了，本人作为一个程序员，也要全心全意向蜻蜓司的神级程序员好好学习，所以本系列文章就来深刻学习一下蜻蜓FM是如何请来普罗米修斯和宙斯的。\n\n<!--more-->\n\n本篇文章主要来看 Android 中如何能在不同的进程中启动多个 Service 并保持 Service \"不被杀死\"。\n\n\n\n## 创建多个 Service\n\n这个应该和简单，就新建多个 Service 类就好了，在此示例建立了三个 Service，每个代码都是如下：\n\n``` java\npublic class MyService1 extends Service {\n    public MyService1() {\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}\n```\n\n再简单不过的 Service 了，在 Manifest.xml 文件中\b也注册好，如下：\n\n``` xml\n<service\n    android:name=\".services.MyService1\"\n    android:enabled=\"true\"\n    android:exported=\"true\" >\n</service>\n```\n\n如此新建好三个 Service 就好了，分别为 MyService1、MyService2、MyService3。另外，为了方便对这三个 Service 进行统一管理，所以我们在新建一个工具类 ServiceUtils，提供一静态方法用于启动 Service，如下：\n\n``` java\n// ServiceUtils 工具类用于启动多个Service\npublic class ServiceUtils {\n\n    public static void startAllService(Context context) {\n        context.startService(new Intent(context, MyService1.class));\n        context.startService(new Intent(context, MyService2.class));\n        context.startService(new Intent(context, MyService3.class));\n    }\n\n}\n```\n\n\n\n接下来我们在 MainActivity 中直接调用该工具类的静态方法直接启动这三个 Service，代码如下：\n\n``` java\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\t\t// 直接启动三个 Service\n        ServiceUtils.startAllService(this);\n    }\n}\n```\n\n如果你做过 Android 程序，其实以上代码都很简单，下面来实际运行一下，打开模拟器的 `Running app`，如下图：\n\n![initservice](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-initservice.png)\n\n\n\n可以看到，一个 QTFM 的进程以及都在该进程中的三个 Service。可是我们再对比一下实际上蜻蜓FM的进程和服务情况，如下图：\n\n![image](http://ww1.sinaimg.cn/large/005SiNxyjw1exvsuo6d8hj30go0pa41w.jpg)\n\n从图中也可以看出来，它的 APP 启动了多个进程，几乎把服务都分散到多个进程中了，这样做的好处就是可以彼此\"帮助\"，相互唤醒，做到杀不死啊哈哈。其实这个就是 Android 中的多进程编程，我记得之前有个流氓软件防卸载就是使用的这种技术，看来多进程编程在某些程度上被玩坏了。回归正题，我们这里关注的是技术，所以就来看看如何把每个 Service 放在单独的进程中，而不是同一个进程中。\n\n实现多进程编程也不难，打开 Manifest.xml 文件，找到 Service 标签，为 Service 添加 process 属性即可，代码如下：\n\n``` xml\n<service\n    android:name=\".services.MyService1\"\n    android:enabled=\"true\"\n    android:exported=\"true\"\n    android:process=\":myservice1\"></service>\n<service\n    android:name=\".services.MyService2\"\n    android:enabled=\"true\"\n    android:exported=\"true\"\n    android:process=\":myservice2\"></service>\n<service\n    android:name=\".services.MyService3\"\n    android:enabled=\"true\"\n    android:exported=\"true\"\n    android:process=\":myservice3\"></service>\n```\n\n给 Service 指定特定的 process 属性就可以了，process 的值可以有两种，其一就是如上写的 `:remote` 以冒号开头的，代表当前程序的私有进程，其二就是不以冒号开头，多以包名开头，代表单独的进程。这里我们先不关心两种方式的具体区别，只先实现启动多个进程。此时我们再运行一下程序，之后切换到设置中的 `Running app` 中查看，如图：\n\n![process](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-process.png)\n\n很明显，目的达到了，每个 Service 都运行在了一个进程中，这个问题我们解决了，继续向下一个问题探索：如何使得 Service 不被杀死？\n\n\n\n## 如何使得 Service 不被杀死\n\n此时，我们虽然可以看到确实三个 Service 运行在了三个进程中了，但是如果我们点击某个 Service 中的 \"Stop\" 按钮，那么该 Service 就被结束掉了，效果如下：\n\n\n\n![killservice](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-killservice.gif)\n\n\n\n那此时我们需要解决的问题就是，如何在点击了 \"Stop\" 按钮之后该 Service 不被杀死。实现这个也不难，利用 Service 的生命周期，在其 onDestroy() 中做手脚，几行代码搞定，如下：\n\n``` java\npublic class MyService1 extends Service {\n    public MyService1() {\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    @Override\n    public void onDestroy() {\n        // 在这里再次启动 Service\n        startService(new Intent(this, MyService1.class));\n        super.onDestroy();\n    }\n}\n```\n\n我们给 MyService1 赋予了这种『小强模式』，另外两个 Service 还是和原来一样，这样我们再来分别 Stop 一下，对比看看效果，如下：\n\n![killservice](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-killservice1.gif)\n\n\n\n可以看到，每次试图 Stop MyService1 时，它总是又会启动，并且运行时间重新从0开始，而其它两个 Service 都可以轻易被 Stop 掉，形成了明显的对比。所以其实那我们就可以在每个 Service 的 onDestroy() 中调用我们写好的静态工具类的方法来一键启动所有其它 Service 了，不贴代码了，自己尝试下就可以了。\n\n\n\n进行到这里，本来我就不想继续写了，因为要探讨的两个问题：『创建多个 Service、如何使得 Service 不被杀死』都已经解决完了，然而真的是这样嘛，我开始也以为是，但是又发现了新的问题，在于某种情况下我点击 Stop 仍然可以杀死服务，你先可以探索一下是否真的这样以及怎样做，然后继续往下看。\n\n———分隔线———\n\n不知道你是否发现了，就是，点击了 Stop 后马上进 Service 再点 Stop，这样就可以杀死该 Service 了，演示如下：\n\n![killservice](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-killservice2.gif)\n\n\n\n我非常快的点击了两次该 Service 的 Stop 按钮，惊奇发现所有的 Service 都被杀死了有木有。我们看一下在第二次点击 Stop 之前的界面，貌似和之前的不太一样，如下图：\n\n![stop](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-stop.png)\n\n所以如果这个时候我们立刻点击了 Stop，就将该 App 的所有进程都非正常终结掉了，所以我怀疑有些内存清理或防自启的软件是不是这么做的（仅仅猜测而已，待证实）。\n\n\n\n所以目前为止，我们还不能很好的实现服务不被杀死，那我们下面就要继续探索还有什么方式可以帮助我们来自动启动 Service。\n\n\n\n## 利用广播来实现自启\n\n这种方法应该早就有了，思想就是静态注册广播接收器，接收一些特定的广播事件，比如开机、连接\\断开电源、网络状态变化等来回调 onReceive()，实现具体的自启操作。\n\n我们先定义一个 BroadcastReceiver 用于监听飞行模式的状态变化这一广播事件，Manifest.xml 文件如下：\n\n``` java\n<receiver\n    android:name=\".receivers.MyReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"true\" >\n    <intent-filter>\n        <action android:name=\"android.intent.action.AIRPLANE_MODE\"/>\n    </intent-filter>\n</receiver>\n```\n\n添加一 intent-filter 监听飞行模式变化的 action 即可，这个并不需要添加什么额外的权限，如果是监听锁屏开关等则需要相应的权限，据说蜻蜓FM也监听了锁屏。\n\n看下 MyReceiver 的代码，很简单：\n\n``` java\npublic class MyReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        ServiceUtils.startAllService(context);\n    }\n}\n```\n\n在 onReceive() 中启动需要的 Service 就可以了，这样我们再运行下程序，改变下飞行模式的状态，效果如下图：\n\n![broadcast](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-broadcast.gif)\n\n\n\n至此，我们就实现了对一个 app 开启多个进程并分别启动相应的 Service，同时使得 Service 不那么容易被杀死以及收到广播事件后自启。下篇文章将继续研究下一个话题：增加 app 日活。哈哈哈，做个程序员真是越来越有意思。\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-11-11-QTFMService.markdown","raw":"title: 蜻蜓FM之 Service 流氓重生\ndate: 2015-11-11 22:18:44 \ntags: Android\n----\n\n近来蜻蜓FM事件让中国移动互联网变得更好玩了，本人作为一个程序员，也要全心全意向蜻蜓司的神级程序员好好学习，所以本系列文章就来深刻学习一下蜻蜓FM是如何请来普罗米修斯和宙斯的。\n\n<!--more-->\n\n本篇文章主要来看 Android 中如何能在不同的进程中启动多个 Service 并保持 Service \"不被杀死\"。\n\n\n\n## 创建多个 Service\n\n这个应该和简单，就新建多个 Service 类就好了，在此示例建立了三个 Service，每个代码都是如下：\n\n``` java\npublic class MyService1 extends Service {\n    public MyService1() {\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}\n```\n\n再简单不过的 Service 了，在 Manifest.xml 文件中\b也注册好，如下：\n\n``` xml\n<service\n    android:name=\".services.MyService1\"\n    android:enabled=\"true\"\n    android:exported=\"true\" >\n</service>\n```\n\n如此新建好三个 Service 就好了，分别为 MyService1、MyService2、MyService3。另外，为了方便对这三个 Service 进行统一管理，所以我们在新建一个工具类 ServiceUtils，提供一静态方法用于启动 Service，如下：\n\n``` java\n// ServiceUtils 工具类用于启动多个Service\npublic class ServiceUtils {\n\n    public static void startAllService(Context context) {\n        context.startService(new Intent(context, MyService1.class));\n        context.startService(new Intent(context, MyService2.class));\n        context.startService(new Intent(context, MyService3.class));\n    }\n\n}\n```\n\n\n\n接下来我们在 MainActivity 中直接调用该工具类的静态方法直接启动这三个 Service，代码如下：\n\n``` java\npublic class MainActivity extends Activity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\t\t// 直接启动三个 Service\n        ServiceUtils.startAllService(this);\n    }\n}\n```\n\n如果你做过 Android 程序，其实以上代码都很简单，下面来实际运行一下，打开模拟器的 `Running app`，如下图：\n\n![initservice](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-initservice.png)\n\n\n\n可以看到，一个 QTFM 的进程以及都在该进程中的三个 Service。可是我们再对比一下实际上蜻蜓FM的进程和服务情况，如下图：\n\n![image](http://ww1.sinaimg.cn/large/005SiNxyjw1exvsuo6d8hj30go0pa41w.jpg)\n\n从图中也可以看出来，它的 APP 启动了多个进程，几乎把服务都分散到多个进程中了，这样做的好处就是可以彼此\"帮助\"，相互唤醒，做到杀不死啊哈哈。其实这个就是 Android 中的多进程编程，我记得之前有个流氓软件防卸载就是使用的这种技术，看来多进程编程在某些程度上被玩坏了。回归正题，我们这里关注的是技术，所以就来看看如何把每个 Service 放在单独的进程中，而不是同一个进程中。\n\n实现多进程编程也不难，打开 Manifest.xml 文件，找到 Service 标签，为 Service 添加 process 属性即可，代码如下：\n\n``` xml\n<service\n    android:name=\".services.MyService1\"\n    android:enabled=\"true\"\n    android:exported=\"true\"\n    android:process=\":myservice1\"></service>\n<service\n    android:name=\".services.MyService2\"\n    android:enabled=\"true\"\n    android:exported=\"true\"\n    android:process=\":myservice2\"></service>\n<service\n    android:name=\".services.MyService3\"\n    android:enabled=\"true\"\n    android:exported=\"true\"\n    android:process=\":myservice3\"></service>\n```\n\n给 Service 指定特定的 process 属性就可以了，process 的值可以有两种，其一就是如上写的 `:remote` 以冒号开头的，代表当前程序的私有进程，其二就是不以冒号开头，多以包名开头，代表单独的进程。这里我们先不关心两种方式的具体区别，只先实现启动多个进程。此时我们再运行一下程序，之后切换到设置中的 `Running app` 中查看，如图：\n\n![process](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-process.png)\n\n很明显，目的达到了，每个 Service 都运行在了一个进程中，这个问题我们解决了，继续向下一个问题探索：如何使得 Service 不被杀死？\n\n\n\n## 如何使得 Service 不被杀死\n\n此时，我们虽然可以看到确实三个 Service 运行在了三个进程中了，但是如果我们点击某个 Service 中的 \"Stop\" 按钮，那么该 Service 就被结束掉了，效果如下：\n\n\n\n![killservice](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-killservice.gif)\n\n\n\n那此时我们需要解决的问题就是，如何在点击了 \"Stop\" 按钮之后该 Service 不被杀死。实现这个也不难，利用 Service 的生命周期，在其 onDestroy() 中做手脚，几行代码搞定，如下：\n\n``` java\npublic class MyService1 extends Service {\n    public MyService1() {\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    @Override\n    public void onDestroy() {\n        // 在这里再次启动 Service\n        startService(new Intent(this, MyService1.class));\n        super.onDestroy();\n    }\n}\n```\n\n我们给 MyService1 赋予了这种『小强模式』，另外两个 Service 还是和原来一样，这样我们再来分别 Stop 一下，对比看看效果，如下：\n\n![killservice](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-killservice1.gif)\n\n\n\n可以看到，每次试图 Stop MyService1 时，它总是又会启动，并且运行时间重新从0开始，而其它两个 Service 都可以轻易被 Stop 掉，形成了明显的对比。所以其实那我们就可以在每个 Service 的 onDestroy() 中调用我们写好的静态工具类的方法来一键启动所有其它 Service 了，不贴代码了，自己尝试下就可以了。\n\n\n\n进行到这里，本来我就不想继续写了，因为要探讨的两个问题：『创建多个 Service、如何使得 Service 不被杀死』都已经解决完了，然而真的是这样嘛，我开始也以为是，但是又发现了新的问题，在于某种情况下我点击 Stop 仍然可以杀死服务，你先可以探索一下是否真的这样以及怎样做，然后继续往下看。\n\n———分隔线———\n\n不知道你是否发现了，就是，点击了 Stop 后马上进 Service 再点 Stop，这样就可以杀死该 Service 了，演示如下：\n\n![killservice](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-killservice2.gif)\n\n\n\n我非常快的点击了两次该 Service 的 Stop 按钮，惊奇发现所有的 Service 都被杀死了有木有。我们看一下在第二次点击 Stop 之前的界面，貌似和之前的不太一样，如下图：\n\n![stop](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-stop.png)\n\n所以如果这个时候我们立刻点击了 Stop，就将该 App 的所有进程都非正常终结掉了，所以我怀疑有些内存清理或防自启的软件是不是这么做的（仅仅猜测而已，待证实）。\n\n\n\n所以目前为止，我们还不能很好的实现服务不被杀死，那我们下面就要继续探索还有什么方式可以帮助我们来自动启动 Service。\n\n\n\n## 利用广播来实现自启\n\n这种方法应该早就有了，思想就是静态注册广播接收器，接收一些特定的广播事件，比如开机、连接\\断开电源、网络状态变化等来回调 onReceive()，实现具体的自启操作。\n\n我们先定义一个 BroadcastReceiver 用于监听飞行模式的状态变化这一广播事件，Manifest.xml 文件如下：\n\n``` java\n<receiver\n    android:name=\".receivers.MyReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"true\" >\n    <intent-filter>\n        <action android:name=\"android.intent.action.AIRPLANE_MODE\"/>\n    </intent-filter>\n</receiver>\n```\n\n添加一 intent-filter 监听飞行模式变化的 action 即可，这个并不需要添加什么额外的权限，如果是监听锁屏开关等则需要相应的权限，据说蜻蜓FM也监听了锁屏。\n\n看下 MyReceiver 的代码，很简单：\n\n``` java\npublic class MyReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        ServiceUtils.startAllService(context);\n    }\n}\n```\n\n在 onReceive() 中启动需要的 Service 就可以了，这样我们再运行下程序，改变下飞行模式的状态，效果如下图：\n\n![broadcast](http://7xivx9.com1.z0.glb.clouddn.com/qtfm-broadcast.gif)\n\n\n\n至此，我们就实现了对一个 app 开启多个进程并分别启动相应的 Service，同时使得 Service 不那么容易被杀死以及收到广播事件后自启。下篇文章将继续研究下一个话题：增加 app 日活。哈哈哈，做个程序员真是越来越有意思。\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-11-11-QTFMService","published":1,"updated":"2015-11-16T08:27:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynxx000mek5xbfgr9lzn"},{"title":"Messenger 的使用及源码解析","date":"2015-10-28T14:18:44.000Z","_content":"\nMessenger 和 AIDL 都是 IPC 的方式，并且 Messenger 底层也是基于 AIDL 的，只不过为了使用更方便就封装成了 Messenger。下面依次说一下 Messenger 的基本使用方式以及对 Messenger 源码进行解析。\n\n<!--more-->\n\n# Messenger 简介\n\nMessenger 可以翻译为信使，可以在两个不同的进程中传递 Message 对象，在 Message 中我们又可以放入需要跨进程传递的数据，这样就可以实现 IPC 了。\n\n# Messenger 的使用\n\n我们需要有两个进程，分别为客户端和服务端进程，客户端通过 bindService 的方式来和 Service 建立连接请求并获得 Messenger 对象(Binder 对象)。\n\n### 服务端\n\n1、创建 MessengerService，并在注册时指定 process 属性让其运行在单独的进程中\n\n```\n<service\n\tandroid:name=\".MessengerService\"\n\tandroid:process=\":remote\" >\n```\n\n2、在 MessengerService 中实现 创建 Messenger、返回 Messenger、处理 Messenger 消息 的逻辑\n\n```\npackage com.icodeyou.ipcmessenger;\nimport ...;\n\npublic class MessengerService extends Service {\n    private static final String TAG = \"MessengerService\";\n\n    // 用来处理接收 msg 的 handler\n    private Handler mMessengerHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            Log.d(TAG, \"Recv Data : \" + msg.getData().getString(\"msg\"));\n        }\n    };\n\n    // 定义 Messenger 对象，将关联的 Handler 作为参数传递进去\n    private final Messenger mMessenger = new Messenger(mMessengerHandler);\n\n    @Override\n    public IBinder onBind(Intent intent) {\n    \t// 返回 Messenger 中的 Binder 对象\n        return mMessenger.getBinder();\n    }\n}\n```\n\n### 客户端\n\n客户端要做的就是 bindService 后在 onServiceConnected() 方法中将 Binder 对象再转换为 Messenger 对象，调用 Messenger#send(msg) 即可向远程发送消息，代码如下：\n\n```\npackage com.icodeyou.ipcmessenger;\nimport ....\n\npublic class MainActivity extends Activity implements View.OnClickListener {\n\n    private Intent serviceIntent;\n\n    private Messenger mMessenger;\n\n    private ServiceConnection connection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n        \t// 将 Binder 对象转换为 Messenger\n            mMessenger = new Messenger(service);\n            // 构建个 Message 并将 Bundle 数据设置进去\n            Message msg = Message.obtain();\n            Bundle bundle = new Bundle();\n            bundle.putString(\"msg\", \"I am Messenger from Client\");\n            msg.setData(bundle);\n            try {\n            \t// 使用 Messenger 发送消息给远程服务端\n                mMessenger.send(msg);\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        serviceIntent = new Intent(MainActivity.this, MessengerService.class);\n\n        findViewById(R.id.id_btnBind).setOnClickListener(this);\n        findViewById(R.id.id_btnUnBind).setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.id_btnBind:\n                bindService(serviceIntent, connection, BIND_AUTO_CREATE);\n                break;\n            case R.id.id_btnUnBind:\n                unbindService(connection);\n                break;\n        }\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unbindService(connection);\n    }\n}\n```\n\n运行下程序，点击客户端的 Bind 按钮，在 logcat 中查看日志信息，可以看到服务端，即 :remote 收到消息的输出信息，如图：\n\n![messenger](http://7xivx9.com1.z0.glb.clouddn.com/aidl-messenger.png)\n\n以上是客户端远程调用服务端的方法，而服务端还不能主动与客户端进行通信，若要解决这个问题，可通过 Message 的 replyTo 参数传递给服务端，这里就不具体解释了，懂了上面的以后再看下相关代码就明白了。下面咱们来说一下 Messenger 的源码解析。\n\n# Messenger 源码解析\n\nMessenger 是一种轻量级的 IPC 方法，底层仍然是 AIDL，下面来根据代码具体分析。\n\n贴出 Messenger 的关键源代码，分析写在了注释中：\n\n```\npackage android.os;\n\npublic final class Messenger implements Parcelable {\n\t// IMessenger 是 Binder 对象\n    private final IMessenger mTarget;\n\n    // 将 Handler 与 Messenger 关联起来，下面会分析 Handler#getIMessenger()\n    public Messenger(Handler target) {\n        mTarget = target.getIMessenger();\n    }\n\n    // 将服务端的 Binder 转换为客户端的 Binder（AIDL 中使用过）\n    public Messenger(IBinder target) {\n        mTarget = IMessenger.Stub.asInterface(target);\n    }\n    \n    // 向 Messenger 关联的 Handler 发送一个 Message，会调用该 Handler 的 handlerMessage(msg) 方法\n    public void send(Message message) throws RemoteException {\n        mTarget.send(message);\n    }\n    \n    // 获取到 Binder 对象\n    public IBinder getBinder() {\n        return mTarget.asBinder();\n    }\n}\n```\n\n主要就是将能处理消息的 Handler 与 Messenger 相关联，客户端接收到服务端的 Binder 对象后转换为 Messenger 对象，再调用 Messenger#send(msg) 来触发服务端 Handler 的 handleMessage(msg) 方法。\n\n另外，在上述 Messenger 的代码中我们也看到了 handler.getIMessenger()，这个代码实现是怎样的呢，我们可以去看一下 Handler 中相关的代码实现，如下：\n\n```\n// Binder 对象\nIMessenger mMessenger;\n\nfinal IMessenger getIMessenger() {\n\tsynchronized (mQueue) {\n\t\tif (mMessenger != null) {\n\t\t\treturn mMessenger;\n\t\t}\n\t\t// mMessenger 为空则重新创建\n\t\tmMessenger = new MessengerImpl();\n\t\treturn mMessenger;\n    }\n}\n\nprivate final class MessengerImpl extends IMessenger.Stub {\n\tpublic void send(Message msg) {\n\t\tmsg.sendingUid = Binder.getCallingUid();\n\t\t// 这里可以看到其实 IMessenger#send() 就是调用了关联的 Handler 的 sendMessage(msg) 方法而已\n\t\tHandler.this.sendMessage(msg);\n\t}\n}\n```\n\n这样看下来就清晰了很多，知道了底层的实现会对 Messenger 的使用上理解更深入一步。\n\n# Messenger 使用注意事项\n\n- Messenger 一次只处理一个请求，是串行执行的，因此在服务端不用考虑线程同步的问题，这有点类似于 IntentService 中的串行问题，因为都是使用的 Handler、MessageQueue 机制。\n\n- Messenger 只能用来传递消息，不能跨进程调用远程的方法。\n\n- msg.obj 只能传输系统实现了 Parcelable 接口的对象，一般情况下也不要使用 obj 这个字段跨进程传输，可以使用 Bundle 对象来替代 obj，Bundle 可以支持大量的数据类型。\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-10-28-Messenger.markdown","raw":"title: Messenger 的使用及源码解析\ndate: 2015-10-28 22:18:44 \ntags: Android\n----\n\nMessenger 和 AIDL 都是 IPC 的方式，并且 Messenger 底层也是基于 AIDL 的，只不过为了使用更方便就封装成了 Messenger。下面依次说一下 Messenger 的基本使用方式以及对 Messenger 源码进行解析。\n\n<!--more-->\n\n# Messenger 简介\n\nMessenger 可以翻译为信使，可以在两个不同的进程中传递 Message 对象，在 Message 中我们又可以放入需要跨进程传递的数据，这样就可以实现 IPC 了。\n\n# Messenger 的使用\n\n我们需要有两个进程，分别为客户端和服务端进程，客户端通过 bindService 的方式来和 Service 建立连接请求并获得 Messenger 对象(Binder 对象)。\n\n### 服务端\n\n1、创建 MessengerService，并在注册时指定 process 属性让其运行在单独的进程中\n\n```\n<service\n\tandroid:name=\".MessengerService\"\n\tandroid:process=\":remote\" >\n```\n\n2、在 MessengerService 中实现 创建 Messenger、返回 Messenger、处理 Messenger 消息 的逻辑\n\n```\npackage com.icodeyou.ipcmessenger;\nimport ...;\n\npublic class MessengerService extends Service {\n    private static final String TAG = \"MessengerService\";\n\n    // 用来处理接收 msg 的 handler\n    private Handler mMessengerHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            Log.d(TAG, \"Recv Data : \" + msg.getData().getString(\"msg\"));\n        }\n    };\n\n    // 定义 Messenger 对象，将关联的 Handler 作为参数传递进去\n    private final Messenger mMessenger = new Messenger(mMessengerHandler);\n\n    @Override\n    public IBinder onBind(Intent intent) {\n    \t// 返回 Messenger 中的 Binder 对象\n        return mMessenger.getBinder();\n    }\n}\n```\n\n### 客户端\n\n客户端要做的就是 bindService 后在 onServiceConnected() 方法中将 Binder 对象再转换为 Messenger 对象，调用 Messenger#send(msg) 即可向远程发送消息，代码如下：\n\n```\npackage com.icodeyou.ipcmessenger;\nimport ....\n\npublic class MainActivity extends Activity implements View.OnClickListener {\n\n    private Intent serviceIntent;\n\n    private Messenger mMessenger;\n\n    private ServiceConnection connection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n        \t// 将 Binder 对象转换为 Messenger\n            mMessenger = new Messenger(service);\n            // 构建个 Message 并将 Bundle 数据设置进去\n            Message msg = Message.obtain();\n            Bundle bundle = new Bundle();\n            bundle.putString(\"msg\", \"I am Messenger from Client\");\n            msg.setData(bundle);\n            try {\n            \t// 使用 Messenger 发送消息给远程服务端\n                mMessenger.send(msg);\n            } catch (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        serviceIntent = new Intent(MainActivity.this, MessengerService.class);\n\n        findViewById(R.id.id_btnBind).setOnClickListener(this);\n        findViewById(R.id.id_btnUnBind).setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.id_btnBind:\n                bindService(serviceIntent, connection, BIND_AUTO_CREATE);\n                break;\n            case R.id.id_btnUnBind:\n                unbindService(connection);\n                break;\n        }\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unbindService(connection);\n    }\n}\n```\n\n运行下程序，点击客户端的 Bind 按钮，在 logcat 中查看日志信息，可以看到服务端，即 :remote 收到消息的输出信息，如图：\n\n![messenger](http://7xivx9.com1.z0.glb.clouddn.com/aidl-messenger.png)\n\n以上是客户端远程调用服务端的方法，而服务端还不能主动与客户端进行通信，若要解决这个问题，可通过 Message 的 replyTo 参数传递给服务端，这里就不具体解释了，懂了上面的以后再看下相关代码就明白了。下面咱们来说一下 Messenger 的源码解析。\n\n# Messenger 源码解析\n\nMessenger 是一种轻量级的 IPC 方法，底层仍然是 AIDL，下面来根据代码具体分析。\n\n贴出 Messenger 的关键源代码，分析写在了注释中：\n\n```\npackage android.os;\n\npublic final class Messenger implements Parcelable {\n\t// IMessenger 是 Binder 对象\n    private final IMessenger mTarget;\n\n    // 将 Handler 与 Messenger 关联起来，下面会分析 Handler#getIMessenger()\n    public Messenger(Handler target) {\n        mTarget = target.getIMessenger();\n    }\n\n    // 将服务端的 Binder 转换为客户端的 Binder（AIDL 中使用过）\n    public Messenger(IBinder target) {\n        mTarget = IMessenger.Stub.asInterface(target);\n    }\n    \n    // 向 Messenger 关联的 Handler 发送一个 Message，会调用该 Handler 的 handlerMessage(msg) 方法\n    public void send(Message message) throws RemoteException {\n        mTarget.send(message);\n    }\n    \n    // 获取到 Binder 对象\n    public IBinder getBinder() {\n        return mTarget.asBinder();\n    }\n}\n```\n\n主要就是将能处理消息的 Handler 与 Messenger 相关联，客户端接收到服务端的 Binder 对象后转换为 Messenger 对象，再调用 Messenger#send(msg) 来触发服务端 Handler 的 handleMessage(msg) 方法。\n\n另外，在上述 Messenger 的代码中我们也看到了 handler.getIMessenger()，这个代码实现是怎样的呢，我们可以去看一下 Handler 中相关的代码实现，如下：\n\n```\n// Binder 对象\nIMessenger mMessenger;\n\nfinal IMessenger getIMessenger() {\n\tsynchronized (mQueue) {\n\t\tif (mMessenger != null) {\n\t\t\treturn mMessenger;\n\t\t}\n\t\t// mMessenger 为空则重新创建\n\t\tmMessenger = new MessengerImpl();\n\t\treturn mMessenger;\n    }\n}\n\nprivate final class MessengerImpl extends IMessenger.Stub {\n\tpublic void send(Message msg) {\n\t\tmsg.sendingUid = Binder.getCallingUid();\n\t\t// 这里可以看到其实 IMessenger#send() 就是调用了关联的 Handler 的 sendMessage(msg) 方法而已\n\t\tHandler.this.sendMessage(msg);\n\t}\n}\n```\n\n这样看下来就清晰了很多，知道了底层的实现会对 Messenger 的使用上理解更深入一步。\n\n# Messenger 使用注意事项\n\n- Messenger 一次只处理一个请求，是串行执行的，因此在服务端不用考虑线程同步的问题，这有点类似于 IntentService 中的串行问题，因为都是使用的 Handler、MessageQueue 机制。\n\n- Messenger 只能用来传递消息，不能跨进程调用远程的方法。\n\n- msg.obj 只能传输系统实现了 Parcelable 接口的对象，一般情况下也不要使用 obj 这个字段跨进程传输，可以使用 Bundle 对象来替代 obj，Bundle 可以支持大量的数据类型。\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-10-28-Messenger","published":1,"updated":"2015-10-28T13:05:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yny0000pek5xcopcohz0"},{"title":"AIDL 使用及原理探索","date":"2015-10-28T14:18:44.000Z","_content":"\nAIDL 是 Android IPC 通信的一种方式，底层实现是 Binder。本文主要介绍 AIDL 的使用以及分析根据 .aidl 自动生成的 .java 文件。\n\n<!--more-->\n\n# AIDL 在两个进程通信中的使用\n\n我们需要有两个进程，分别称之为 Client 和 Server，最终要使用 AIDL 实现的效果是 Client 可以调用 Server 进程中的方法，即跨进程调用（RPC），执行效果如下图所示：\n\n![aidl-play](http://7xivx9.com1.z0.glb.clouddn.com/aidl-play.gif)\n\n### Server 端\n\n1、在 Server 的工程上新建一个 AIDL 文件，如 IServerInterface.aidl，添加上需要在 Client 调用的方法，代码如下：\n\n```\n// IServerInterface.aidl\npackage com.icodeyou.ipcaidlserver;\n\n// Declare any non-default types here with import statements\n\ninterface IServerInterface {\n    /**\n     * Demonstrates some basic types that you can use as parameters\n     * and return values in AIDL.\n     */\n    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,\n            double aDouble, String aString);\n\n    // 这是手动增加的方法，作用为设置 Server 中 Service 的对象 data 值\n    void setData(String data);\n    // 这是手动增加的方法，作用为设置 Server 中 Service 的对象 isRunning 值\n    void isRunning(boolean isRunning);\n}\n```\n\n可以看到这个接口中有两个我们手动新添加的方法，也就是我们要在 Client 能够调用的方法。\n\n2、在 Server 的工程上新建一个 Service，如 ServerService，并实现其 onBind() 等回调方法，代码如下：\n\n```\npackage com.icodeyou.ipcaidlserver;\nimport ...\n\npublic class ServerService extends Service {\n    private static final String TAG = \"ServerService\";\n    // Service 中维护的变量，之后在一个线程中循环打印\n    private String mData = \"1\";\n    // 线程运行的标志变量\n    private boolean mIsRunning = true;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // Service 创建后每隔一秒打印一次 mData\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (mIsRunning)\n                try {\n                    Thread.sleep(1000);\n                    Log.d(TAG, mData);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n    \t// 很重要，在客户端调用 bindService() 后会调用到这里，返回 binder 对象给客户端\n        return new IServerInterface.Stub() {\n            @Override\n            public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException {\n            }\n\n            // 根据客户端调用方法时传的参数替换本 Service 中对象的值，下同\n            @Override\n            public void setData(String data) throws RemoteException {\n                ServerService.this.mData = data;\n            }\n\n            @Override\n            public void isRunning(boolean isRunning) throws RemoteException {\n                mIsRunning = isRunning;\n            }\n        };\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n    }\n}\n```\n\nServer 端的代码就搞定了，可以直接现在模拟器上运行了，只要等待下面客户端的远程调用就可以了，下面看客户端的实现部分。\n\n### Client\n\n客户端的截图如下：\n\n![aidlclient](http://7xivx9.com1.z0.glb.clouddn.com/aidl-client.png)\n\n根据截图，说一下客户端要完成的工作：\n\n- 绑定到远程的 Service，并将远程 Service 的 onBind() 返回的 Binder 对象保存\n- 通过上一步获取到的 Binder 对象，可直接调用 binder.setData() 以及 binder.isRunning() 来设置远程 Service 的状态\n\n下面看客户端的代码：\n\n```\npackage com.icodeyou.ipcaidlclient;\n\nimport ...\n\npublic class MainActivity extends Activity implements View.OnClickListener {\n    private static final String TAG = \"MainActivity\";\n    // 绑定远程 Service 的 Intent\n    private Intent serviceIntent;\n    // 保存远程 Service#onBind() 方法的返回值，即 Binder 对象\n    private IServerInterface binder = null;\n\n    // bindService() 需要用到的 ServiceConnection 对象\n    private ServiceConnection serviceConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            // 当远程的 onBind() 返回时，调用到这里，将远程的 IBinder 转换成本地的 Binder 对象保存\n            binder = IServerInterface.Stub.asInterface(service);\n            // 注意这里不能够使用强制类型转换，因为两个对象在两个进程中(不同的 Dalvik)，不是属于同一个类\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        serviceIntent = new Intent();\n        // 这里很关键，需要明确告诉远程调用的 Service 的具体包、类的信息，因为5.0之后 Service 不允许隐式调用了\n        serviceIntent.setComponent(new ComponentName(\"com.icodeyou.ipcaidlserver\", \"com.icodeyou.ipcaidlserver.ServerService\"));\n\n        findViewById(R.id.id_btnBind).setOnClickListener(this);\n        findViewById(R.id.id_btnUnBind).setOnClickListener(this);\n        findViewById(R.id.id_btnChange).setOnClickListener(this);\n        findViewById(R.id.id_btnStop).setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.id_btnBind:\n                bindService(serviceIntent, serviceConnection, Service.BIND_AUTO_CREATE);\n                break;\n            case R.id.id_btnUnBind:\n                unbindService(serviceConnection);\n                if (binder != null) {\n                    binder = null;\n                }\n                break;\n            case R.id.id_btnChange:\n                if (binder != null) {\n                    try {\n                    \t// 可以直接通过 binder 对象来进行远程方法调用，改变远程 Service 中的值\n                        binder.setData(\"2\");\n                    } catch (RemoteException e) {\n                        e.printStackTrace();\n                    }\n                }\n                break;\n            case  R.id.id_btnStop:\n                if (binder != null) {\n                    try {\n                    \t// 可以直接通过 binder 对象来进行远程方法调用，改变远程线程运行状态\n                        binder.isRunning(false);\n                    } catch (RemoteException e) {\n                        e.printStackTrace();\n                    }\n                }\n                break;\n        }\n    }\n}\n```\n\n客户端要想使用 IServerInterface，也必须得有相关的 .aidl 文件才可以，不然让它去哪里找这个类，所以我们还需要将服务器端的 aidl 文件所在的包以及类一模一样的复制到 Client 的工程目录下，还需要 Rebuild Project，如图：\n\n![aidlcopy](http://7xivx9.com1.z0.glb.clouddn.com/aidl-copy.png)\n\n对于 AIDL 的使用，简单总结一下，客户端通过 bindService() 可以绑定到远程 Service，该远程 Service 中的 onBinder() 方法返回 IBinder 对象，此时客户端便可以通过该 IBinder 对象中相关的方法来进行远程调用。\n\n# AIDL 底层原理探索\n\n我们手动新建的 .aidl 文件到底是干嘛的，没有行不行，为什么我学了这么多年的 java 了，都不知道还有 .aidl 这么个文件类型？\n\n对于 Java 语言来说，最终能实现相应的逻辑，还得靠 .java 文件才行，那么 .aidl 文件和 .java 文件有什么关系？细心点就不难发现，我们在建立了 .aidl 文件并 Rebuild Project 后，在 build/generated/aidl 文件夹下就会有一个同名的 .java 文件，并且这是一个接口文件，如图：\n\n![aidlgen](http://7xivx9.com1.z0.glb.clouddn.com/aidl-gen.png)\n\n这个文件是根据 .aidl 文件中的内容自动生成的，所以每次我们改变了 .aidl 文件中的内容后，都需要 Rebuild 一下来重新自动生成这个文件，而且 Android Studio 也会在顶部提示我们，如图：\n\n![aidlgentips](http://7xivx9.com1.z0.glb.clouddn.com/aidl-gen-tips.png)\n\n下面来看一个这个文件中的代码，其实也不复杂，根据代码先后顺序使用注释来分析：\n\n```\n/*\n * This file is auto-generated.  DO NOT MODIFY.\n * Original file: /Users/huan/Repository/AndroidStudioProjects/AndroidHeros/ipcaidlserver/src/main/aidl/com/icodeyou/ipcaidlserver/IServerInterface.aidl\n */\npackage com.icodeyou.ipcaidlserver;\n// Declare any non-default types here with import statements\n\npublic interface IServerInterface extends android.os.IInterface {\n    // 内部的 Stub 类，在上面 AIDL 的使用上会用到这个类 \n    public static abstract class Stub extends android.os.Binder implements com.icodeyou.ipcaidlserver.IServerInterface {\n    \t// Binder 的唯一标识，一般用当前 Binder 的类名表示\n        private static final java.lang.String DESCRIPTOR = \"com.icodeyou.ipcaidlserver.IServerInterface\";\n\n        public Stub() {\n            this.attachInterface(this, DESCRIPTOR);\n        }\n\n        // 用于将服务器端的 Binder 对象转换成客户端所需的 AIDL 接口类型的对象\n        // 并且这种转换区分进程的，如果C和S位于同一进程，那么返回服务端的Stub对象本身，否则返回的是系统封装后的 Stub.proxy 对象\n        public static com.icodeyou.ipcaidlserver.IServerInterface asInterface(android.os.IBinder obj) {\n            if ((obj == null)) {\n                return null;\n            }\n            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n            if (((iin != null) && (iin instanceof com.icodeyou.ipcaidlserver.IServerInterface))) {\n                return ((com.icodeyou.ipcaidlserver.IServerInterface) iin);\n            }\n            return new com.icodeyou.ipcaidlserver.IServerInterface.Stub.Proxy(obj);\n        }\n\n        // 返回当前 Binder 对象\n        @Override\n        public android.os.IBinder asBinder() {\n            return this;\n        }\n\n        // 运行在服务端的 Binder 线程池中，通过 code 来调用相关方法\n        @Override\n        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n            switch (code) {\n                case INTERFACE_TRANSACTION: {\n                    reply.writeString(DESCRIPTOR);\n                    return true;\n                }\n                case TRANSACTION_basicTypes: {\n                    data.enforceInterface(DESCRIPTOR);\n                    int _arg0;\n                    _arg0 = data.readInt();\n                    long _arg1;\n                    _arg1 = data.readLong();\n                    boolean _arg2;\n                    _arg2 = (0 != data.readInt());\n                    float _arg3;\n                    _arg3 = data.readFloat();\n                    double _arg4;\n                    _arg4 = data.readDouble();\n                    java.lang.String _arg5;\n                    _arg5 = data.readString();\n                    this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);\n                    reply.writeNoException();\n                    return true;\n                }\n                case TRANSACTION_setData: {\n                    data.enforceInterface(DESCRIPTOR);\n                    java.lang.String _arg0;\n                    _arg0 = data.readString();\n                    this.setData(_arg0);\n                    reply.writeNoException();\n                    return true;\n                }\n                case TRANSACTION_isRunning: {\n                    data.enforceInterface(DESCRIPTOR);\n                    boolean _arg0;\n                    _arg0 = (0 != data.readInt());\n                    this.isRunning(_arg0);\n                    reply.writeNoException();\n                    return true;\n                }\n            }\n            return super.onTransact(code, data, reply, flags);\n        }\n\n        private static class Proxy implements com.icodeyou.ipcaidlserver.IServerInterface {\n            private android.os.IBinder mRemote;\n\n            Proxy(android.os.IBinder remote) {\n                mRemote = remote;\n            }\n\n            @Override\n            public android.os.IBinder asBinder() {\n                return mRemote;\n            }\n\n            public java.lang.String getInterfaceDescriptor() {\n                return DESCRIPTOR;\n            }\n\n            /**\n             * Demonstrates some basic types that you can use as parameters\n             * and return values in AIDL.\n             */\n            @Override\n            public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    _data.writeInt(anInt);\n                    _data.writeLong(aLong);\n                    _data.writeInt(((aBoolean) ? (1) : (0)));\n                    _data.writeFloat(aFloat);\n                    _data.writeDouble(aDouble);\n                    _data.writeString(aString);\n                    mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0);\n                    _reply.readException();\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n            }\n\n            // 运行在客户端，执行到 mRemote.transact() 时当前线程挂起，服务端的 onTransact 被调用直到 RPC 结束\n            @Override\n            public void setData(java.lang.String data) throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    _data.writeString(data);\n                    mRemote.transact(Stub.TRANSACTION_setData, _data, _reply, 0);\n                    _reply.readException();\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n            }\n\n            @Override\n            public void isRunning(boolean isRunning) throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    _data.writeInt(((isRunning) ? (1) : (0)));\n                    mRemote.transact(Stub.TRANSACTION_isRunning, _data, _reply, 0);\n                    _reply.readException();\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n            }\n        }\n\n        // 定义的 code 常量，标识对应的方法\n        static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n        static final int TRANSACTION_setData = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);\n        static final int TRANSACTION_isRunning = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);\n    }\n\n    public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException;\n\n    public void setData(java.lang.String data) throws android.os.RemoteException;\n\n    public void isRunning(boolean isRunning) throws android.os.RemoteException;\n}\n```\n\n根据注释就能了解 Binder 的工作机制，但还是有两点需要注意一下：\n\n- 当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以如果一个远程方法是很耗时的，那么就不能在 UI 线程中发起此远程请求。（可以试着在远程方法中加个 Thread.sleep，看看效果）\n\n- 由于服务端的 Binder 方法运行在 Binder 线程池中，所以 Binder 方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了。\n\n以上就是对 aidl 文件的分析，那么问题来了，aidl 文件是不是必须的？答案是：`.aidl 文件并不是实现 Binder 的必需品`，`.aidl 文件的本质是系统为我们提供了一种快速实现 Binder 的工具而已`，所以说，实现 IPC 完全可以不用新建 .aidl 文件，而是自己写那个由 .aidl 文件生成的 .java 文件，当然，这比较难了。\n\n我现在还没有能力靠手工写出一个上述生成的 .java 文件，做个标记，希望随着学习的深入以后能办到。\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-10-28-AIDL.markdown","raw":"title: AIDL 使用及原理探索\ndate: 2015-10-28 22:18:44 \ntags: Android\n----\n\nAIDL 是 Android IPC 通信的一种方式，底层实现是 Binder。本文主要介绍 AIDL 的使用以及分析根据 .aidl 自动生成的 .java 文件。\n\n<!--more-->\n\n# AIDL 在两个进程通信中的使用\n\n我们需要有两个进程，分别称之为 Client 和 Server，最终要使用 AIDL 实现的效果是 Client 可以调用 Server 进程中的方法，即跨进程调用（RPC），执行效果如下图所示：\n\n![aidl-play](http://7xivx9.com1.z0.glb.clouddn.com/aidl-play.gif)\n\n### Server 端\n\n1、在 Server 的工程上新建一个 AIDL 文件，如 IServerInterface.aidl，添加上需要在 Client 调用的方法，代码如下：\n\n```\n// IServerInterface.aidl\npackage com.icodeyou.ipcaidlserver;\n\n// Declare any non-default types here with import statements\n\ninterface IServerInterface {\n    /**\n     * Demonstrates some basic types that you can use as parameters\n     * and return values in AIDL.\n     */\n    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,\n            double aDouble, String aString);\n\n    // 这是手动增加的方法，作用为设置 Server 中 Service 的对象 data 值\n    void setData(String data);\n    // 这是手动增加的方法，作用为设置 Server 中 Service 的对象 isRunning 值\n    void isRunning(boolean isRunning);\n}\n```\n\n可以看到这个接口中有两个我们手动新添加的方法，也就是我们要在 Client 能够调用的方法。\n\n2、在 Server 的工程上新建一个 Service，如 ServerService，并实现其 onBind() 等回调方法，代码如下：\n\n```\npackage com.icodeyou.ipcaidlserver;\nimport ...\n\npublic class ServerService extends Service {\n    private static final String TAG = \"ServerService\";\n    // Service 中维护的变量，之后在一个线程中循环打印\n    private String mData = \"1\";\n    // 线程运行的标志变量\n    private boolean mIsRunning = true;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // Service 创建后每隔一秒打印一次 mData\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (mIsRunning)\n                try {\n                    Thread.sleep(1000);\n                    Log.d(TAG, mData);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n    \t// 很重要，在客户端调用 bindService() 后会调用到这里，返回 binder 对象给客户端\n        return new IServerInterface.Stub() {\n            @Override\n            public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException {\n            }\n\n            // 根据客户端调用方法时传的参数替换本 Service 中对象的值，下同\n            @Override\n            public void setData(String data) throws RemoteException {\n                ServerService.this.mData = data;\n            }\n\n            @Override\n            public void isRunning(boolean isRunning) throws RemoteException {\n                mIsRunning = isRunning;\n            }\n        };\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n    }\n}\n```\n\nServer 端的代码就搞定了，可以直接现在模拟器上运行了，只要等待下面客户端的远程调用就可以了，下面看客户端的实现部分。\n\n### Client\n\n客户端的截图如下：\n\n![aidlclient](http://7xivx9.com1.z0.glb.clouddn.com/aidl-client.png)\n\n根据截图，说一下客户端要完成的工作：\n\n- 绑定到远程的 Service，并将远程 Service 的 onBind() 返回的 Binder 对象保存\n- 通过上一步获取到的 Binder 对象，可直接调用 binder.setData() 以及 binder.isRunning() 来设置远程 Service 的状态\n\n下面看客户端的代码：\n\n```\npackage com.icodeyou.ipcaidlclient;\n\nimport ...\n\npublic class MainActivity extends Activity implements View.OnClickListener {\n    private static final String TAG = \"MainActivity\";\n    // 绑定远程 Service 的 Intent\n    private Intent serviceIntent;\n    // 保存远程 Service#onBind() 方法的返回值，即 Binder 对象\n    private IServerInterface binder = null;\n\n    // bindService() 需要用到的 ServiceConnection 对象\n    private ServiceConnection serviceConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            // 当远程的 onBind() 返回时，调用到这里，将远程的 IBinder 转换成本地的 Binder 对象保存\n            binder = IServerInterface.Stub.asInterface(service);\n            // 注意这里不能够使用强制类型转换，因为两个对象在两个进程中(不同的 Dalvik)，不是属于同一个类\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        serviceIntent = new Intent();\n        // 这里很关键，需要明确告诉远程调用的 Service 的具体包、类的信息，因为5.0之后 Service 不允许隐式调用了\n        serviceIntent.setComponent(new ComponentName(\"com.icodeyou.ipcaidlserver\", \"com.icodeyou.ipcaidlserver.ServerService\"));\n\n        findViewById(R.id.id_btnBind).setOnClickListener(this);\n        findViewById(R.id.id_btnUnBind).setOnClickListener(this);\n        findViewById(R.id.id_btnChange).setOnClickListener(this);\n        findViewById(R.id.id_btnStop).setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.id_btnBind:\n                bindService(serviceIntent, serviceConnection, Service.BIND_AUTO_CREATE);\n                break;\n            case R.id.id_btnUnBind:\n                unbindService(serviceConnection);\n                if (binder != null) {\n                    binder = null;\n                }\n                break;\n            case R.id.id_btnChange:\n                if (binder != null) {\n                    try {\n                    \t// 可以直接通过 binder 对象来进行远程方法调用，改变远程 Service 中的值\n                        binder.setData(\"2\");\n                    } catch (RemoteException e) {\n                        e.printStackTrace();\n                    }\n                }\n                break;\n            case  R.id.id_btnStop:\n                if (binder != null) {\n                    try {\n                    \t// 可以直接通过 binder 对象来进行远程方法调用，改变远程线程运行状态\n                        binder.isRunning(false);\n                    } catch (RemoteException e) {\n                        e.printStackTrace();\n                    }\n                }\n                break;\n        }\n    }\n}\n```\n\n客户端要想使用 IServerInterface，也必须得有相关的 .aidl 文件才可以，不然让它去哪里找这个类，所以我们还需要将服务器端的 aidl 文件所在的包以及类一模一样的复制到 Client 的工程目录下，还需要 Rebuild Project，如图：\n\n![aidlcopy](http://7xivx9.com1.z0.glb.clouddn.com/aidl-copy.png)\n\n对于 AIDL 的使用，简单总结一下，客户端通过 bindService() 可以绑定到远程 Service，该远程 Service 中的 onBinder() 方法返回 IBinder 对象，此时客户端便可以通过该 IBinder 对象中相关的方法来进行远程调用。\n\n# AIDL 底层原理探索\n\n我们手动新建的 .aidl 文件到底是干嘛的，没有行不行，为什么我学了这么多年的 java 了，都不知道还有 .aidl 这么个文件类型？\n\n对于 Java 语言来说，最终能实现相应的逻辑，还得靠 .java 文件才行，那么 .aidl 文件和 .java 文件有什么关系？细心点就不难发现，我们在建立了 .aidl 文件并 Rebuild Project 后，在 build/generated/aidl 文件夹下就会有一个同名的 .java 文件，并且这是一个接口文件，如图：\n\n![aidlgen](http://7xivx9.com1.z0.glb.clouddn.com/aidl-gen.png)\n\n这个文件是根据 .aidl 文件中的内容自动生成的，所以每次我们改变了 .aidl 文件中的内容后，都需要 Rebuild 一下来重新自动生成这个文件，而且 Android Studio 也会在顶部提示我们，如图：\n\n![aidlgentips](http://7xivx9.com1.z0.glb.clouddn.com/aidl-gen-tips.png)\n\n下面来看一个这个文件中的代码，其实也不复杂，根据代码先后顺序使用注释来分析：\n\n```\n/*\n * This file is auto-generated.  DO NOT MODIFY.\n * Original file: /Users/huan/Repository/AndroidStudioProjects/AndroidHeros/ipcaidlserver/src/main/aidl/com/icodeyou/ipcaidlserver/IServerInterface.aidl\n */\npackage com.icodeyou.ipcaidlserver;\n// Declare any non-default types here with import statements\n\npublic interface IServerInterface extends android.os.IInterface {\n    // 内部的 Stub 类，在上面 AIDL 的使用上会用到这个类 \n    public static abstract class Stub extends android.os.Binder implements com.icodeyou.ipcaidlserver.IServerInterface {\n    \t// Binder 的唯一标识，一般用当前 Binder 的类名表示\n        private static final java.lang.String DESCRIPTOR = \"com.icodeyou.ipcaidlserver.IServerInterface\";\n\n        public Stub() {\n            this.attachInterface(this, DESCRIPTOR);\n        }\n\n        // 用于将服务器端的 Binder 对象转换成客户端所需的 AIDL 接口类型的对象\n        // 并且这种转换区分进程的，如果C和S位于同一进程，那么返回服务端的Stub对象本身，否则返回的是系统封装后的 Stub.proxy 对象\n        public static com.icodeyou.ipcaidlserver.IServerInterface asInterface(android.os.IBinder obj) {\n            if ((obj == null)) {\n                return null;\n            }\n            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n            if (((iin != null) && (iin instanceof com.icodeyou.ipcaidlserver.IServerInterface))) {\n                return ((com.icodeyou.ipcaidlserver.IServerInterface) iin);\n            }\n            return new com.icodeyou.ipcaidlserver.IServerInterface.Stub.Proxy(obj);\n        }\n\n        // 返回当前 Binder 对象\n        @Override\n        public android.os.IBinder asBinder() {\n            return this;\n        }\n\n        // 运行在服务端的 Binder 线程池中，通过 code 来调用相关方法\n        @Override\n        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n            switch (code) {\n                case INTERFACE_TRANSACTION: {\n                    reply.writeString(DESCRIPTOR);\n                    return true;\n                }\n                case TRANSACTION_basicTypes: {\n                    data.enforceInterface(DESCRIPTOR);\n                    int _arg0;\n                    _arg0 = data.readInt();\n                    long _arg1;\n                    _arg1 = data.readLong();\n                    boolean _arg2;\n                    _arg2 = (0 != data.readInt());\n                    float _arg3;\n                    _arg3 = data.readFloat();\n                    double _arg4;\n                    _arg4 = data.readDouble();\n                    java.lang.String _arg5;\n                    _arg5 = data.readString();\n                    this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);\n                    reply.writeNoException();\n                    return true;\n                }\n                case TRANSACTION_setData: {\n                    data.enforceInterface(DESCRIPTOR);\n                    java.lang.String _arg0;\n                    _arg0 = data.readString();\n                    this.setData(_arg0);\n                    reply.writeNoException();\n                    return true;\n                }\n                case TRANSACTION_isRunning: {\n                    data.enforceInterface(DESCRIPTOR);\n                    boolean _arg0;\n                    _arg0 = (0 != data.readInt());\n                    this.isRunning(_arg0);\n                    reply.writeNoException();\n                    return true;\n                }\n            }\n            return super.onTransact(code, data, reply, flags);\n        }\n\n        private static class Proxy implements com.icodeyou.ipcaidlserver.IServerInterface {\n            private android.os.IBinder mRemote;\n\n            Proxy(android.os.IBinder remote) {\n                mRemote = remote;\n            }\n\n            @Override\n            public android.os.IBinder asBinder() {\n                return mRemote;\n            }\n\n            public java.lang.String getInterfaceDescriptor() {\n                return DESCRIPTOR;\n            }\n\n            /**\n             * Demonstrates some basic types that you can use as parameters\n             * and return values in AIDL.\n             */\n            @Override\n            public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    _data.writeInt(anInt);\n                    _data.writeLong(aLong);\n                    _data.writeInt(((aBoolean) ? (1) : (0)));\n                    _data.writeFloat(aFloat);\n                    _data.writeDouble(aDouble);\n                    _data.writeString(aString);\n                    mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0);\n                    _reply.readException();\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n            }\n\n            // 运行在客户端，执行到 mRemote.transact() 时当前线程挂起，服务端的 onTransact 被调用直到 RPC 结束\n            @Override\n            public void setData(java.lang.String data) throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    _data.writeString(data);\n                    mRemote.transact(Stub.TRANSACTION_setData, _data, _reply, 0);\n                    _reply.readException();\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n            }\n\n            @Override\n            public void isRunning(boolean isRunning) throws android.os.RemoteException {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    _data.writeInt(((isRunning) ? (1) : (0)));\n                    mRemote.transact(Stub.TRANSACTION_isRunning, _data, _reply, 0);\n                    _reply.readException();\n                } finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n            }\n        }\n\n        // 定义的 code 常量，标识对应的方法\n        static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n        static final int TRANSACTION_setData = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);\n        static final int TRANSACTION_isRunning = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);\n    }\n\n    public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException;\n\n    public void setData(java.lang.String data) throws android.os.RemoteException;\n\n    public void isRunning(boolean isRunning) throws android.os.RemoteException;\n}\n```\n\n根据注释就能了解 Binder 的工作机制，但还是有两点需要注意一下：\n\n- 当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以如果一个远程方法是很耗时的，那么就不能在 UI 线程中发起此远程请求。（可以试着在远程方法中加个 Thread.sleep，看看效果）\n\n- 由于服务端的 Binder 方法运行在 Binder 线程池中，所以 Binder 方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了。\n\n以上就是对 aidl 文件的分析，那么问题来了，aidl 文件是不是必须的？答案是：`.aidl 文件并不是实现 Binder 的必需品`，`.aidl 文件的本质是系统为我们提供了一种快速实现 Binder 的工具而已`，所以说，实现 IPC 完全可以不用新建 .aidl 文件，而是自己写那个由 .aidl 文件生成的 .java 文件，当然，这比较难了。\n\n我现在还没有能力靠手工写出一个上述生成的 .java 文件，做个标记，希望随着学习的深入以后能办到。\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-10-28-AIDL","published":1,"updated":"2015-10-28T13:05:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yny3000rek5xcadxlyjx"},{"title":"自定义 View 之 onMeasure","date":"2015-10-22T14:18:44.000Z","_content":"\n现阶段的目标就是：好好学习自定义 View 如何实现，只知道理论不行，必须实际攻克这个难题了，做出真正有用的自定义 View 出来。先总结一些关于自定义 View 遇到的问题，结合源码分析会更明确。\n\n<!--more-->\n\n本节先说测量，即 onMeasure。我们在使用系统提供的控件时，几乎都会使用 layout_width（和 layout_height，下同） 这样的属性来设置控件的宽和高，其实这就是在通过 XML 的方式告诉系统对于该 View 的控件如何去 measure。那么下面就简单自定义一个 View，咱们也给自己的 View 用 layout_width 指定个宽高试试。\n\n自定义View\n\n```\npublic class MyView extends View {\n    // 从 xml 中使用控件必须要写的构造方法 \n    public MyView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n}\n```\n\n布局文件\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <com.icodeyou.viewmeasure.MyView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"#abcdef\" />\n\n</RelativeLayout>\n```\n\n我们先后改一下 layout_width 和 layout_height 属性，当其属性为 30dp, match_parent 的时候，发现控件显示的大小确实符合我们的预期。但是，当我们指定其为 wrap_content 的时候，却意外发现和 match_parent 效果是相同的，即铺满了整个父级容器，为什么会这样，我们需要根据源码来看一下了。\n\n在 View 中，有个方法叫做 onMeasure，也就是本节要讨论的主题，源码如下：\n\n```\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n}\n```\n\n要看懂以上代码，需要先知道什么是 MeasureSpec。简单来说，这个类可以帮我们保存控件测量的模式和测量的大小，本质上是一个32位的 int 值，其中高2位为测量的模式，低30位为测量的大小。这么说没意思，直接看源码，它是 View 的一个静态内部类：\n\n```\npublic static class MeasureSpec {\n        private static final int MODE_SHIFT = 30;\n        private static final int MODE_MASK  = 0x3 << MODE_SHIFT;\n\n        // 使用高2位来保存测量模式\n        public static final int UNSPECIFIED = 0 << MODE_SHIFT;\n        public static final int EXACTLY     = 1 << MODE_SHIFT;\n        public static final int AT_MOST     = 2 << MODE_SHIFT;\n\n        // 根据传入的测量大小和测量模式返回 MeasureSpec 对象，其实就是一个int\n        public static int makeMeasureSpec(int size, int mode) {\n            if (sUseBrokenMakeMeasureSpec) {\n                return size + mode;\n            } else {\n                return (size & ~MODE_MASK) | (mode & MODE_MASK);\n            }\n        }\n\n        // 从传入的 MeasureSpec 中取得测量模式，取其高2位\n        public static int getMode(int measureSpec) {\n            return (measureSpec & MODE_MASK);\n        }\n\n        // 从传入的 MeasureSpec 中取得测量大小，取其低30位\n        public static int getSize(int measureSpec) {\n            return (measureSpec & ~MODE_MASK);\n        }\n}\n```\n\n看源代码就很清晰 MeasureSpec 这么短小精悍的类是怎么工作的了，主要就是用到了移位和关系与逻辑运算来操作，下面来具体说说三种 MeasureSpec Mode 的区别是什么。\n\n- EXACTLY\n精确模式，当 layout_width 指定为 100dp 和 match_parent 时，即使用这种模式。\n\n- AT_MOST\n最大值模式，当 layout_width 指定为 wrap_content 时，控件大小随着控件子空间或内容的变化而变化，此时控件的尺寸只要不超过父控件允许的最大值即可。\n\n- UNSPECIFIED\n想多大就多大，至今没用过。。。\n\n另外，specSize 的单位是 px，而不是 dp，可以自己输出看一下。（我320dpi的模拟器，输出结果为 xml 中指定 dp 数值的2倍）看懂了什么是 MeasureSpec，下面可以再回顾我们刚才贴出来的 View 中 onMeasure 默认的代码了：\n\n```\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n}\n```\n\n其实就是通过 setMeasureDimension 来设置 View 的大小的，里面传入的分别是宽和高，可以自己重写这个方法然后写个具体的值进去看看效果（其实就是无论在 xml 中怎么指定大小，都会以你自己在这里写的值为准）。那么继续看 getDefaultSize() 这个方法干了些什么：\n\n```\npublic static int getDefaultSize(int size, int measureSpec) {\n        int result = size;\n        int specMode = MeasureSpec.getMode(measureSpec);\n        int specSize = MeasureSpec.getSize(measureSpec);\n\n        switch (specMode) {\n        case MeasureSpec.UNSPECIFIED:\n            result = size;\n            break;\n        // 注意 AT_MOST 后面没有 break 啊\n        case MeasureSpec.AT_MOST:\n        case MeasureSpec.EXACTLY:\n            result = specSize;\n            break;\n        }\n        return result;\n}\n```\n\n好好看看这段代码，发现 AT_MOST 和 EXACTLY 两种模式都是返回的 specSize 啊，当指定为 wrap_content 的时候就是 AT_MOST 模式，那最大值就是父容器的大小了，所以会出现我们在文章开始提到的那个问题--指定为 wrap_content 时控件会铺满父级容器。\n\n跟着源码过了一遍原理，那么下面我们再来提一个需求--当指定为 wrap_content 的时候，将控件大小设置为 200 px，而不是任由它铺满整个父级容器，想一想这个应该怎么来实现呢？\n\n首先，肯定是要重写 onMeasure() 方法了，在其 setMeasuredDimension() 方法中传入我们设置好的宽和高，就可以实现我们的需求了，那么子 View 的 onMeasure 代码如下：\n\n```\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\tsetMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec));\n}\n```\n\n我们又自己写了两个方法当做 setMeasuredDimension 的参数，下面分析其中的一个即可，比如 measureWidth():\n\n```\nprivate int measureWidth(int widthMeasureSpec) {\n\tint result = 0;\n\t// 获取参数中的测量模式和测量大小\n    int specMode = MeasureSpec.getMode(widthMeasureSpec);\n\tint specSize = MeasureSpec.getSize(widthMeasureSpec);\n\n\tif (specMode == MeasureSpec.EXACTLY) {\n\t\t// 精确模式，没的说，大小该是多少就是多少\n\t\tresult = specSize;\n\t}else{\n\t\tresult = 200;\n\t\t// wrap_content 的话，根据刚才的需求，大小只能是 200 和 specSize 的最小值\n\t\tif (specMode == MeasureSpec.AT_MOST) {\n\t\t\tresult = Math.min(result, specSize);\n        }\n\t}\n\n\t// 注意返回值单位是 px，不是 dp\n\treturn result;\n}\n```\n\n此时，当我们在 xml 中指定控件大小为 wrap_content 的时候，大小就会是 200 px了，而不是铺满了整个父级容器，效果如图：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/viewonmeasure.png)\n\n此篇文章浅层次分析了 View 的测量，重点是 onMeasure 方法的作用，下篇文章准备继续深度说说 View 的测量流程。\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-10-22-ViewMeasure.markdown","raw":"title: 自定义 View 之 onMeasure\ndate: 2015-10-22 22:18:44 \ntags: Android\n----\n\n现阶段的目标就是：好好学习自定义 View 如何实现，只知道理论不行，必须实际攻克这个难题了，做出真正有用的自定义 View 出来。先总结一些关于自定义 View 遇到的问题，结合源码分析会更明确。\n\n<!--more-->\n\n本节先说测量，即 onMeasure。我们在使用系统提供的控件时，几乎都会使用 layout_width（和 layout_height，下同） 这样的属性来设置控件的宽和高，其实这就是在通过 XML 的方式告诉系统对于该 View 的控件如何去 measure。那么下面就简单自定义一个 View，咱们也给自己的 View 用 layout_width 指定个宽高试试。\n\n自定义View\n\n```\npublic class MyView extends View {\n    // 从 xml 中使用控件必须要写的构造方法 \n    public MyView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n}\n```\n\n布局文件\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <com.icodeyou.viewmeasure.MyView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"#abcdef\" />\n\n</RelativeLayout>\n```\n\n我们先后改一下 layout_width 和 layout_height 属性，当其属性为 30dp, match_parent 的时候，发现控件显示的大小确实符合我们的预期。但是，当我们指定其为 wrap_content 的时候，却意外发现和 match_parent 效果是相同的，即铺满了整个父级容器，为什么会这样，我们需要根据源码来看一下了。\n\n在 View 中，有个方法叫做 onMeasure，也就是本节要讨论的主题，源码如下：\n\n```\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n}\n```\n\n要看懂以上代码，需要先知道什么是 MeasureSpec。简单来说，这个类可以帮我们保存控件测量的模式和测量的大小，本质上是一个32位的 int 值，其中高2位为测量的模式，低30位为测量的大小。这么说没意思，直接看源码，它是 View 的一个静态内部类：\n\n```\npublic static class MeasureSpec {\n        private static final int MODE_SHIFT = 30;\n        private static final int MODE_MASK  = 0x3 << MODE_SHIFT;\n\n        // 使用高2位来保存测量模式\n        public static final int UNSPECIFIED = 0 << MODE_SHIFT;\n        public static final int EXACTLY     = 1 << MODE_SHIFT;\n        public static final int AT_MOST     = 2 << MODE_SHIFT;\n\n        // 根据传入的测量大小和测量模式返回 MeasureSpec 对象，其实就是一个int\n        public static int makeMeasureSpec(int size, int mode) {\n            if (sUseBrokenMakeMeasureSpec) {\n                return size + mode;\n            } else {\n                return (size & ~MODE_MASK) | (mode & MODE_MASK);\n            }\n        }\n\n        // 从传入的 MeasureSpec 中取得测量模式，取其高2位\n        public static int getMode(int measureSpec) {\n            return (measureSpec & MODE_MASK);\n        }\n\n        // 从传入的 MeasureSpec 中取得测量大小，取其低30位\n        public static int getSize(int measureSpec) {\n            return (measureSpec & ~MODE_MASK);\n        }\n}\n```\n\n看源代码就很清晰 MeasureSpec 这么短小精悍的类是怎么工作的了，主要就是用到了移位和关系与逻辑运算来操作，下面来具体说说三种 MeasureSpec Mode 的区别是什么。\n\n- EXACTLY\n精确模式，当 layout_width 指定为 100dp 和 match_parent 时，即使用这种模式。\n\n- AT_MOST\n最大值模式，当 layout_width 指定为 wrap_content 时，控件大小随着控件子空间或内容的变化而变化，此时控件的尺寸只要不超过父控件允许的最大值即可。\n\n- UNSPECIFIED\n想多大就多大，至今没用过。。。\n\n另外，specSize 的单位是 px，而不是 dp，可以自己输出看一下。（我320dpi的模拟器，输出结果为 xml 中指定 dp 数值的2倍）看懂了什么是 MeasureSpec，下面可以再回顾我们刚才贴出来的 View 中 onMeasure 默认的代码了：\n\n```\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n}\n```\n\n其实就是通过 setMeasureDimension 来设置 View 的大小的，里面传入的分别是宽和高，可以自己重写这个方法然后写个具体的值进去看看效果（其实就是无论在 xml 中怎么指定大小，都会以你自己在这里写的值为准）。那么继续看 getDefaultSize() 这个方法干了些什么：\n\n```\npublic static int getDefaultSize(int size, int measureSpec) {\n        int result = size;\n        int specMode = MeasureSpec.getMode(measureSpec);\n        int specSize = MeasureSpec.getSize(measureSpec);\n\n        switch (specMode) {\n        case MeasureSpec.UNSPECIFIED:\n            result = size;\n            break;\n        // 注意 AT_MOST 后面没有 break 啊\n        case MeasureSpec.AT_MOST:\n        case MeasureSpec.EXACTLY:\n            result = specSize;\n            break;\n        }\n        return result;\n}\n```\n\n好好看看这段代码，发现 AT_MOST 和 EXACTLY 两种模式都是返回的 specSize 啊，当指定为 wrap_content 的时候就是 AT_MOST 模式，那最大值就是父容器的大小了，所以会出现我们在文章开始提到的那个问题--指定为 wrap_content 时控件会铺满父级容器。\n\n跟着源码过了一遍原理，那么下面我们再来提一个需求--当指定为 wrap_content 的时候，将控件大小设置为 200 px，而不是任由它铺满整个父级容器，想一想这个应该怎么来实现呢？\n\n首先，肯定是要重写 onMeasure() 方法了，在其 setMeasuredDimension() 方法中传入我们设置好的宽和高，就可以实现我们的需求了，那么子 View 的 onMeasure 代码如下：\n\n```\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n\tsetMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec));\n}\n```\n\n我们又自己写了两个方法当做 setMeasuredDimension 的参数，下面分析其中的一个即可，比如 measureWidth():\n\n```\nprivate int measureWidth(int widthMeasureSpec) {\n\tint result = 0;\n\t// 获取参数中的测量模式和测量大小\n    int specMode = MeasureSpec.getMode(widthMeasureSpec);\n\tint specSize = MeasureSpec.getSize(widthMeasureSpec);\n\n\tif (specMode == MeasureSpec.EXACTLY) {\n\t\t// 精确模式，没的说，大小该是多少就是多少\n\t\tresult = specSize;\n\t}else{\n\t\tresult = 200;\n\t\t// wrap_content 的话，根据刚才的需求，大小只能是 200 和 specSize 的最小值\n\t\tif (specMode == MeasureSpec.AT_MOST) {\n\t\t\tresult = Math.min(result, specSize);\n        }\n\t}\n\n\t// 注意返回值单位是 px，不是 dp\n\treturn result;\n}\n```\n\n此时，当我们在 xml 中指定控件大小为 wrap_content 的时候，大小就会是 200 px了，而不是铺满了整个父级容器，效果如图：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/viewonmeasure.png)\n\n此篇文章浅层次分析了 View 的测量，重点是 onMeasure 方法的作用，下篇文章准备继续深度说说 View 的测量流程。\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-10-22-ViewMeasure","published":1,"updated":"2015-10-22T09:15:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yny4000tek5xaq0xci77"},{"title":"说说 getMainLooper","date":"2015-10-11T14:18:44.000Z","_content":"\n关于 Handler、Looper、MessageQueue，我想大家都了解的差不多了，简单来说就是一个 Handler 对应一个 Looper，一个 Looper 对应一个 Message。那么再想个问题，`一个 Handler 可以对应多个 Looper 吗？` `一个 Looper 可以对应多个 Handler 吗？`\n\n<!--more-->\n\n之所以会提出上面这个问题，主要是因为在看 Looper 的源码时，发现了其中的 `getMainLooper` 这个方法，从名字可以看出是获取主线程的 Looper，那么为什么要特别提供这个方法呢？首先看一下这个方法的源码，很简单：\n\n```java\n    /*\n     * 返回应用主线程中的 Looper\n     */\n    public static Looper getMainLooper() {\n        synchronized (Looper.class) {\n            return sMainLooper;\n        }\n    }\n```\n\n其实我们平时最常用的是无构造参数的 Handler，其实 Handler 还有构造参数的构造方法，如下：\n\n```java\n    public Handler(Looper looper, Callback callback, boolean async) {\n        mLooper = looper;\n        mQueue = looper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n在此注意构造函数中第一个参数是 Looper 就可以了，那么也就是说，我们可以传递一个已有的 Looper 来创建 Handler。这里先不写示例代码了，填个坑，以后有时间再写，大概是下面这样：\n\n```java\n    Handler handler = new Handler(Looper.getMainLooper()){\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n        }\n    };\n```\n\n注意上面的 Looper.getMainLooper()，将主线程中的 Looper 扔进去了，也就是说 handleMessage 会运行在主线程中，那么这样有什么用呢？这样可以在主线程中更新 UI 而不用把 Handler 定义在主线程中。\n\n当然刚才提到的作用只是对应于主线程中的 sMainLooper 了，其实各种 Looper 都可以往 Handler 的构造方法这里扔，从而使得 handleMessage 运行在你想要的线程中，进而实现线程间通信。\n\n那么想到另一篇文章 [HandlerThread源码解析](http://icodeyou.com/2015/10/11/2015-10-11-HandlerThread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/) 中 HandlerThread#getLooper() 的作用了吗？\n\n文章开头也提到了一个问题，那么答案就应该是：一个 Handler 中只能有一个 Looper，而一个 Looper 则可以对应多个 Handler，只要把 Looper 往 Handler 的构造方法里扔扔扔就好了。\n\n今天再看了看 AsyncTask 的源码，发现其中也用到了 getMainLooper()，来更新 UI，源码如下：\n\n```\nprivate static class InternalHandler extends Handler {\n        public InternalHandler() {\n            // 使用主线程的 Looper 扔给 Handler\n            super(Looper.getMainLooper());\n        }\n}\n```\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-10-11-getMainLooper.markdown","raw":"title: 说说 getMainLooper\ndate: 2015-10-11 22:18:44 \ntags: Android\n----\n\n关于 Handler、Looper、MessageQueue，我想大家都了解的差不多了，简单来说就是一个 Handler 对应一个 Looper，一个 Looper 对应一个 Message。那么再想个问题，`一个 Handler 可以对应多个 Looper 吗？` `一个 Looper 可以对应多个 Handler 吗？`\n\n<!--more-->\n\n之所以会提出上面这个问题，主要是因为在看 Looper 的源码时，发现了其中的 `getMainLooper` 这个方法，从名字可以看出是获取主线程的 Looper，那么为什么要特别提供这个方法呢？首先看一下这个方法的源码，很简单：\n\n```java\n    /*\n     * 返回应用主线程中的 Looper\n     */\n    public static Looper getMainLooper() {\n        synchronized (Looper.class) {\n            return sMainLooper;\n        }\n    }\n```\n\n其实我们平时最常用的是无构造参数的 Handler，其实 Handler 还有构造参数的构造方法，如下：\n\n```java\n    public Handler(Looper looper, Callback callback, boolean async) {\n        mLooper = looper;\n        mQueue = looper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n在此注意构造函数中第一个参数是 Looper 就可以了，那么也就是说，我们可以传递一个已有的 Looper 来创建 Handler。这里先不写示例代码了，填个坑，以后有时间再写，大概是下面这样：\n\n```java\n    Handler handler = new Handler(Looper.getMainLooper()){\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n        }\n    };\n```\n\n注意上面的 Looper.getMainLooper()，将主线程中的 Looper 扔进去了，也就是说 handleMessage 会运行在主线程中，那么这样有什么用呢？这样可以在主线程中更新 UI 而不用把 Handler 定义在主线程中。\n\n当然刚才提到的作用只是对应于主线程中的 sMainLooper 了，其实各种 Looper 都可以往 Handler 的构造方法这里扔，从而使得 handleMessage 运行在你想要的线程中，进而实现线程间通信。\n\n那么想到另一篇文章 [HandlerThread源码解析](http://icodeyou.com/2015/10/11/2015-10-11-HandlerThread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/) 中 HandlerThread#getLooper() 的作用了吗？\n\n文章开头也提到了一个问题，那么答案就应该是：一个 Handler 中只能有一个 Looper，而一个 Looper 则可以对应多个 Handler，只要把 Looper 往 Handler 的构造方法里扔扔扔就好了。\n\n今天再看了看 AsyncTask 的源码，发现其中也用到了 getMainLooper()，来更新 UI，源码如下：\n\n```\nprivate static class InternalHandler extends Handler {\n        public InternalHandler() {\n            // 使用主线程的 Looper 扔给 Handler\n            super(Looper.getMainLooper());\n        }\n}\n```\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-10-11-getMainLooper","published":1,"updated":"2015-10-14T02:16:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yny6000vek5xctr5uu75"},{"title":"IntentService 源码解析","date":"2015-10-11T14:18:44.000Z","_content":"\nService 运行在主线程，IntentService 运行在子线程并且可以在执行完 onHandleIntent 方法后自动结束，下面通过分析 Android 源码分析下上述的原理。\n\n<!--more-->\n\nIntentService 代码量不大，下面来看一下主要的变量和几个函数：\n\n```java\npublic abstract class IntentService extends Service {\n\t// 保存从 HandlerThread 中得到的 Looper，该 Looper 位于子线程\n    private volatile Looper mServiceLooper;\n    // 处理 Message 的 Handler，其 Looper 为上面的 mServiceLooper\n    private volatile ServiceHandler mServiceHandler;\n    private String mName;\n\n    private final class ServiceHandler extends Handler {\n        public ServiceHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n        \t// mServiceLooper 取出消息后发送到这里，执行其 onHandleIntent 方法，因为该 Looper 位于子线程，所以下面的两个方法都会运行在子线程\n            onHandleIntent((Intent)msg.obj);\n            // onHandleIntent 执行完毕后自动结束自己\n            stopSelf(msg.arg1);\n        }\n    }\n\n    /*\n     * 只有这个构造方法，所以子类需要明确指定 name，只是方便调试，没有其它用处\n     */\n    public IntentService(String name) {\n        super();\n        mName = name;\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // 创建 HandlerThread，其内部会自动创建一个 Looper 对象\n        HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\");\n        // 必须调用 start 才可以，因为逻辑写在了线程的 run 方法里\n        thread.start();\n\n        // 从 HandlerThread 里获取到其中创建好的 Looper，并注意该 Looper 是在子线程中创建的\n        mServiceLooper = thread.getLooper();\n        // 用上述 Looper 创建 mServiceHandler\n        mServiceHandler = new ServiceHandler(mServiceLooper);\n    }\n\n    @Override\n    public void onStart(Intent intent, int startId) {\n    \t// Service 启动后直接就向 mServiceHandler 发送消息，则马上就会执行 handleMessage 方法\n        Message msg = mServiceHandler.obtainMessage();\n        msg.arg1 = startId;\n        msg.obj = intent;\n        mServiceHandler.sendMessage(msg);\n    }\n\n    /*\n     * 一般不覆盖这个方法\n     */\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        onStart(intent, startId);\n        // 可暂时忽略 START_REDELIVER_INTENT\n        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;\n    }\n\n    @Override\n    public void onDestroy() {\n        mServiceLooper.quit();\n    }\n\n    /*\n     * 每次只处理一个任务\n     */\n    @WorkerThread   // 工作线程，即子线程\n    protected abstract void onHandleIntent(Intent intent);\n}\n```\n\n流程分析：\n\n1、启动后首先执行31行 `onCreate` 方法，在其中创建了 HandlerThread，调用其 start 方法后可在其内部创建一个 Handler，所以此处的 Handler 是在子线程创建的，运行在子线程，这对于后面 onHandleIntent 运行在子线程至关重要。接着使用 thread.getLooper() 获取到了其中的 Looper 对象，并使用该 Looper 当做参数创建了 mServiceHandler。\n\n2、接着是45行的 `onStart` 方法，在此从 mServiceHandler 中获取了一个 Message，其 obj 为传过来的 Intent 对象，并调用 mServiceHandler.sendMessage(msg) 将消息压入消息队列，所以下面就要执行14行的 mServiceHandler 的 `handleMessage()` 方法。\n\n3、进入 handleMessage 方法，第一行就清晰地调用了 `onHandleIntent` 方法，显然就会执行子类覆盖的 onHandleIntent 方法了，并且是在`子线程`，因为 mServiceHandler 中的 Looper 是子线程中创建的。\n\n4、最后调用18行的 stopSelf() 来自我结束。 \n\n以上就分析完了 IntentService 的整个流程，所以可以发现其内部最主要的还是用了 Handler、Looper、Message 通信机制，并且在此需要注意 Looper 是从 HandlerThread 子线程中取出来的，这样才可以让 handleMessage 运行在子线程中。\n\n另外还需要知道的是，如果客户端多次启动同一个 IntentService，则所有任务要串行执行，因为其内部采用 Handler、MessageQueue，Message 要一个一个压进去、一个一个取出来执行，所以就串行了。\n\n关于 HandlerThread，可以看看我写的这篇文章，[HandlerThread 源码解析](http://icodeyou.com/2015/10/11/2015-10-11-HandlerThread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/)\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-10-11-IntentService源码解析.markdown","raw":"title: IntentService 源码解析\ndate: 2015-10-11 22:18:44 \ntags: Android\n----\n\nService 运行在主线程，IntentService 运行在子线程并且可以在执行完 onHandleIntent 方法后自动结束，下面通过分析 Android 源码分析下上述的原理。\n\n<!--more-->\n\nIntentService 代码量不大，下面来看一下主要的变量和几个函数：\n\n```java\npublic abstract class IntentService extends Service {\n\t// 保存从 HandlerThread 中得到的 Looper，该 Looper 位于子线程\n    private volatile Looper mServiceLooper;\n    // 处理 Message 的 Handler，其 Looper 为上面的 mServiceLooper\n    private volatile ServiceHandler mServiceHandler;\n    private String mName;\n\n    private final class ServiceHandler extends Handler {\n        public ServiceHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n        \t// mServiceLooper 取出消息后发送到这里，执行其 onHandleIntent 方法，因为该 Looper 位于子线程，所以下面的两个方法都会运行在子线程\n            onHandleIntent((Intent)msg.obj);\n            // onHandleIntent 执行完毕后自动结束自己\n            stopSelf(msg.arg1);\n        }\n    }\n\n    /*\n     * 只有这个构造方法，所以子类需要明确指定 name，只是方便调试，没有其它用处\n     */\n    public IntentService(String name) {\n        super();\n        mName = name;\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // 创建 HandlerThread，其内部会自动创建一个 Looper 对象\n        HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\");\n        // 必须调用 start 才可以，因为逻辑写在了线程的 run 方法里\n        thread.start();\n\n        // 从 HandlerThread 里获取到其中创建好的 Looper，并注意该 Looper 是在子线程中创建的\n        mServiceLooper = thread.getLooper();\n        // 用上述 Looper 创建 mServiceHandler\n        mServiceHandler = new ServiceHandler(mServiceLooper);\n    }\n\n    @Override\n    public void onStart(Intent intent, int startId) {\n    \t// Service 启动后直接就向 mServiceHandler 发送消息，则马上就会执行 handleMessage 方法\n        Message msg = mServiceHandler.obtainMessage();\n        msg.arg1 = startId;\n        msg.obj = intent;\n        mServiceHandler.sendMessage(msg);\n    }\n\n    /*\n     * 一般不覆盖这个方法\n     */\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        onStart(intent, startId);\n        // 可暂时忽略 START_REDELIVER_INTENT\n        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;\n    }\n\n    @Override\n    public void onDestroy() {\n        mServiceLooper.quit();\n    }\n\n    /*\n     * 每次只处理一个任务\n     */\n    @WorkerThread   // 工作线程，即子线程\n    protected abstract void onHandleIntent(Intent intent);\n}\n```\n\n流程分析：\n\n1、启动后首先执行31行 `onCreate` 方法，在其中创建了 HandlerThread，调用其 start 方法后可在其内部创建一个 Handler，所以此处的 Handler 是在子线程创建的，运行在子线程，这对于后面 onHandleIntent 运行在子线程至关重要。接着使用 thread.getLooper() 获取到了其中的 Looper 对象，并使用该 Looper 当做参数创建了 mServiceHandler。\n\n2、接着是45行的 `onStart` 方法，在此从 mServiceHandler 中获取了一个 Message，其 obj 为传过来的 Intent 对象，并调用 mServiceHandler.sendMessage(msg) 将消息压入消息队列，所以下面就要执行14行的 mServiceHandler 的 `handleMessage()` 方法。\n\n3、进入 handleMessage 方法，第一行就清晰地调用了 `onHandleIntent` 方法，显然就会执行子类覆盖的 onHandleIntent 方法了，并且是在`子线程`，因为 mServiceHandler 中的 Looper 是子线程中创建的。\n\n4、最后调用18行的 stopSelf() 来自我结束。 \n\n以上就分析完了 IntentService 的整个流程，所以可以发现其内部最主要的还是用了 Handler、Looper、Message 通信机制，并且在此需要注意 Looper 是从 HandlerThread 子线程中取出来的，这样才可以让 handleMessage 运行在子线程中。\n\n另外还需要知道的是，如果客户端多次启动同一个 IntentService，则所有任务要串行执行，因为其内部采用 Handler、MessageQueue，Message 要一个一个压进去、一个一个取出来执行，所以就串行了。\n\n关于 HandlerThread，可以看看我写的这篇文章，[HandlerThread 源码解析](http://icodeyou.com/2015/10/11/2015-10-11-HandlerThread%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/)\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-10-11-IntentService源码解析","published":1,"updated":"2015-10-11T13:44:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yny7000xek5xh52ttodx"},{"title":"HandlerThread 源码解析","date":"2015-10-11T14:18:44.000Z","_content":"\nAndroid 为我们提供好了一个类——HandlerThread，在其内部维护了一个 Looper 对象，通过线程的 start 方法启动后即可创建内部的 Looper 对象，并且此 Looper 对象运行在子线程，我们还可以通过 handlerThread.getLooper() 来取到这个 Looper 对象，免得我们自己创建了。\n\n<!--more-->\n\n根据源码分析下 HandlerThread 的机制，下面是关键代码：\n\n```java\n/*\n * 开启一个内部有 Looper 的线程，这个 Looper 可以用来创建其它 Handler，注意需要调用 start() 方法\n */\npublic class HandlerThread extends Thread {\n    // 线程优先级\n    int mPriority;\n    // 线程 id\n    int mTid = -1;\n    // 内部维护的 Looper 对象\n    Looper mLooper;\n\n    public HandlerThread(String name) {\n        super(name);\n        // 指定默认的线程优先级\n        mPriority = Process.THREAD_PRIORITY_DEFAULT;\n    }\n    \n    public HandlerThread(String name, int priority) {\n        super(name);\n        mPriority = priority;\n    }\n    \n    /*\n     * 可以覆写该回调方法来在 Looper.loop() 前执行一些操作\n     */\n    protected void onLooperPrepared() {\n    }\n\n    /*\n     * 关键方法，注意需要调用 start 方法\n     */\n    @Override\n    public void run() {\n        mTid = Process.myTid();\n        // 创建 Looper 对象，此处用到了 ThreadLocal\n        Looper.prepare();\n        synchronized (this) {\n            // 获取到 Looper 对象\n            mLooper = Looper.myLooper();\n            // 此处与 getLooper() 中的 wait 相对应\n            notifyAll();\n        }\n        Process.setThreadPriority(mPriority);\n        // loop 之前的操作，默认为空\n        onLooperPrepared();\n        Looper.loop();\n        // 为什么要为 -1？\n        mTid = -1;\n    }\n    \n    /*\n     * 关键方法，返回该线程中维护的 Looper. 如果此线程没有被 start 或者其它原因导致 isAlive() 的值是false，则此方法返回 null\n     * 如果此线程已经被 start 了，那么这个方法将会阻塞直到线程中的 Looper 已经被初始化了\n     */\n    public Looper getLooper() {\n        if (!isAlive()) {\n            return null;\n        }\n        \n        // If the thread has been started, wait until the looper has been created.\n        synchronized (this) {\n            while (isAlive() && mLooper == null) {\n                try {\n                    // 阻塞\n                    wait();\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        return mLooper;\n    }\n\n    /*\n     * 退出 HandlerThread 中的 Looper\n     * 直接退出 Looper，即使 MessageQueue 中还有未处理的消息，所以此种退出方法不安全\n     * 退出后，handler.sendMessage(msg) 将返回 false\n     */\n    public boolean quit() {\n        Looper looper = getLooper();\n        if (looper != null) {\n            looper.quit();\n            return true;\n        }\n        return false;\n    }\n\n    /*\n     * 处理完 MessageQueue 中的所有消息后才退出 Looper，所以此种退出方法比较安全\n     * 退出后，handler.sendMessage(msg) 将返回 false\n     */\n    public boolean quitSafely() {\n        Looper looper = getLooper();\n        if (looper != null) {\n            looper.quitSafely();\n            return true;\n        }\n        return false;\n    }\n\n    /*\n     * 返回线程 ID\n     */\n    public int getThreadId() {\n        return mTid;\n    }\n}\n```\n\n学习完了 HandlerThread，那么思考个问题，一个 Looper 可以对应多个 Handler 吗？具体答案见 [说说 Looper#getMainLooper](http://icodeyou.com/2015/10/11/2015-10-11-getMainLooper/)。\n\n关于 HandlerThread 的具体应用，请看 [IntentService 源码解析](http://icodeyou.com/2015/10/11/2015-10-11-IntentService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/)。\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-10-11-HandlerThread源码解析.markdown","raw":"title: HandlerThread 源码解析\ndate: 2015-10-11 22:18:44 \ntags: Android\n----\n\nAndroid 为我们提供好了一个类——HandlerThread，在其内部维护了一个 Looper 对象，通过线程的 start 方法启动后即可创建内部的 Looper 对象，并且此 Looper 对象运行在子线程，我们还可以通过 handlerThread.getLooper() 来取到这个 Looper 对象，免得我们自己创建了。\n\n<!--more-->\n\n根据源码分析下 HandlerThread 的机制，下面是关键代码：\n\n```java\n/*\n * 开启一个内部有 Looper 的线程，这个 Looper 可以用来创建其它 Handler，注意需要调用 start() 方法\n */\npublic class HandlerThread extends Thread {\n    // 线程优先级\n    int mPriority;\n    // 线程 id\n    int mTid = -1;\n    // 内部维护的 Looper 对象\n    Looper mLooper;\n\n    public HandlerThread(String name) {\n        super(name);\n        // 指定默认的线程优先级\n        mPriority = Process.THREAD_PRIORITY_DEFAULT;\n    }\n    \n    public HandlerThread(String name, int priority) {\n        super(name);\n        mPriority = priority;\n    }\n    \n    /*\n     * 可以覆写该回调方法来在 Looper.loop() 前执行一些操作\n     */\n    protected void onLooperPrepared() {\n    }\n\n    /*\n     * 关键方法，注意需要调用 start 方法\n     */\n    @Override\n    public void run() {\n        mTid = Process.myTid();\n        // 创建 Looper 对象，此处用到了 ThreadLocal\n        Looper.prepare();\n        synchronized (this) {\n            // 获取到 Looper 对象\n            mLooper = Looper.myLooper();\n            // 此处与 getLooper() 中的 wait 相对应\n            notifyAll();\n        }\n        Process.setThreadPriority(mPriority);\n        // loop 之前的操作，默认为空\n        onLooperPrepared();\n        Looper.loop();\n        // 为什么要为 -1？\n        mTid = -1;\n    }\n    \n    /*\n     * 关键方法，返回该线程中维护的 Looper. 如果此线程没有被 start 或者其它原因导致 isAlive() 的值是false，则此方法返回 null\n     * 如果此线程已经被 start 了，那么这个方法将会阻塞直到线程中的 Looper 已经被初始化了\n     */\n    public Looper getLooper() {\n        if (!isAlive()) {\n            return null;\n        }\n        \n        // If the thread has been started, wait until the looper has been created.\n        synchronized (this) {\n            while (isAlive() && mLooper == null) {\n                try {\n                    // 阻塞\n                    wait();\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        return mLooper;\n    }\n\n    /*\n     * 退出 HandlerThread 中的 Looper\n     * 直接退出 Looper，即使 MessageQueue 中还有未处理的消息，所以此种退出方法不安全\n     * 退出后，handler.sendMessage(msg) 将返回 false\n     */\n    public boolean quit() {\n        Looper looper = getLooper();\n        if (looper != null) {\n            looper.quit();\n            return true;\n        }\n        return false;\n    }\n\n    /*\n     * 处理完 MessageQueue 中的所有消息后才退出 Looper，所以此种退出方法比较安全\n     * 退出后，handler.sendMessage(msg) 将返回 false\n     */\n    public boolean quitSafely() {\n        Looper looper = getLooper();\n        if (looper != null) {\n            looper.quitSafely();\n            return true;\n        }\n        return false;\n    }\n\n    /*\n     * 返回线程 ID\n     */\n    public int getThreadId() {\n        return mTid;\n    }\n}\n```\n\n学习完了 HandlerThread，那么思考个问题，一个 Looper 可以对应多个 Handler 吗？具体答案见 [说说 Looper#getMainLooper](http://icodeyou.com/2015/10/11/2015-10-11-getMainLooper/)。\n\n关于 HandlerThread 的具体应用，请看 [IntentService 源码解析](http://icodeyou.com/2015/10/11/2015-10-11-IntentService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/)。\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-10-11-HandlerThread源码解析","published":1,"updated":"2015-12-20T09:08:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yny9000zek5xdycaklnj"},{"title":"Java 笔试题随记","date":"2015-10-09T14:18:44.000Z","_content":"\n在牛客网上刷题，记录一些错题。\n\n<!--more-->\n\n- 没有 <<<= 运算符\n\n- 执行顺序：静态代码块 > 构造代码块 > 构造函数\n\n- 静态变量和静态代码块的执行顺序就是代码前后的顺序\n\n- 执行顺序\n   父类静态块\n   自身静态块\n   父类块\n   父类构造器\n   自身块\n   自身构造器 \n\n- 程序的赋值步骤为\n\t父类的静态变量赋值\n\t自身的静态变量赋值\n\t父类成员变量赋值\n\t父类块赋值\n\t父类构造器赋值\n\t自身成员变量赋值\n\t自身块赋值\n\t自身构造器赋值\n\n- 子类构造函数若没有显示调用 super() 构造函数的话，会被默认插入\n\n- ResultSet中记录行的第一列索引为 1\n\n- 枚举类 所有的枚举值都是类静态常量，在初始化时会对所有的枚举值对象进行第一次初始化\n\n- 线程安全的类：Vector、HashTable、StringBuffer、Properties\n\n- final 只是指向不变，但是指向的值有可能变，所以依然不是线程安全\n\n- 对 volatile 变量的操作不是原子性的\n\n- 只有同一个类加载器加载的相同类名的才是一个class\n\n- Integer 作为参数传递的时候会拆箱，变成值传递\n\n- Java数据库连接库JDBC用到 桥接模式，JDBC提供两套接口，一个面向数据库厂商，一个面向JDBC使用者。\n\n- Xmx：最大堆大小   Xms：初始堆大小   Xmn:年轻代大小   XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值\n\n- 继承具有传递性\n\n- (TestClass)null == TestClass\n\n- 类B从类A派生，则类B可以访问类A中的 public、protected 成员\n\n- 局部变量必须显示初始化\n\n- Java实现了真数组，避免了覆盖数据的可能\n\n- 方法区在JVM中也是一个非常重要的区域，它与堆一样，是被 线程共享 的区域。 在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。\n\n- 硬链接就是同一个文件使用了多个别名。若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软链接\n\n- Stack继承了Vector,所以也是线程安全的\n\n- HashMap 把 Hashtable 的 contains 方法去掉了，因为 contains 方法容易让人产生误解\n\n- 持久带中主要存放用于存放静态类型数据，如 Java Class, Method 等， 与垃圾收集器要收集的Java对象关系不大。而heapspace分为年轻带和年老带。年轻代的垃圾回收叫 Young GC， 年老代的垃圾回收叫 Full GC。\n\n- 持久堆内存，即为存放字节码文件对象的地方，因为平时每个.class文件的对象都只有一份，此对象的唯一性由全限定类名和类加载器共同决定，正常编程时不会溢出，只有修改类加载器，生成大量的字节码文件对象，才会溢出。\n\n- JVM堆内存分为2块：Permanent Space 和 Heap Space。\nPermanent 即 持久代（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。\nHeap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。\n\n- Java 运行时内存划分与线程可见性\n线程共享：方法区，堆区\n线程私有：虚拟机栈，本地方法栈，程序计数器\n\n- [Java 堆内存设置原理](http://blog.csdn.net/sivyer123/article/details/17139443)\n\n- java语言中的方法属于对象的成员,而不是类的成员\n\n- 子类重写方法时，不能降低从基类继承的方法的可见性\n\n- final类型的变量一定要初始化，因为final的变量不可更改\n\n- %和*是同一个优先级，从左到右运算\n\n- protected可以给同一包中其他类访问，但是也可以给不在同一包的子类访问。\n\n- ReadWriteLock适用于读多写少的并发场景\n\n- CopyOnWriteArrayList适用于写少读多的并发场景\n\n- 抽象类可以有构造方法，接口不能有构造方法\n\n- 当所有必要的类都已经装载结束，开始执行main()方法体\n\n- 存在使i + 1 < i的数，如果 i 为 int 型，那么当 i 为 int 能表示的最大整数时，i+1 就溢出变成负数了\n\n- px = dp*（dpi/160）\n\n- Object 的公有方法有：equals() hashcode() toString() getClass() notify() notifyAll() wait()\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-10-09- Java笔试题随记.markdown","raw":"title: Java 笔试题随记\ndate: 2015-10-09 22:18:44\ntags: Java\n----\n\n在牛客网上刷题，记录一些错题。\n\n<!--more-->\n\n- 没有 <<<= 运算符\n\n- 执行顺序：静态代码块 > 构造代码块 > 构造函数\n\n- 静态变量和静态代码块的执行顺序就是代码前后的顺序\n\n- 执行顺序\n   父类静态块\n   自身静态块\n   父类块\n   父类构造器\n   自身块\n   自身构造器 \n\n- 程序的赋值步骤为\n\t父类的静态变量赋值\n\t自身的静态变量赋值\n\t父类成员变量赋值\n\t父类块赋值\n\t父类构造器赋值\n\t自身成员变量赋值\n\t自身块赋值\n\t自身构造器赋值\n\n- 子类构造函数若没有显示调用 super() 构造函数的话，会被默认插入\n\n- ResultSet中记录行的第一列索引为 1\n\n- 枚举类 所有的枚举值都是类静态常量，在初始化时会对所有的枚举值对象进行第一次初始化\n\n- 线程安全的类：Vector、HashTable、StringBuffer、Properties\n\n- final 只是指向不变，但是指向的值有可能变，所以依然不是线程安全\n\n- 对 volatile 变量的操作不是原子性的\n\n- 只有同一个类加载器加载的相同类名的才是一个class\n\n- Integer 作为参数传递的时候会拆箱，变成值传递\n\n- Java数据库连接库JDBC用到 桥接模式，JDBC提供两套接口，一个面向数据库厂商，一个面向JDBC使用者。\n\n- Xmx：最大堆大小   Xms：初始堆大小   Xmn:年轻代大小   XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值\n\n- 继承具有传递性\n\n- (TestClass)null == TestClass\n\n- 类B从类A派生，则类B可以访问类A中的 public、protected 成员\n\n- 局部变量必须显示初始化\n\n- Java实现了真数组，避免了覆盖数据的可能\n\n- 方法区在JVM中也是一个非常重要的区域，它与堆一样，是被 线程共享 的区域。 在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。\n\n- 硬链接就是同一个文件使用了多个别名。若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软链接\n\n- Stack继承了Vector,所以也是线程安全的\n\n- HashMap 把 Hashtable 的 contains 方法去掉了，因为 contains 方法容易让人产生误解\n\n- 持久带中主要存放用于存放静态类型数据，如 Java Class, Method 等， 与垃圾收集器要收集的Java对象关系不大。而heapspace分为年轻带和年老带。年轻代的垃圾回收叫 Young GC， 年老代的垃圾回收叫 Full GC。\n\n- 持久堆内存，即为存放字节码文件对象的地方，因为平时每个.class文件的对象都只有一份，此对象的唯一性由全限定类名和类加载器共同决定，正常编程时不会溢出，只有修改类加载器，生成大量的字节码文件对象，才会溢出。\n\n- JVM堆内存分为2块：Permanent Space 和 Heap Space。\nPermanent 即 持久代（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。\nHeap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。\n\n- Java 运行时内存划分与线程可见性\n线程共享：方法区，堆区\n线程私有：虚拟机栈，本地方法栈，程序计数器\n\n- [Java 堆内存设置原理](http://blog.csdn.net/sivyer123/article/details/17139443)\n\n- java语言中的方法属于对象的成员,而不是类的成员\n\n- 子类重写方法时，不能降低从基类继承的方法的可见性\n\n- final类型的变量一定要初始化，因为final的变量不可更改\n\n- %和*是同一个优先级，从左到右运算\n\n- protected可以给同一包中其他类访问，但是也可以给不在同一包的子类访问。\n\n- ReadWriteLock适用于读多写少的并发场景\n\n- CopyOnWriteArrayList适用于写少读多的并发场景\n\n- 抽象类可以有构造方法，接口不能有构造方法\n\n- 当所有必要的类都已经装载结束，开始执行main()方法体\n\n- 存在使i + 1 < i的数，如果 i 为 int 型，那么当 i 为 int 能表示的最大整数时，i+1 就溢出变成负数了\n\n- px = dp*（dpi/160）\n\n- Object 的公有方法有：equals() hashcode() toString() getClass() notify() notifyAll() wait()\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-10-09- Java笔试题随记","published":1,"updated":"2015-10-16T14:00:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynyc0011ek5x4d5e9wu0"},{"title":"自己真正读过的好书","date":"2015-10-08T14:18:44.000Z","_content":"\n网上总是能看到各种推荐的所谓 \"程序员必读\" 书籍，但这些书籍可能连推荐人本身都没有读过或读完——只是推荐的人多了，自然就成了\"好书\"而已。下面所列的每一本书，我自己肯定都是从头到尾读完了的，并且觉得大有裨益。\n\n<!--more-->\n\n先写两个近期看的，以后有时间再慢慢更新。\n\n[《Android 群英传》](http://item.jd.com/11758334.html)\n\n[《Android 开发艺术探索》](http://item.jd.com/11760209.html)\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-10-08- 自己真正读过的好书.markdown","raw":"title: 自己真正读过的好书\ndate: 2015-10-08 22:18:44\ntags: Android\n----\n\n网上总是能看到各种推荐的所谓 \"程序员必读\" 书籍，但这些书籍可能连推荐人本身都没有读过或读完——只是推荐的人多了，自然就成了\"好书\"而已。下面所列的每一本书，我自己肯定都是从头到尾读完了的，并且觉得大有裨益。\n\n<!--more-->\n\n先写两个近期看的，以后有时间再慢慢更新。\n\n[《Android 群英传》](http://item.jd.com/11758334.html)\n\n[《Android 开发艺术探索》](http://item.jd.com/11760209.html)\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-10-08- 自己真正读过的好书","published":1,"updated":"2015-10-11T12:12:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynyf0014ek5xha1crzfr"},{"title":"Android 开发艺术探索读书笔记","date":"2015-10-07T14:18:44.000Z","_content":"\n和《Android 群英传》一样，《Android 开发艺术探索》是一本进阶的书，比群英传还要进阶一些，特来拜读。\n\n<!--more-->\n\n- 不能在 onPause 中做重量级的操作，因为必须 onPause 执行完成以后新启动的 Activity 才能 onResume。其实 onPause 和 onStop 都不能执行耗时的操作，尤其是 onPause，这也意味着，应当尽量在 onStop 中做操作，从而使得新 Activity 尽快显示出来并切换到前台。\n\n- onSaveInstanceState 的调用在 onStop 之前，和 onPause 没有既定的时序关系。当 Activity 被重新创建之后，系统会调用 onRestoreInstanceState，调用时机在 onStart 之后。并且，系统只在 Activity 异常终止的时候才会调用 onSaveInstanceState 和 onRestoreInstanceState 来存储和恢复数据，其它情况不会触发这个过程，但是按Home键或者启动新Activity仍然会单独触发onSaveInstanceState的调用。\n\n- 既然在 onCreate 和 onSaveInstanceState 中都能够恢复数据，那么二者有什么区别呢？区别在于 onSaveInstanceState 一旦被调用，其参数 Bundle savedInstanceState 一定是有值的；而 onCreate 中必须先进行判空处理。另外，官方文档建议是采用 onRestoreInstanceState 去恢复数据。\n\n- 在 XML 中指定 android:configChanges = \"orientation | screenSize\"(API>13)，可防止屏幕旋转时 Activity 重建，另外会调用 onConfigurationChanged 方法。\n\n- 为 Activity 指定启动模式有两种方式：静态 XML 中指定 launchMode 和 Intent 中动态指定 FLAG。区别在于，其一，动态优先级高于静态；其二，静态方式无法直接为 Activity 设定 FLAG_ACTIVITY_CLEAR_TOP 标识，动态方式无法为 Activity 设定 singleInstance 模式。\n\n- 以 singleTask 启动时，onPause -> onNewIntent -> onResume\n\n- adb shell dumpsys activity\n\n- IntentFilter 中过滤的信息有 action、category、data。只有一个 Intent 同时匹配 action+category+data 才算完全匹配。另外，一个 Activity 中可以有多个 IntentFilter，只要能匹配其中任何一组 IntentFilter 即可成功启动对应的 Activity。\n\n- action 的匹配要求 Intent 中的 action 存在且必须和过滤规则中的其中一个 action 相同。\n\n- action 要求 Intent 中必须有一个 action 且必须能够和过滤规则中的某个 action 相同，而 category 要求 Intent 可以没有 category，但是如果你一旦有 category，不管有几个，每个都要能够和过滤规则中的任何一个 category 相同。\n\n- 为了 Activity 能够接收隐式调用，就必须在 intent-filter 中指定 \"android.intent.category.DEFAULT\" 这个 category，原因是系统在调用 startActivity 或者 startActivityForResult 的时候会默认为 Intent 加上 \"android.intent.category.DEFAULT\" 这个 category。\n\n- 当通过隐式方式启动一个 Activity 的时候，可以做一下判断，看是否有 Activity 能够匹配我们的隐式 Intent，避免抛出找不到满足条件 Activity 的异常。判断方式有两种：采用 PackageManager 的 resolveActivity 方法或者 Intent 的 resolveActivity 方法，如果找不到就会返回 null。另外，PackageManager 还提供了 queryIntentActivities 方法，可以返回所有成功匹配的 Activities 信息而不是最佳匹配的。注意 MATCH_DEFAULT_ONLY 这个标志位，可以匹配那些在 intent-filter 中声明了 category.DEFAULT 的 Activity。使用这个标志位的意义在于，如果上述两个方法不返回 null，那么 startActivity 一定可以成功。\n\n- Parcelable：内存序列化        Serializable：持久化到设备或网络传输\n\n- 反序列化得到的对象只是在内容上和序列化之前的对象相同，但它们本质上还是两个对象，所以它叫做\"对象序列化\"。\n\n- 系统提供了许多实现了 Parcelable 接口的类，它们都是可以直接序列化的，如 Intent、Bundle、Bitmap等，同时 List 和 Map 也可以序列化，前提是它们里面的每个元素都是可序列化的。\n\n- Binder 主要用在 Service 中，包括 AIDL 和 Messenger（Messenger 的底层是 AIDL）\n\n- Bundle 实现了 Parcelable 接口，所以它可以很方便的在不同的进程间传输。当然，我们传输的数据必须能够被序列化，比如基本类型、实现了 Parcelable 接口的对象、实现了 Serialization 接口的对象以及一些 Android 支持的特殊对象。\n\n- 对于 SharedPreferences，系统对它的读/写都有一定的缓存策略，即在内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，系统对它的读/写就变得不可靠，当面对高并发的读/写访问，SharedPreferences 有很大几率会丢失数据，因此，不建议在进程通信中使用 SharedPreferences。\n\n- Messenger 可以在不同进程中传递 Message 对象，是一种轻量级的 IPC 方案，底层实现是 AIDL。只能传递消息，不能跨进程调用服务端的方法。同时，由于它一次只处理一个请求，串行执行，因此在服务端不用考虑线程同步的问题。\n\n- Message 中所支持的传输类型就是 Messenger 中所支持的传输类型。实际上，通过 Messenger 来传输 Message，Message 中能使用的载体只有 what，arg1，arg2，Bundle 以及 replyTo。至于另一个字段 object，其在同一个进程中是很实用的，但是在进程间通信的时候，在 Android 2.2 之前 object 字段不支持跨进程传输，即便是在 2.2 之后，也仅仅是系统提供的实现了 Parcelable 接口的对象才能通过它来传输，这就意味着我们自定义的 Parcelable 对象无法通过 object 字段来传输。所幸我们还有 Bundle，它可以支持大量的数据类型。\n\n- 当有大量的并发请求或跨进程调用服务端的方法时，要使用 AIDL 而不是 Messenger（Messenger 底层也是 AIDL）。\n\n- AIDL 支持的数据类型：基本数据类型、String 和 CharSequence、List（只支持 ArrayList，里面每个元素都必须能够被 AIDL 支持）、Map（只支持 HashMap，里面的每个元素都必须能够被 AIDL 支持，包括 key 和 value）、所有实现了 Parcelable 接口的对象、AIDL 接口本身。其中，自定义的 Parcelable 对象和 AIDL 对象必须要显示 import 进来。\n\n- AIDL 中除了基本类型，其它类型的参数必须标上方向：in、out、inout。\n\n- AIDL 接口中只支持方法，不支持声明静态常量，这一点区别于传统的接口。 AIDL 中无法使用普通接口，如果使用接口只能是 AIDL 接口。\n\n- CopyOnWriteArrayList（不是继承自 ArrayList） 和 ConcurrentHashMap 支持并发读/写。\n\n- RemoteCallbackList 是系统专门提供的用于删除跨进程 listener 的接口。虽然多次跨进程传输客户端的同一个对象会在服务端生成不同的对象，但是这些新生成的对象有一个共同点，那就是它们底层的 Binder 对象是同一个。同时 RemoveCallbackList 还有一个很有用的功能，那就是当客户端进程终止之后，它能够自动移除客户端所注册的 listener。另外，RemoteCallbackList 内部自动实现了线程同步的功能，所以我们使用它来注册和解注册时，不需要做额外的线程同步工作。\n\n- RemoteCallbackList 有一点需要注意，我们无法像操作 List 一样去操作它，因为它并不是一个 List。其中 beginBroadcast 和 finishBroadcast 必须要配对使用，哪怕仅仅是获取 RemoteCallbackList 中元素的个数。\n\n- 和 Messenger 一样，ContentProvider 的底层实现同样也是 Binder。根据 Binder 的工作原理，onCreate、query、update、insert、delete、getType 均运行在 ContentProvider 的进程中，除了 onCreate 由系统回调并运行在主线程里，其它五个方法均由外界回调并运行在 Binder 线程池中。\n\n- android:authorities 是 ContentProvider 的唯一标识，所以也必须唯一\n\n- IPC 方式的优缺点和适用场景\n\n| 名 称 | 优 点 | 缺 点 | 适 用 场 景 |\n|:-----:|:----:|:---:|:----:|\n| Bundle | 简单易用 | 只能传输 Bundle 支持的数据类型 | 四大组件间的进程通信 |\n| 文件共享 | 简单易用 | 不适合高并发场景，并且无法做到进程间的即时通信 | 无并发访问情形、交换简单的数据实时性不高的场景 |\n| AIDL | 功能强大，支持一对多并发通信，支持实时通信 | 使用稍复杂，需要处理好线程同步 | 一对多通信且有 RPC 需求 |\n| Messenger | 功能一般，支持一对多串行通信，支持实时通信 | 不能很好处理高并发情形，不支持 RPC，数据通过 Message 进行传输，因此只能传输 Bundle 支持的数据类型 | 低并发的一对多即时通信，无 RPC 需求，或者无须要返回结果的 RPC 需求 |\n| ContentProvider | 在数据源访问方面功能强大，支持一对多并发数据共享，可通过 Call 方法扩展其它操作 | 可以理解为受约束的 AIDL，主要提供数据源的 CRUD 操作 | 一对多的进程间的数据共享 |\n| Socket | 功能强大，可以通过网络传输字节流，支持一对多并发实时通信 | 实现细节稍微有点麻烦，不支持直接的 RPC | 网络数据交换 |\n\n- x、y、translationX、translationY 是 Android 3.0 后增加的额外参数，translationX 和 translationY 默认是 0.\n\n- x = left + translationX  and  y = top + translatinY。需要注意的是，View 在平移的过程中，top 和 left 表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是 x、y、translationX、translationY 这四个参数。\n\n- touchSlop 是系统所能识别的被认为是滑动的最小距离，如果两次滑动之间的距离小于这个常量，那么系统就不认为你是在进行滑动操作。这是一个常量，和设备有关，有的是 8dp。\n\n- View 的滑动方式有三种：\n（1）scrollTo/scrollBy，只能将 View 的内容进行移动，并不能将 View 本身进行移动，也就是说，不管怎么滑动，也不可能将当前 View 滑动到附近 View 所在的区域。\n\tmScrollX = View 左边缘 - View 内容左边缘\n\tmScrollY = View 上边缘 - View 内容上边缘\n（2）View 动画是对 View 的影像做操作，它并不能改变 View 的位置参数，包括宽/高，并且如果希望动画后的状态得以保留还必须将 fillAfter 设置为 true。属性动画并不会存在上述问题，Android 3.0 以下通过 nineoldandroids 来实现的属性动画本质上仍然是 View 动画。\n（3）改变布局参数实现 View 滑动\n\n- View 滑动三种方式对比\n（1）scrollTo/scrollBy：适合对 View 内容的滑动\n（2）动画：主要适用于没有交互的 View 和实现复杂的动画效果\n（3）改变布局参数：适用于有交互的 View\n\n- Scroller 的使用\n```\n    Scroller mScroller = new Scroller(mContext);\n\n    // 缓慢滚动到指定位置\n    private void smoothScrollTo(int destX, int destY) {\n        int scrollX = getScrollX();\n        int deltaX = destX - scrollX;\n        // 1000ms 横坐标从 scrollX 滑动到 scrollX + deltaX，效果就是慢慢移动\n        mScroller.startScroll(scrollX, 0, deltaX, 0, 1000);\n        invalidate(); // 触发 View 的第一次重绘\n    }\n\n    // View 的每次重绘都会调用这个方法\n    @Override\n    public void computeScroll() {\n        // true 代表动画还没结束\n        if (mScroller.computeScrollOffset()) { // 此方法会根据时间的流逝来计算当前的 scrollX 和 scrollY 的值\n            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n            postInvalidate();\n        }\n    }\n```\n\n\nScroll 的滑动是指 View 内容的滑动而非 View 本身位置的改变。整个过程中它对 View 没有丝毫的引用，甚至在它内部连计时器都没有。\n\n- 当 ViewPager 和 Fragment 配合使用所组成的页面滑动效果，ViewPager 内部又有一个 ListView，本来这种情况下是有滑动冲突的，但是 ViewPager 内部处理了这种滑动冲突。但如果采用的是 ScrollView，那就必须手动处理滑动冲突了。\n\n- dispatchTouchEvent(MotionEvent ev) 处理模型:\n\n\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        boolean consume = false;\n\n        if ( onInterceptTouchEvent(ev) ) {\n            consume = onTouchEvent(ev);\n            consume = true;\n        } else {\n            consume = child.dispatchTouchEvent(ev);\n        }\n\n        return consume;\n    }\n\n\n- TimeInterpolator 为时间插值器，作用是根据时间流逝的百分比来计算出当前属性值改变的百分比，系统预置的有 LinearInterpolator、AccelerateDecelerateInterpolator、DecelerateInterpolator。\n\n- TypeEvaluator 为类型估值算法，也叫做估值器，作用是根据当前属性改变的百分比来计算改变后的属性值。\n\n- Measure：getMeasuredHeight、getMeasuredWidth  Layout：getHeight、getWidth、四个顶点的坐标\n\n- measure 是测量的意思，那么 onMeasure() 方法顾名思义就是用于测量视图的大小的。View 系统的绘制流程会从 ViewRoot 的 performTraversals() 方法中开始，在其内部调用 View 的measure() 方法。measure() 方法接收两个参数，widthMeasureSpec 和 heightMeasureSpec，这两个值分别用于确定视图的宽度和高度的规格和大小。\n\n- 对于普通 View，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定。\n\n- 在 TextView、ImageView 等源码中可以发现，针对 wrap_content 情形，它们的 onMeasure 方法均做了特殊处理。\n\n- 在 onCreate、onStart、onResume 中均无法正确得到某个 View 的宽高信息，这是因为 View 的 measure 过程和 Activity 的生命周期方法不是同步执行的，因此无法保证 Activity 执行了 onCreate、onStart、onResume 时某个 View 已经测量完毕了，如果 View 还没有测量完毕，那么获得的宽高就是0。\n\n- 需要注意的是，在 onMeasure()#setMeasuredDimension()方法调用之后，我们才能使用 getMeasuredWidth() 和 getMeasuredHeight() 来获取视图测量出的宽高，以此之前调用这两个方法得到的值都会是0。\n\n- 视图大小的控制是由父视图、布局文件、以及视图本身共同完成的，父视图会提供给子视图参考的大小，而开发人员可以在XML文件中指定视图的大小，然后视图本身会对最终的大小进行拍板。\n\n- Layout 的作用是 ViewGroup 用来确定子元素的位置，当 ViewGroup 的位置被确定后，它在 onLayout 中会遍历所有的子元素并调用其 layout 方法，在 layout 方法中 onLayout 方法又会被调用。Layout 方法确定 View 本身的位置，而 onLayout 方法则会确定所有子元素的位置。\n\n- View 中的 onLayout() 方法就是一个空方法，因为 onLayout() 过程是为了确定视图在布局中所在的位置，而这个操作应该是由布局来完成的，即父视图决定子视图的显示位置。而 ViewGroup 中 的onLayout() 方法是一个抽象方法，这就意味着所有 ViewGroup 的子类都必须重写这个方法。没错，像 LinearLayout、RelativeLayout 等布局，都是重写了这个方法，然后在内部按照各自的规则对子视图进行布局的。\n\n\n- Draw 过程的作用是将 View 绘制到屏幕上，过程遵循如下几步：\n（1）绘制背景 background.draw(canvas)\n（2）绘制自己 onDraw\n（3）绘制 children dispatchDraw\n（4）绘制装饰 onDrawScrollBars\n\n- 自定义 View 需要注意的问题：\n（1）对于直接继承自 View 的控件，如果不对 wrap_content 做特殊处理，那么使用 wrap_content 就相当于 match_parent\n（2）对于直接继承自 View 和 ViewGroup 的控件，padding 默认是无法生效的，需要自己在 onDraw 中处理\n\n- 如果一个 View 不需要绘制任何内容，可以设置 setWillNotDraw(true)，系统会进行相应优化。默认情况下，View 没有启用这个标记位，而 ViewGroup 会默认启用这个标志位。对应实际开发意义是：当我们的自定义控件继承于 ViewGroup 并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。当然，当明确知道一个 ViewGroup 需要通过 onDraw 来绘制内容时，我们需要显示地关闭 WILL_NOT_DRAW 这个标记位。\n\n- ThreadLocal 可以在不同的线程中互不干扰地存储并提供数据，并通过 ThreadLocal 可以轻松获取每个线程的 Looper\n\n- ThreadLocal 的效果是因为不同线程访问同一个 ThreadLocal 的 get() 方法，ThreadLocal 内部会从各自的线程中取出一个数组(ThreadLocal.Value)，然后再从数组中根据当前 ThreadLocal 的索引去查找出对应的 value 值。很显然，不容线程中的数组是不同的，这就是为什么通过 ThreadLocal 可以在不同的线程中维护一套数据的副本并且彼此互不干扰。\n\n- 非主线程不能更新 UI 是因为 ViewRootImpl 对 UI 操作进行了验证，由 checkThread() 来完成：\n\n\n    void checkThread() {\n    \tif ( mThread != Thread.currentThread ) {\n    \t\tthrow new CalledFromWrongThreadException(\"Only the original thread that created a view hierarchy can touch its view.\");\n    \t}\n    }\n\n\n- 非主线程不能更新 UI 是因为 UI 控件不是线程安全的，多线程中并发访问会导致 UI 控件处于不可预期的状态\n\n- MessageQueue 内部实现是单链表，而不是队列。在其 next() 方法中有一变量 nextPollTimeoutMillis 设置没有消息时等待下一次取消息的时延（书中没讲，这是我猜的）\n\n- pollOnce 和 wake 最终都是通过 Linux 的 epoll 模型来实现的。pollOnce() 通过等待被激活，然后从消息队列中获取消息；wake() 则是激活处于等待状态的消息队列，通知它有消息到达了。这是典型的生产者-消费者模型。\n\n- 由于主线程的 Looper 比较特殊，所以 Looper 提供了一个 getMainLooper() 方法，通过它可以在任何地方获取到主线程的 Looper。\n\n- Looper 也是可以退出的，quit() 会直接退出 Looper，而 quitSafely() 只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全退出。Looper 退出后，通过 Handler 发送的消息会失败，这个时候 Handler 的 send() 方法会返回 false。在子线程中，如果手动为其创建了 Looper，那么在所有的事情完成以后应该调用 quit 方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出 Looper 以后，这个线程就会立刻终止，因此建议不需要的时候终止 Looper。\n\n- Activity 的主线程就是 ActivityThread。ActivityThread 通过 ApplicationThread 和 AMS 进行进程间通信，AMS 以进程间通信的方式完成 ActivityThread 的请求后回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 会向 H 发送消息，H 收到消息后会将 ApplicationThread 中的逻辑切换到 ActivityThread 中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。（H 是主线程中的 Handler）\n\n- 对于 AsyncTask 来说，它的底层使用了线程池，对于 IntentService 和 HandlerThread 来说，它的底层则直接使用了线程。\n\n- AsyncTask 封装了 Thread 和 Handler，但是 AsyncTask 并不适合进行特别耗时的后台任务，对于特别耗时的任务来说，建议采用线程池。\n\n- AsyncTask 注意事项：\n（1）AsyncTask 的类必须在主线程中加载，这就意味着第一次访问 AsyncTask 必须发生在主线程，当然这个过程在 Android 4.1 及以上版本已经被系统自动完成。（static final InternalHandler sHandler 是静态成员由于静态成员会在加载类的时候进行初始化，因此这就变相要求 AsyncTask 的类必须在主线程中加载）\n（2）AsyncTask 的对象必须在主线程中创建\n（3）execute() 方法必须在 UI 线程中调用\n（4）不要再程序中直接调用 onPreExecute()、onPostExecute()、doInBackground() 和 onProgressUpdate() 方法\n（5）一个 AsyncTask 对象只能执行一次，即只能调用一次 execute 方法，否则会报运行时异常\n（6）Android 1.6 之前，串行执行；Android 3.0 之前，并行执行；3.0 之后，串行执行，但可以通过 AsyncTask 的 executeOnExecutor() 方法来并行执行任务\n\n- AsyncTask 中的 InternalHandler 用于将执行环境从线程池切换到主线程\n\n- IntentService 的优点：子线程中执行，可以自动结束，不容易被系统杀死(普通线程脱离四大组件后优先级非常低)\n\n- HandlerThread 继承自 Thread，是一种可以使用 Handler 的 Thread，内部创建了消息队列。外界需要通过 Handler 的消息方式来通知 HandlerThread 执行一个具体的任务。具体使用场景是 IntentService。由于 HandlerThread 的 run 方法是一个无限循环，因此当明确不需要再使用 HandlerThread 时，可以通过它的 quit 或 quitSafely 方法来终止线程的执行。\n\n- IntentService 第一次被启动时，onCreate 方法会被调用，其中会创建一个 HandlerThread，然后使用它的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最终都会在 HandlerThread 中执行。\n\n- 另外，由于每执行一个后台任务就必须启动一次 IntentService，而 IntentService 内部则通过消息的方式向 HandlerThread 请求执行任务，Handler 中的 Looper 是顺序处理消息的，这就意味着 IntentService 也是顺序执行后台任务的，当有多个后台任务同时存在时，这些后台任务会按照外界发起的顺序排队执行。\n\n- ThreadPoolExecutor 是线程池的真正实现，下面是其一个比较常用的构造方法：\n\n```\n    public ThreadPoolExecutor ( \n    \tint corePollSize, // 核心线程，默认会一直存活即使闲置。非默认是指将 allowCoreThreadTimeOut = true，则超过 keepAliveTime 后核心线程就会被终止\n    \tint maximumPoolSize, // 所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞\n    \tlong keepAliveTime, // 非核心线程闲置的超时时长\n    \tTimeUnit unit, // 枚举常量\n    \tBlockingQueue<Runnable> workQueue, // 任务队列，通过 execute 方法提交的 Runnable 对象会存储在这个参数中\n    \tThreadFactory threadFactory ) // 为线程池提供创建新线程的机会，ThreadFactory 是一个接口，只有一个方法：Thread newThread(Runnable r)\n```\n\n- ThreadPoolExecutor 执行任务时的规则：\n（1）如果线程池中的线程数量未达到核心线程数量，那么会直接启动一个核心线程来执行任务\n（2）如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到 workQueue 中排队等待执行\n（3）如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务\n（4）如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor 会调用 RejectedExecutionHandler 的 rejectExecution 方法来通知调用者\n\n- 四种线程池：\n（1）newFixedThreadPool 只有核心线程并且这些核心线程没有超时限制，另外任务队列也是没有大小限制的。\n（2）newCachedThreadPool 只有非核心线程，并且其最大值为 Integer.MAX_VALUE，60秒超时限制，它的 SynchronousQueue 无法插入任务\n（3）newScheduledThreadPool 核心线程数由参数指定，非核心线程数无限制，非核心闲置时立即被回收\n（4）newSingleThreadExecutor 只有一个核心线程，确保所有的任务都在同一个线程中按顺序执行，不需要处理线程同步的问题，无超时限制\n\n- inSampleSize 的取值应该总是2的指数，如果外界传递给系统的 inSampleSize 不为2的指数，那么系统会向下取整并选择一个最接近2的指数来代替，但是这个结论并非在所有的 Android 版本上都成立，因此把它当成一个开发者建议即可。\n\n- 为 Activity 开启硬件加速，android:hardwareAccelerated = \"true\"。\n\n- 通过 UncaughtExceptionHandler 来监视应用的 crash 信息，当程序 crash 时就会调用 uncaughtException 方法。它只能收到那些未捕获的异常，被 catch 的异常不会交给 UncaughtExceptionHandler 处理。\n\n- 单个 dex 文件所能够包含的最大方法数为 65536，这包含 Android FrameWork、以来的 jar 包以及应用本身的代码中的所有方法。\n\n- 解决方法数越界的方式：\n（1）删除无用代码和第三方库\n（2）插件化机制动态加载部分 dex， 通过将一个 dex 拆分成两个或多个 dex。但是偏重量级了，而且兼容性问题往往较多\n（3）Google 2014 年提出 multidex 解决方案，很好解决，使用很简单\n\n- 使用 multidex，Android 5.0 以前需要引入 android-support-multidex.jar，5.0 以后默认支持了 multidex。\n\n- multidex 局限性：\n（1）启动速度降低，因为要额外加载 dex 文件，甚至可能出现 ANR，尤其是其它 dex 文件较大的时候，因此要避免生成较大的 dex 文件\n（2）由于 Dalvik LinearAlloc 的 bug，这可能导致使用 multidex 的应用无法在 Android 4.0 以前的手机上运行，此种情况目前还极少遇到\n\n- 插件化三个基础性问题：资源访问、Activity 生命周期管理、ClassLoader 的管理\n（1）资源访问：插件中凡是以 R 开头的资源都不能访问了，解决方法为以反射的机制调用 AssetManager 的 addAssetPath 隐藏方法，将 apk 路径传递给它，将资源加载到 AssetManager 中；然后再通过 AssetManager 来创建一个新的 Resource 对象，通过这个对象就可以访问插件 apk 中的资源了；接着在代理 Activity 中实现 getAssets() 和 getResource() 方法\n（2）Activity 生命周期管理：使用反射，但是效率低且编写麻烦；最好使用接口回调，将 Activity 的生命周期方法都写到 IDLPlugin 接口中，在代理 Activity 中只需要在相应生命周期方法中调用插件 Activity 的生命周期方法即可\n（3）插件 ClassLoader 的管理：需要合理管理各个插件的 DexClassLoader，这样同一个插件就可以采用同一个 ClassLoader 去加载类，从而避免了多个 ClassLoader 加载同一个类时所引发的类型转换错误，可以将不同插件的 ClassLoader 存储在一个 HashMap 中，这样就可以保证不同插件中的类彼此互不干扰\n\n- 当一个进程发生 ANR 了以后，系统会在 /data/anr 目录下创建一个文件 traces.txt，通过分析这个文件就能定位出 ANR 的原因。 adb pull /data/anr/traces.txt。\n\n- float x 与“零值”比较的if语句为 if (fabs(x) < 0.00001f)\n\n- 带小数的默认为 double\n\n- 进入”Dead”状态的线程还可以恢复，不一定被回收\n\n- final类型的变量一定要初始化，因为final的变量不可更改\n\n- byte和short型在计算时会自动转换为int型计算\n\n- $Usdollars 是合法标识符\n\n- throws 关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过 throw 抛出异常对象\n\n- 在 JVM 中是使用监视器锁来实现不同线程的异步执行，在语法的表现就是synchronized\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-10-07- Android开发艺术探索.markdown","raw":"title: Android 开发艺术探索读书笔记\ndate: 2015-10-07 22:18:44\ntags: Android\n----\n\n和《Android 群英传》一样，《Android 开发艺术探索》是一本进阶的书，比群英传还要进阶一些，特来拜读。\n\n<!--more-->\n\n- 不能在 onPause 中做重量级的操作，因为必须 onPause 执行完成以后新启动的 Activity 才能 onResume。其实 onPause 和 onStop 都不能执行耗时的操作，尤其是 onPause，这也意味着，应当尽量在 onStop 中做操作，从而使得新 Activity 尽快显示出来并切换到前台。\n\n- onSaveInstanceState 的调用在 onStop 之前，和 onPause 没有既定的时序关系。当 Activity 被重新创建之后，系统会调用 onRestoreInstanceState，调用时机在 onStart 之后。并且，系统只在 Activity 异常终止的时候才会调用 onSaveInstanceState 和 onRestoreInstanceState 来存储和恢复数据，其它情况不会触发这个过程，但是按Home键或者启动新Activity仍然会单独触发onSaveInstanceState的调用。\n\n- 既然在 onCreate 和 onSaveInstanceState 中都能够恢复数据，那么二者有什么区别呢？区别在于 onSaveInstanceState 一旦被调用，其参数 Bundle savedInstanceState 一定是有值的；而 onCreate 中必须先进行判空处理。另外，官方文档建议是采用 onRestoreInstanceState 去恢复数据。\n\n- 在 XML 中指定 android:configChanges = \"orientation | screenSize\"(API>13)，可防止屏幕旋转时 Activity 重建，另外会调用 onConfigurationChanged 方法。\n\n- 为 Activity 指定启动模式有两种方式：静态 XML 中指定 launchMode 和 Intent 中动态指定 FLAG。区别在于，其一，动态优先级高于静态；其二，静态方式无法直接为 Activity 设定 FLAG_ACTIVITY_CLEAR_TOP 标识，动态方式无法为 Activity 设定 singleInstance 模式。\n\n- 以 singleTask 启动时，onPause -> onNewIntent -> onResume\n\n- adb shell dumpsys activity\n\n- IntentFilter 中过滤的信息有 action、category、data。只有一个 Intent 同时匹配 action+category+data 才算完全匹配。另外，一个 Activity 中可以有多个 IntentFilter，只要能匹配其中任何一组 IntentFilter 即可成功启动对应的 Activity。\n\n- action 的匹配要求 Intent 中的 action 存在且必须和过滤规则中的其中一个 action 相同。\n\n- action 要求 Intent 中必须有一个 action 且必须能够和过滤规则中的某个 action 相同，而 category 要求 Intent 可以没有 category，但是如果你一旦有 category，不管有几个，每个都要能够和过滤规则中的任何一个 category 相同。\n\n- 为了 Activity 能够接收隐式调用，就必须在 intent-filter 中指定 \"android.intent.category.DEFAULT\" 这个 category，原因是系统在调用 startActivity 或者 startActivityForResult 的时候会默认为 Intent 加上 \"android.intent.category.DEFAULT\" 这个 category。\n\n- 当通过隐式方式启动一个 Activity 的时候，可以做一下判断，看是否有 Activity 能够匹配我们的隐式 Intent，避免抛出找不到满足条件 Activity 的异常。判断方式有两种：采用 PackageManager 的 resolveActivity 方法或者 Intent 的 resolveActivity 方法，如果找不到就会返回 null。另外，PackageManager 还提供了 queryIntentActivities 方法，可以返回所有成功匹配的 Activities 信息而不是最佳匹配的。注意 MATCH_DEFAULT_ONLY 这个标志位，可以匹配那些在 intent-filter 中声明了 category.DEFAULT 的 Activity。使用这个标志位的意义在于，如果上述两个方法不返回 null，那么 startActivity 一定可以成功。\n\n- Parcelable：内存序列化        Serializable：持久化到设备或网络传输\n\n- 反序列化得到的对象只是在内容上和序列化之前的对象相同，但它们本质上还是两个对象，所以它叫做\"对象序列化\"。\n\n- 系统提供了许多实现了 Parcelable 接口的类，它们都是可以直接序列化的，如 Intent、Bundle、Bitmap等，同时 List 和 Map 也可以序列化，前提是它们里面的每个元素都是可序列化的。\n\n- Binder 主要用在 Service 中，包括 AIDL 和 Messenger（Messenger 的底层是 AIDL）\n\n- Bundle 实现了 Parcelable 接口，所以它可以很方便的在不同的进程间传输。当然，我们传输的数据必须能够被序列化，比如基本类型、实现了 Parcelable 接口的对象、实现了 Serialization 接口的对象以及一些 Android 支持的特殊对象。\n\n- 对于 SharedPreferences，系统对它的读/写都有一定的缓存策略，即在内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，系统对它的读/写就变得不可靠，当面对高并发的读/写访问，SharedPreferences 有很大几率会丢失数据，因此，不建议在进程通信中使用 SharedPreferences。\n\n- Messenger 可以在不同进程中传递 Message 对象，是一种轻量级的 IPC 方案，底层实现是 AIDL。只能传递消息，不能跨进程调用服务端的方法。同时，由于它一次只处理一个请求，串行执行，因此在服务端不用考虑线程同步的问题。\n\n- Message 中所支持的传输类型就是 Messenger 中所支持的传输类型。实际上，通过 Messenger 来传输 Message，Message 中能使用的载体只有 what，arg1，arg2，Bundle 以及 replyTo。至于另一个字段 object，其在同一个进程中是很实用的，但是在进程间通信的时候，在 Android 2.2 之前 object 字段不支持跨进程传输，即便是在 2.2 之后，也仅仅是系统提供的实现了 Parcelable 接口的对象才能通过它来传输，这就意味着我们自定义的 Parcelable 对象无法通过 object 字段来传输。所幸我们还有 Bundle，它可以支持大量的数据类型。\n\n- 当有大量的并发请求或跨进程调用服务端的方法时，要使用 AIDL 而不是 Messenger（Messenger 底层也是 AIDL）。\n\n- AIDL 支持的数据类型：基本数据类型、String 和 CharSequence、List（只支持 ArrayList，里面每个元素都必须能够被 AIDL 支持）、Map（只支持 HashMap，里面的每个元素都必须能够被 AIDL 支持，包括 key 和 value）、所有实现了 Parcelable 接口的对象、AIDL 接口本身。其中，自定义的 Parcelable 对象和 AIDL 对象必须要显示 import 进来。\n\n- AIDL 中除了基本类型，其它类型的参数必须标上方向：in、out、inout。\n\n- AIDL 接口中只支持方法，不支持声明静态常量，这一点区别于传统的接口。 AIDL 中无法使用普通接口，如果使用接口只能是 AIDL 接口。\n\n- CopyOnWriteArrayList（不是继承自 ArrayList） 和 ConcurrentHashMap 支持并发读/写。\n\n- RemoteCallbackList 是系统专门提供的用于删除跨进程 listener 的接口。虽然多次跨进程传输客户端的同一个对象会在服务端生成不同的对象，但是这些新生成的对象有一个共同点，那就是它们底层的 Binder 对象是同一个。同时 RemoveCallbackList 还有一个很有用的功能，那就是当客户端进程终止之后，它能够自动移除客户端所注册的 listener。另外，RemoteCallbackList 内部自动实现了线程同步的功能，所以我们使用它来注册和解注册时，不需要做额外的线程同步工作。\n\n- RemoteCallbackList 有一点需要注意，我们无法像操作 List 一样去操作它，因为它并不是一个 List。其中 beginBroadcast 和 finishBroadcast 必须要配对使用，哪怕仅仅是获取 RemoteCallbackList 中元素的个数。\n\n- 和 Messenger 一样，ContentProvider 的底层实现同样也是 Binder。根据 Binder 的工作原理，onCreate、query、update、insert、delete、getType 均运行在 ContentProvider 的进程中，除了 onCreate 由系统回调并运行在主线程里，其它五个方法均由外界回调并运行在 Binder 线程池中。\n\n- android:authorities 是 ContentProvider 的唯一标识，所以也必须唯一\n\n- IPC 方式的优缺点和适用场景\n\n| 名 称 | 优 点 | 缺 点 | 适 用 场 景 |\n|:-----:|:----:|:---:|:----:|\n| Bundle | 简单易用 | 只能传输 Bundle 支持的数据类型 | 四大组件间的进程通信 |\n| 文件共享 | 简单易用 | 不适合高并发场景，并且无法做到进程间的即时通信 | 无并发访问情形、交换简单的数据实时性不高的场景 |\n| AIDL | 功能强大，支持一对多并发通信，支持实时通信 | 使用稍复杂，需要处理好线程同步 | 一对多通信且有 RPC 需求 |\n| Messenger | 功能一般，支持一对多串行通信，支持实时通信 | 不能很好处理高并发情形，不支持 RPC，数据通过 Message 进行传输，因此只能传输 Bundle 支持的数据类型 | 低并发的一对多即时通信，无 RPC 需求，或者无须要返回结果的 RPC 需求 |\n| ContentProvider | 在数据源访问方面功能强大，支持一对多并发数据共享，可通过 Call 方法扩展其它操作 | 可以理解为受约束的 AIDL，主要提供数据源的 CRUD 操作 | 一对多的进程间的数据共享 |\n| Socket | 功能强大，可以通过网络传输字节流，支持一对多并发实时通信 | 实现细节稍微有点麻烦，不支持直接的 RPC | 网络数据交换 |\n\n- x、y、translationX、translationY 是 Android 3.0 后增加的额外参数，translationX 和 translationY 默认是 0.\n\n- x = left + translationX  and  y = top + translatinY。需要注意的是，View 在平移的过程中，top 和 left 表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是 x、y、translationX、translationY 这四个参数。\n\n- touchSlop 是系统所能识别的被认为是滑动的最小距离，如果两次滑动之间的距离小于这个常量，那么系统就不认为你是在进行滑动操作。这是一个常量，和设备有关，有的是 8dp。\n\n- View 的滑动方式有三种：\n（1）scrollTo/scrollBy，只能将 View 的内容进行移动，并不能将 View 本身进行移动，也就是说，不管怎么滑动，也不可能将当前 View 滑动到附近 View 所在的区域。\n\tmScrollX = View 左边缘 - View 内容左边缘\n\tmScrollY = View 上边缘 - View 内容上边缘\n（2）View 动画是对 View 的影像做操作，它并不能改变 View 的位置参数，包括宽/高，并且如果希望动画后的状态得以保留还必须将 fillAfter 设置为 true。属性动画并不会存在上述问题，Android 3.0 以下通过 nineoldandroids 来实现的属性动画本质上仍然是 View 动画。\n（3）改变布局参数实现 View 滑动\n\n- View 滑动三种方式对比\n（1）scrollTo/scrollBy：适合对 View 内容的滑动\n（2）动画：主要适用于没有交互的 View 和实现复杂的动画效果\n（3）改变布局参数：适用于有交互的 View\n\n- Scroller 的使用\n```\n    Scroller mScroller = new Scroller(mContext);\n\n    // 缓慢滚动到指定位置\n    private void smoothScrollTo(int destX, int destY) {\n        int scrollX = getScrollX();\n        int deltaX = destX - scrollX;\n        // 1000ms 横坐标从 scrollX 滑动到 scrollX + deltaX，效果就是慢慢移动\n        mScroller.startScroll(scrollX, 0, deltaX, 0, 1000);\n        invalidate(); // 触发 View 的第一次重绘\n    }\n\n    // View 的每次重绘都会调用这个方法\n    @Override\n    public void computeScroll() {\n        // true 代表动画还没结束\n        if (mScroller.computeScrollOffset()) { // 此方法会根据时间的流逝来计算当前的 scrollX 和 scrollY 的值\n            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n            postInvalidate();\n        }\n    }\n```\n\n\nScroll 的滑动是指 View 内容的滑动而非 View 本身位置的改变。整个过程中它对 View 没有丝毫的引用，甚至在它内部连计时器都没有。\n\n- 当 ViewPager 和 Fragment 配合使用所组成的页面滑动效果，ViewPager 内部又有一个 ListView，本来这种情况下是有滑动冲突的，但是 ViewPager 内部处理了这种滑动冲突。但如果采用的是 ScrollView，那就必须手动处理滑动冲突了。\n\n- dispatchTouchEvent(MotionEvent ev) 处理模型:\n\n\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        boolean consume = false;\n\n        if ( onInterceptTouchEvent(ev) ) {\n            consume = onTouchEvent(ev);\n            consume = true;\n        } else {\n            consume = child.dispatchTouchEvent(ev);\n        }\n\n        return consume;\n    }\n\n\n- TimeInterpolator 为时间插值器，作用是根据时间流逝的百分比来计算出当前属性值改变的百分比，系统预置的有 LinearInterpolator、AccelerateDecelerateInterpolator、DecelerateInterpolator。\n\n- TypeEvaluator 为类型估值算法，也叫做估值器，作用是根据当前属性改变的百分比来计算改变后的属性值。\n\n- Measure：getMeasuredHeight、getMeasuredWidth  Layout：getHeight、getWidth、四个顶点的坐标\n\n- measure 是测量的意思，那么 onMeasure() 方法顾名思义就是用于测量视图的大小的。View 系统的绘制流程会从 ViewRoot 的 performTraversals() 方法中开始，在其内部调用 View 的measure() 方法。measure() 方法接收两个参数，widthMeasureSpec 和 heightMeasureSpec，这两个值分别用于确定视图的宽度和高度的规格和大小。\n\n- 对于普通 View，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定。\n\n- 在 TextView、ImageView 等源码中可以发现，针对 wrap_content 情形，它们的 onMeasure 方法均做了特殊处理。\n\n- 在 onCreate、onStart、onResume 中均无法正确得到某个 View 的宽高信息，这是因为 View 的 measure 过程和 Activity 的生命周期方法不是同步执行的，因此无法保证 Activity 执行了 onCreate、onStart、onResume 时某个 View 已经测量完毕了，如果 View 还没有测量完毕，那么获得的宽高就是0。\n\n- 需要注意的是，在 onMeasure()#setMeasuredDimension()方法调用之后，我们才能使用 getMeasuredWidth() 和 getMeasuredHeight() 来获取视图测量出的宽高，以此之前调用这两个方法得到的值都会是0。\n\n- 视图大小的控制是由父视图、布局文件、以及视图本身共同完成的，父视图会提供给子视图参考的大小，而开发人员可以在XML文件中指定视图的大小，然后视图本身会对最终的大小进行拍板。\n\n- Layout 的作用是 ViewGroup 用来确定子元素的位置，当 ViewGroup 的位置被确定后，它在 onLayout 中会遍历所有的子元素并调用其 layout 方法，在 layout 方法中 onLayout 方法又会被调用。Layout 方法确定 View 本身的位置，而 onLayout 方法则会确定所有子元素的位置。\n\n- View 中的 onLayout() 方法就是一个空方法，因为 onLayout() 过程是为了确定视图在布局中所在的位置，而这个操作应该是由布局来完成的，即父视图决定子视图的显示位置。而 ViewGroup 中 的onLayout() 方法是一个抽象方法，这就意味着所有 ViewGroup 的子类都必须重写这个方法。没错，像 LinearLayout、RelativeLayout 等布局，都是重写了这个方法，然后在内部按照各自的规则对子视图进行布局的。\n\n\n- Draw 过程的作用是将 View 绘制到屏幕上，过程遵循如下几步：\n（1）绘制背景 background.draw(canvas)\n（2）绘制自己 onDraw\n（3）绘制 children dispatchDraw\n（4）绘制装饰 onDrawScrollBars\n\n- 自定义 View 需要注意的问题：\n（1）对于直接继承自 View 的控件，如果不对 wrap_content 做特殊处理，那么使用 wrap_content 就相当于 match_parent\n（2）对于直接继承自 View 和 ViewGroup 的控件，padding 默认是无法生效的，需要自己在 onDraw 中处理\n\n- 如果一个 View 不需要绘制任何内容，可以设置 setWillNotDraw(true)，系统会进行相应优化。默认情况下，View 没有启用这个标记位，而 ViewGroup 会默认启用这个标志位。对应实际开发意义是：当我们的自定义控件继承于 ViewGroup 并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。当然，当明确知道一个 ViewGroup 需要通过 onDraw 来绘制内容时，我们需要显示地关闭 WILL_NOT_DRAW 这个标记位。\n\n- ThreadLocal 可以在不同的线程中互不干扰地存储并提供数据，并通过 ThreadLocal 可以轻松获取每个线程的 Looper\n\n- ThreadLocal 的效果是因为不同线程访问同一个 ThreadLocal 的 get() 方法，ThreadLocal 内部会从各自的线程中取出一个数组(ThreadLocal.Value)，然后再从数组中根据当前 ThreadLocal 的索引去查找出对应的 value 值。很显然，不容线程中的数组是不同的，这就是为什么通过 ThreadLocal 可以在不同的线程中维护一套数据的副本并且彼此互不干扰。\n\n- 非主线程不能更新 UI 是因为 ViewRootImpl 对 UI 操作进行了验证，由 checkThread() 来完成：\n\n\n    void checkThread() {\n    \tif ( mThread != Thread.currentThread ) {\n    \t\tthrow new CalledFromWrongThreadException(\"Only the original thread that created a view hierarchy can touch its view.\");\n    \t}\n    }\n\n\n- 非主线程不能更新 UI 是因为 UI 控件不是线程安全的，多线程中并发访问会导致 UI 控件处于不可预期的状态\n\n- MessageQueue 内部实现是单链表，而不是队列。在其 next() 方法中有一变量 nextPollTimeoutMillis 设置没有消息时等待下一次取消息的时延（书中没讲，这是我猜的）\n\n- pollOnce 和 wake 最终都是通过 Linux 的 epoll 模型来实现的。pollOnce() 通过等待被激活，然后从消息队列中获取消息；wake() 则是激活处于等待状态的消息队列，通知它有消息到达了。这是典型的生产者-消费者模型。\n\n- 由于主线程的 Looper 比较特殊，所以 Looper 提供了一个 getMainLooper() 方法，通过它可以在任何地方获取到主线程的 Looper。\n\n- Looper 也是可以退出的，quit() 会直接退出 Looper，而 quitSafely() 只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全退出。Looper 退出后，通过 Handler 发送的消息会失败，这个时候 Handler 的 send() 方法会返回 false。在子线程中，如果手动为其创建了 Looper，那么在所有的事情完成以后应该调用 quit 方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出 Looper 以后，这个线程就会立刻终止，因此建议不需要的时候终止 Looper。\n\n- Activity 的主线程就是 ActivityThread。ActivityThread 通过 ApplicationThread 和 AMS 进行进程间通信，AMS 以进程间通信的方式完成 ActivityThread 的请求后回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 会向 H 发送消息，H 收到消息后会将 ApplicationThread 中的逻辑切换到 ActivityThread 中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。（H 是主线程中的 Handler）\n\n- 对于 AsyncTask 来说，它的底层使用了线程池，对于 IntentService 和 HandlerThread 来说，它的底层则直接使用了线程。\n\n- AsyncTask 封装了 Thread 和 Handler，但是 AsyncTask 并不适合进行特别耗时的后台任务，对于特别耗时的任务来说，建议采用线程池。\n\n- AsyncTask 注意事项：\n（1）AsyncTask 的类必须在主线程中加载，这就意味着第一次访问 AsyncTask 必须发生在主线程，当然这个过程在 Android 4.1 及以上版本已经被系统自动完成。（static final InternalHandler sHandler 是静态成员由于静态成员会在加载类的时候进行初始化，因此这就变相要求 AsyncTask 的类必须在主线程中加载）\n（2）AsyncTask 的对象必须在主线程中创建\n（3）execute() 方法必须在 UI 线程中调用\n（4）不要再程序中直接调用 onPreExecute()、onPostExecute()、doInBackground() 和 onProgressUpdate() 方法\n（5）一个 AsyncTask 对象只能执行一次，即只能调用一次 execute 方法，否则会报运行时异常\n（6）Android 1.6 之前，串行执行；Android 3.0 之前，并行执行；3.0 之后，串行执行，但可以通过 AsyncTask 的 executeOnExecutor() 方法来并行执行任务\n\n- AsyncTask 中的 InternalHandler 用于将执行环境从线程池切换到主线程\n\n- IntentService 的优点：子线程中执行，可以自动结束，不容易被系统杀死(普通线程脱离四大组件后优先级非常低)\n\n- HandlerThread 继承自 Thread，是一种可以使用 Handler 的 Thread，内部创建了消息队列。外界需要通过 Handler 的消息方式来通知 HandlerThread 执行一个具体的任务。具体使用场景是 IntentService。由于 HandlerThread 的 run 方法是一个无限循环，因此当明确不需要再使用 HandlerThread 时，可以通过它的 quit 或 quitSafely 方法来终止线程的执行。\n\n- IntentService 第一次被启动时，onCreate 方法会被调用，其中会创建一个 HandlerThread，然后使用它的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最终都会在 HandlerThread 中执行。\n\n- 另外，由于每执行一个后台任务就必须启动一次 IntentService，而 IntentService 内部则通过消息的方式向 HandlerThread 请求执行任务，Handler 中的 Looper 是顺序处理消息的，这就意味着 IntentService 也是顺序执行后台任务的，当有多个后台任务同时存在时，这些后台任务会按照外界发起的顺序排队执行。\n\n- ThreadPoolExecutor 是线程池的真正实现，下面是其一个比较常用的构造方法：\n\n```\n    public ThreadPoolExecutor ( \n    \tint corePollSize, // 核心线程，默认会一直存活即使闲置。非默认是指将 allowCoreThreadTimeOut = true，则超过 keepAliveTime 后核心线程就会被终止\n    \tint maximumPoolSize, // 所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞\n    \tlong keepAliveTime, // 非核心线程闲置的超时时长\n    \tTimeUnit unit, // 枚举常量\n    \tBlockingQueue<Runnable> workQueue, // 任务队列，通过 execute 方法提交的 Runnable 对象会存储在这个参数中\n    \tThreadFactory threadFactory ) // 为线程池提供创建新线程的机会，ThreadFactory 是一个接口，只有一个方法：Thread newThread(Runnable r)\n```\n\n- ThreadPoolExecutor 执行任务时的规则：\n（1）如果线程池中的线程数量未达到核心线程数量，那么会直接启动一个核心线程来执行任务\n（2）如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到 workQueue 中排队等待执行\n（3）如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务\n（4）如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor 会调用 RejectedExecutionHandler 的 rejectExecution 方法来通知调用者\n\n- 四种线程池：\n（1）newFixedThreadPool 只有核心线程并且这些核心线程没有超时限制，另外任务队列也是没有大小限制的。\n（2）newCachedThreadPool 只有非核心线程，并且其最大值为 Integer.MAX_VALUE，60秒超时限制，它的 SynchronousQueue 无法插入任务\n（3）newScheduledThreadPool 核心线程数由参数指定，非核心线程数无限制，非核心闲置时立即被回收\n（4）newSingleThreadExecutor 只有一个核心线程，确保所有的任务都在同一个线程中按顺序执行，不需要处理线程同步的问题，无超时限制\n\n- inSampleSize 的取值应该总是2的指数，如果外界传递给系统的 inSampleSize 不为2的指数，那么系统会向下取整并选择一个最接近2的指数来代替，但是这个结论并非在所有的 Android 版本上都成立，因此把它当成一个开发者建议即可。\n\n- 为 Activity 开启硬件加速，android:hardwareAccelerated = \"true\"。\n\n- 通过 UncaughtExceptionHandler 来监视应用的 crash 信息，当程序 crash 时就会调用 uncaughtException 方法。它只能收到那些未捕获的异常，被 catch 的异常不会交给 UncaughtExceptionHandler 处理。\n\n- 单个 dex 文件所能够包含的最大方法数为 65536，这包含 Android FrameWork、以来的 jar 包以及应用本身的代码中的所有方法。\n\n- 解决方法数越界的方式：\n（1）删除无用代码和第三方库\n（2）插件化机制动态加载部分 dex， 通过将一个 dex 拆分成两个或多个 dex。但是偏重量级了，而且兼容性问题往往较多\n（3）Google 2014 年提出 multidex 解决方案，很好解决，使用很简单\n\n- 使用 multidex，Android 5.0 以前需要引入 android-support-multidex.jar，5.0 以后默认支持了 multidex。\n\n- multidex 局限性：\n（1）启动速度降低，因为要额外加载 dex 文件，甚至可能出现 ANR，尤其是其它 dex 文件较大的时候，因此要避免生成较大的 dex 文件\n（2）由于 Dalvik LinearAlloc 的 bug，这可能导致使用 multidex 的应用无法在 Android 4.0 以前的手机上运行，此种情况目前还极少遇到\n\n- 插件化三个基础性问题：资源访问、Activity 生命周期管理、ClassLoader 的管理\n（1）资源访问：插件中凡是以 R 开头的资源都不能访问了，解决方法为以反射的机制调用 AssetManager 的 addAssetPath 隐藏方法，将 apk 路径传递给它，将资源加载到 AssetManager 中；然后再通过 AssetManager 来创建一个新的 Resource 对象，通过这个对象就可以访问插件 apk 中的资源了；接着在代理 Activity 中实现 getAssets() 和 getResource() 方法\n（2）Activity 生命周期管理：使用反射，但是效率低且编写麻烦；最好使用接口回调，将 Activity 的生命周期方法都写到 IDLPlugin 接口中，在代理 Activity 中只需要在相应生命周期方法中调用插件 Activity 的生命周期方法即可\n（3）插件 ClassLoader 的管理：需要合理管理各个插件的 DexClassLoader，这样同一个插件就可以采用同一个 ClassLoader 去加载类，从而避免了多个 ClassLoader 加载同一个类时所引发的类型转换错误，可以将不同插件的 ClassLoader 存储在一个 HashMap 中，这样就可以保证不同插件中的类彼此互不干扰\n\n- 当一个进程发生 ANR 了以后，系统会在 /data/anr 目录下创建一个文件 traces.txt，通过分析这个文件就能定位出 ANR 的原因。 adb pull /data/anr/traces.txt。\n\n- float x 与“零值”比较的if语句为 if (fabs(x) < 0.00001f)\n\n- 带小数的默认为 double\n\n- 进入”Dead”状态的线程还可以恢复，不一定被回收\n\n- final类型的变量一定要初始化，因为final的变量不可更改\n\n- byte和short型在计算时会自动转换为int型计算\n\n- $Usdollars 是合法标识符\n\n- throws 关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过 throw 抛出异常对象\n\n- 在 JVM 中是使用监视器锁来实现不同线程的异步执行，在语法的表现就是synchronized\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-10-07- Android开发艺术探索","published":1,"updated":"2015-10-14T14:02:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynyh0016ek5x3qlhm9nl"},{"title":"Android 群英传读书笔记","date":"2015-10-06T14:18:44.000Z","_content":"\n偶然在知乎上看到了关于《Android 群英传》的介绍，感觉还不错，尤其是作者前言中写的内容和我简直心照不宣——Android 学习的瓶颈与进阶，读了快半本了，感觉非常不错，不合适初学者，但绝对适合学习到了瓶颈期，想要突破自我的 Android 开发者，比如我。\n\n<!--more-->\n\n- View 通过刷新来重绘视图，系统通过发出 `VSYNC` 信号来进行重绘，刷新间隔为`16ms`。当如游戏刷新频繁时，会频繁阻塞主线程，导致画面卡顿。此时可使用 SurfaceView 来解决这一问题。View 和 SurfaceView 区别如下3点：\n 1、View 适用于主动刷新，SurfaceView 适用于被动刷新\n 2、View 工作在主线程，SurfaceView 工作在子线程\n 3、View 没有使用双缓冲机制，SurfaceView 使用了双缓冲机制\n 如果自定义 View 需要频繁刷新，或者刷新时数据处理量比较大，那就需要考虑使用 SurfaceView 来代替 View。\n\n- onSaveInstanceState() 不是每次 Activity 离开前台时都会调用的，比如用户使用 finish() 结束 Activity，则不会调用。而且 Android 系统已经默认实现了控件的缓存状态，以此来减少开发者需要实现的缓存逻辑。\n\n- 如果启动模式为 singleTask 的 Activity 已经在后台一个任务栈中了，那么启动后，后台的这个任务栈将一起被切换到前台。\n\n- 注意，如果在一个 singleTop 或者 singleInstance 的 ActivityA 中通过 startActivityForResult() 方法来启动另一个 ActivityB，那么系统将直接返回 Activity.RESUL_CANCELED 而不会再去等待返回。这是由于系统在 Framework 层做了对这两种启动模式的限制，因为 Android 开发者认为，不同 Task 之间，默认是不能传递数据的，如果一定要传递，那就只能通过 Intent 来绑定数据。\n\n- Android 安全机制五道防线：代码混淆 proguard + 权限控制 + 数字证书 + Linux 内核层安全机制 + 虚拟机沙箱隔离\n\n- Android 中的内存组成：寄存器 + 栈 + 堆 + 静态存储区域 + 常量池\n\n- 一旦使用完 Bitmap 后，一定要及时使用 bitmap.recycle() 方法释放内存资源。Android 3.0 之后，Bitmap 被放置到了堆中，其内存由 GC 管理，就不需要进行释放了。\n\n- 进程名以 \":\" 开头的进程属于当前应用的私有进程，其它应用的组件不可以和它跑在同一个进程中，而进程名不以 \":\" 开头的进程属于全局进程，其它应用通过 ShareUID 方式可以和它跑在同一个进程中。\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-10-06- Android群英传.markdown","raw":"title: Android 群英传读书笔记\ndate: 2015-10-06 22:18:44\ntags: Android\n----\n\n偶然在知乎上看到了关于《Android 群英传》的介绍，感觉还不错，尤其是作者前言中写的内容和我简直心照不宣——Android 学习的瓶颈与进阶，读了快半本了，感觉非常不错，不合适初学者，但绝对适合学习到了瓶颈期，想要突破自我的 Android 开发者，比如我。\n\n<!--more-->\n\n- View 通过刷新来重绘视图，系统通过发出 `VSYNC` 信号来进行重绘，刷新间隔为`16ms`。当如游戏刷新频繁时，会频繁阻塞主线程，导致画面卡顿。此时可使用 SurfaceView 来解决这一问题。View 和 SurfaceView 区别如下3点：\n 1、View 适用于主动刷新，SurfaceView 适用于被动刷新\n 2、View 工作在主线程，SurfaceView 工作在子线程\n 3、View 没有使用双缓冲机制，SurfaceView 使用了双缓冲机制\n 如果自定义 View 需要频繁刷新，或者刷新时数据处理量比较大，那就需要考虑使用 SurfaceView 来代替 View。\n\n- onSaveInstanceState() 不是每次 Activity 离开前台时都会调用的，比如用户使用 finish() 结束 Activity，则不会调用。而且 Android 系统已经默认实现了控件的缓存状态，以此来减少开发者需要实现的缓存逻辑。\n\n- 如果启动模式为 singleTask 的 Activity 已经在后台一个任务栈中了，那么启动后，后台的这个任务栈将一起被切换到前台。\n\n- 注意，如果在一个 singleTop 或者 singleInstance 的 ActivityA 中通过 startActivityForResult() 方法来启动另一个 ActivityB，那么系统将直接返回 Activity.RESUL_CANCELED 而不会再去等待返回。这是由于系统在 Framework 层做了对这两种启动模式的限制，因为 Android 开发者认为，不同 Task 之间，默认是不能传递数据的，如果一定要传递，那就只能通过 Intent 来绑定数据。\n\n- Android 安全机制五道防线：代码混淆 proguard + 权限控制 + 数字证书 + Linux 内核层安全机制 + 虚拟机沙箱隔离\n\n- Android 中的内存组成：寄存器 + 栈 + 堆 + 静态存储区域 + 常量池\n\n- 一旦使用完 Bitmap 后，一定要及时使用 bitmap.recycle() 方法释放内存资源。Android 3.0 之后，Bitmap 被放置到了堆中，其内存由 GC 管理，就不需要进行释放了。\n\n- 进程名以 \":\" 开头的进程属于当前应用的私有进程，其它应用的组件不可以和它跑在同一个进程中，而进程名不以 \":\" 开头的进程属于全局进程，其它应用通过 ShareUID 方式可以和它跑在同一个进程中。\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-10-06- Android群英传","published":1,"updated":"2015-10-07T03:04:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynyi0018ek5x4vjxfmsz"},{"title":"BlockingQueue 浅层次总结","date":"2015-09-15T14:18:44.000Z","_content":"\nAsyncTask、ThreadPool 中都会用到 BlockingQueue，这是一个接口，它实现的子类有：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue。本文简要分析总结下 ArrayBlockingQueue。\n\n<!--more-->\n\n### offer(anObject)：\n\n表示如果可能的话，将 anObject 加到 BlockingQueue 里，即如果 BlockingQueue 可以容纳，则返回 true，否则返回 false。\n\n```\npublic boolean offer(E e) {\n    if (e == null) throw new NullPointerException();\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        if (count == items.length)\n            return false;\n        else {\n            enqueue(e);\n            return true;\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### offer(anObject, timeout, timeunit):\n\n加不进去就轮询，直到可以加进去为止。\n\n```\npublic boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length) {\n            if (nanos <= 0)\n                return false;\n            nanos = notFull.awaitNanos(nanos);\n        }\n        enqueue(e);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### put(anObject)：\n     \n把 anObject 加到 BlockingQueue 里，如果 BlockingQueue 没有空间，则调用此方法的线程被阻断直到 BlockingQueue 里有空间再继续。\n\n```\npublic void put(E e) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length)\n            notFull.await();\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### poll(timeout, timeunit)\n\n 取走 BlockingQueue 里排在首位的对象，若不能立即取出，则可以等 timeout 参数规定的时间，取不到时返回null。\n\n```\npublic E poll(long timeout, TimeUnit unit) throws InterruptedException {\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == 0) {\n            if (nanos <= 0)\n                return null;\n            nanos = notEmpty.awaitNanos(nanos);\n        }\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### take()\n\n取走BlockingQueue里排在首位的对象，若BlockingQueue为空，阻断进入等待状态直到BlockingQueue有新的对象被加入为止。\n\n```\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == 0)\n            notEmpty.await();\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n# 四个实现类比较\n\n1、ArrayBlockingQueue：\n规定大小的 BlockingQueue，其构造函数必须带一个 int 参数来指明其大小。其所含的对象是以 FIFO（先入先出）顺序排序的。\n\n2、LinkedBlockingQueue：\n大小不定的 BlockingQueue，若其构造函数带一个规定大小的参数，生成的 BlockingQueue 有大小限制，若不带大小参数，所生成的 BlockingQueue 的大小由 Integer.MAX_VALUE 来决定。其所含的对象是以 FIFO 顺序排序的。\n\n3、PriorityBlockingQueue：\n类似于 LinkedBlockingQueue,但其所含对象的排序不是 FIFO，而是依据对象的自然排序顺序或者是构造函数所带的 Comparator 决定的顺序。\n\n4、SynchronousQueue：\n特殊的 BlockingQueue，对其的操作必须是放和取交替完成的。\n\n# 总结\n\n总的来说，BlockingQueue 内部使用的技术有，ReentrantLock，每次存、取前后都要 lock()、unlock()，且默认情况下是 UnfairLock；Condition,具体到 ArrayBlockingQueue 中就是 notEmpty 和 notFull，队列为空或满时无法出队或入队时，就执行 notFull.await() 和 notEmpty.await()；内部的队列是循环队列。\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-16-BlockingQueue.markdown","raw":"title: BlockingQueue 浅层次总结\ndate: 2015-09-15 22:18:44\ntags: Java\n---\n\nAsyncTask、ThreadPool 中都会用到 BlockingQueue，这是一个接口，它实现的子类有：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue。本文简要分析总结下 ArrayBlockingQueue。\n\n<!--more-->\n\n### offer(anObject)：\n\n表示如果可能的话，将 anObject 加到 BlockingQueue 里，即如果 BlockingQueue 可以容纳，则返回 true，否则返回 false。\n\n```\npublic boolean offer(E e) {\n    if (e == null) throw new NullPointerException();\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        if (count == items.length)\n            return false;\n        else {\n            enqueue(e);\n            return true;\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### offer(anObject, timeout, timeunit):\n\n加不进去就轮询，直到可以加进去为止。\n\n```\npublic boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length) {\n            if (nanos <= 0)\n                return false;\n            nanos = notFull.awaitNanos(nanos);\n        }\n        enqueue(e);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### put(anObject)：\n     \n把 anObject 加到 BlockingQueue 里，如果 BlockingQueue 没有空间，则调用此方法的线程被阻断直到 BlockingQueue 里有空间再继续。\n\n```\npublic void put(E e) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length)\n            notFull.await();\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### poll(timeout, timeunit)\n\n 取走 BlockingQueue 里排在首位的对象，若不能立即取出，则可以等 timeout 参数规定的时间，取不到时返回null。\n\n```\npublic E poll(long timeout, TimeUnit unit) throws InterruptedException {\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == 0) {\n            if (nanos <= 0)\n                return null;\n            nanos = notEmpty.awaitNanos(nanos);\n        }\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n### take()\n\n取走BlockingQueue里排在首位的对象，若BlockingQueue为空，阻断进入等待状态直到BlockingQueue有新的对象被加入为止。\n\n```\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == 0)\n            notEmpty.await();\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n# 四个实现类比较\n\n1、ArrayBlockingQueue：\n规定大小的 BlockingQueue，其构造函数必须带一个 int 参数来指明其大小。其所含的对象是以 FIFO（先入先出）顺序排序的。\n\n2、LinkedBlockingQueue：\n大小不定的 BlockingQueue，若其构造函数带一个规定大小的参数，生成的 BlockingQueue 有大小限制，若不带大小参数，所生成的 BlockingQueue 的大小由 Integer.MAX_VALUE 来决定。其所含的对象是以 FIFO 顺序排序的。\n\n3、PriorityBlockingQueue：\n类似于 LinkedBlockingQueue,但其所含对象的排序不是 FIFO，而是依据对象的自然排序顺序或者是构造函数所带的 Comparator 决定的顺序。\n\n4、SynchronousQueue：\n特殊的 BlockingQueue，对其的操作必须是放和取交替完成的。\n\n# 总结\n\n总的来说，BlockingQueue 内部使用的技术有，ReentrantLock，每次存、取前后都要 lock()、unlock()，且默认情况下是 UnfairLock；Condition,具体到 ArrayBlockingQueue 中就是 notEmpty 和 notFull，队列为空或满时无法出队或入队时，就执行 notFull.await() 和 notEmpty.await()；内部的队列是循环队列。\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-16-BlockingQueue","published":1,"updated":"2015-10-15T02:47:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynyk001aek5xnfyj5eou"},{"title":"JIT 学习笔记","date":"2015-09-16T14:18:44.000Z","_content":"\nJIT编译器是Java虚拟机（以下简称JVM）中效率最高并且最重要的组成部分之一。但是很多的程序并没有充分利用JIT的高性能优化能力，很多开发者甚至也并不清楚他们的程序有效利用JIT的程度。\n\n<!--more-->\n\nJIT编译的关键一点就是JVM会自动地监控正在被解释器执行的方法。一旦某个方法被视为频繁调用，这个方法就会被标记，进而编译成本地机器指令。这些频繁执行的方法的编译由后台的一个JVM线程来完成。在编译完成之前，JVM会执行这个方法的解释执行版本。一旦该方法编译完成，JVM会使用将方法调度表中该方法的解释的版本替换成编译后的版本。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-16- JIT 学习笔记.markdown","raw":"title: JIT 学习笔记\ndate: 2015-09-16 22:18:44\ntags: Java\n---\n\nJIT编译器是Java虚拟机（以下简称JVM）中效率最高并且最重要的组成部分之一。但是很多的程序并没有充分利用JIT的高性能优化能力，很多开发者甚至也并不清楚他们的程序有效利用JIT的程度。\n\n<!--more-->\n\nJIT编译的关键一点就是JVM会自动地监控正在被解释器执行的方法。一旦某个方法被视为频繁调用，这个方法就会被标记，进而编译成本地机器指令。这些频繁执行的方法的编译由后台的一个JVM线程来完成。在编译完成之前，JVM会执行这个方法的解释执行版本。一旦该方法编译完成，JVM会使用将方法调度表中该方法的解释的版本替换成编译后的版本。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-16- JIT 学习笔记","published":1,"updated":"2015-09-16T02:10:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynym001cek5xf16sv6hx"},{"title":"CopyOnWrite 浅层次总结","date":"2015-09-14T14:18:44.000Z","_content":"\n同 ConcurrentHashMap 一样，CopyOnWrite 也是一种多线程并发中使用的容器，实现起来要比 ConcurrentHashMap 简单不少。从 JDK1.5 开始 Java 并发包里提供了两个使用 CopyOnWrite 机制实现的并发容器,它们是 CopyOnWriteArrayList 和 CopyOnWriteArraySet。CopyOnWrite 容器非常有用，可以在非常多的并发场景中使用到，下面就来浅层次总结一下。\n\n<!--more-->\n\n# 源码解析\n\nCopyOnWrite 根据名字，即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器。\n\n看一下它的 add 方法就比较清晰了，如下：\n\n```\n\tpublic synchronized boolean add(E e) {\n\t\t// 新开辟一个长度为原 length + 1 的对象数组\n        Object[] newElements = new Object[elements.length + 1];\n        // 将原 elements 数组中的内容全部复制到 newElements 数组中\n        System.arraycopy(elements, 0, newElements, 0, elements.length);\n        // 在 newElements 末尾添加新的元素 e\n        newElements[elements.length] = e;\n        // 将修改后的数组赋值给原 elements 数组\n        elements = newElements;\n        return true;\n    }\n```\n\n另外也需要注意这个方法是同步的，否则多线程写的时候会 Copy 出 N 个副本出来。\n\n下面，至于读方法，真是再简单不过了，如下：\n\n```\n\tpublic E get(int index) {\n        return (E) elements[index];\n    }\n```\n\n读的时候不需要加锁，如果读的时候有多个线程正在向 newElements[] 添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的 elements[]。\n\n# 应用场景\n\nCopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单。\n\n# 注意问题\n\n- 内存占用问题：因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，那么这个时候很有可能造成频繁的 Young GC 和 Full GC。\n\n- 数据一致性问题：CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果希望写入的的数据马上能读到，就不要使用 CopyOnWrite 容器。\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-14-CopyOnWrite.markdown","raw":"title: CopyOnWrite 浅层次总结\ndate: 2015-09-14 22:18:44\ntags: Java\n---\n\n同 ConcurrentHashMap 一样，CopyOnWrite 也是一种多线程并发中使用的容器，实现起来要比 ConcurrentHashMap 简单不少。从 JDK1.5 开始 Java 并发包里提供了两个使用 CopyOnWrite 机制实现的并发容器,它们是 CopyOnWriteArrayList 和 CopyOnWriteArraySet。CopyOnWrite 容器非常有用，可以在非常多的并发场景中使用到，下面就来浅层次总结一下。\n\n<!--more-->\n\n# 源码解析\n\nCopyOnWrite 根据名字，即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器。\n\n看一下它的 add 方法就比较清晰了，如下：\n\n```\n\tpublic synchronized boolean add(E e) {\n\t\t// 新开辟一个长度为原 length + 1 的对象数组\n        Object[] newElements = new Object[elements.length + 1];\n        // 将原 elements 数组中的内容全部复制到 newElements 数组中\n        System.arraycopy(elements, 0, newElements, 0, elements.length);\n        // 在 newElements 末尾添加新的元素 e\n        newElements[elements.length] = e;\n        // 将修改后的数组赋值给原 elements 数组\n        elements = newElements;\n        return true;\n    }\n```\n\n另外也需要注意这个方法是同步的，否则多线程写的时候会 Copy 出 N 个副本出来。\n\n下面，至于读方法，真是再简单不过了，如下：\n\n```\n\tpublic E get(int index) {\n        return (E) elements[index];\n    }\n```\n\n读的时候不需要加锁，如果读的时候有多个线程正在向 newElements[] 添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的 elements[]。\n\n# 应用场景\n\nCopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单。\n\n# 注意问题\n\n- 内存占用问题：因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，那么这个时候很有可能造成频繁的 Young GC 和 Full GC。\n\n- 数据一致性问题：CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果希望写入的的数据马上能读到，就不要使用 CopyOnWrite 容器。\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-14-CopyOnWrite","published":1,"updated":"2015-10-14T14:24:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynyn001eek5xnb16qgzg"},{"title":"ConcurrentHashMap 浅层次总结","date":"2015-09-14T14:18:44.000Z","_content":"\n学习了 ConcurrentHashMap 的源码，不由地为设计者的思想点赞，现在时间有限，先总结一些我觉得比较有用的知识点，先占个坑，等有时间再详细分析源码。\n\n<!--more-->\n\n# Java 内存模型\n\n## 重排序\n- 编译器生成指令的次序，可以不同于源代码所暗示的“显然”版本\n- 处理器可以乱序或者并行的执行指令\n- 缓存会改变写入提交到主内存的变量的次序\n\n## 内存可见性\n- 执行线程 A 的处理器把变量 V 缓存到寄存器中\n- 执行线程 A 的处理器把变量 V 缓存到自己的缓存中，但还没有同步刷新到主内存中去\n- 执行线程 B 的处理器的缓存中有变量 V 的旧值\n- 可以使用 volatile 确保内存可见性\n\n## happens-before 关系\n\nhappens-before 关系保证：如果线程 A 与线程 B 满足 happens-before 关系，则线程 A 执行动作的结果对于线程 B 是可见的。如果两个操作未按 happens-before 排序，JVM 将可以对他们任意重排序。\n\n几个与 ConcurrentHashMap 有关的 happens-before 关系法则：\n- 程序次序法则：如果在程序中，所有动作 A 出现在动作 B 之前，则线程中的每动作 A 都 happens-before 于该线程中的每一个动作 B\n- 监视器锁法则：对一个监视器的解锁 happens-before 于每个后续对同一监视器的加锁\n- Volatile 变量法则：对 Volatile 域的写入操作 happens-before 于每个后续对同一 Volatile 的读操作\n- 传递性：如果 A happens-before 于 B，且 B happens-before C，则 A happens-before C\n\n# 结构图\n\n## 整体结构图\n\n![ConcurrentHashMap](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image005.jpg)\n\n## 局部 segment 结构图\n\n![Segment](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image004.jpg)\n\n\n# HashEntry 类\n\n```\n\t// 注意 key、hash、next 都是 final 类型， value 是 volatile 类型\n\tstatic final class HashEntry<K,V> { \n        final K key;                // 声明 key 为 final 型\n        final int hash;             // 声明 hash 值为 final 型 \n        volatile V value;           // 声明 value 为 volatile 型\n        final HashEntry<K,V> next;  // 声明 next 为 final 型 \n\t}\n```\n\n# ConcurrentHashMap 类\n\nConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。\n\n# 用分离锁实现多个线程间的并发写操作\n\nlock() 只针对某一 segment 进行，最后在 unlock()。\n\n# 用 HashEntery 对象的不变性来降低读操作对加锁的需求\n\nHashEntry 类的 value 域被声明为 Volatile 型，Java 的内存模型可以保证：某个写线程对 value 域的写入马上可以被后续的某个读线程“看”到。在 ConcurrentHashMap 中，不允许用 unll 作为键和值，当读线程读到某个 HashEntry 的 value 域的值为 null 时，便知道产生了冲突——发生了重排序现象，需要加锁后重新读入这个 value 值。这些特性互相配合，使得读线程即使在不加锁状态下，也能正确访问 ConcurrentHashMap。\n\n## 对散列表做非结构性修改\n\n因为使用了 volatile 所以可以保证内存可见性，一个线程修改了某个 value 可以随后被另一个线程看到。\n\n## 对散列表做结构性修改\n\n结构性修改操作包括 put，remove，clear。\n\n（1）clear：将所有的 segment 置空，每个 segment 之前引用的链表还在，只是 segment 不再引用这些链表，所以正在遍历这个链表的读线程依然可以正常执行对该链表的遍历操作。\n（2）put：头插法，原有链表并没有修改，也不会影响原来读链表的线程。\n（3）remove：\n- 执行删除之前的原链表\n\t\n![before-remove](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image007.jpg)\n\n- 执行删除之后的新链表\n![after-remove](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image008.jpg)\n\n# 用 Volatile 变量协调读写线程间的内存可见性\n\n![volatile](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image009.jpg)\n\n此处也用到了 happens-before 法则，另外也需要注意 count 这个变量，其被声明为 transient volatile int count; 所有执行写操作的方法（put, remove, clear），在对链表做结构性修改之后，在退出写方法前都会去写这个 count 变量。所有未加锁的读操作（get, contains, containsKey）在读方法中，都会首先去读取这个 count 变量。\n\n# 基于通常情形而优化\n\n由于散列表读操作频率远远大于写操作，所以 ConcurrentHashMap 针对读操作做了大量的优化。通过 HashEntry 对象的不变性和用 volatile 型变量协调线程间的内存可见性，使得大多数时候，读操作不需要加锁就可以正确获得值。这个特性使得 ConcurrentHashMap 的并发性能在分离锁的基础上又有了近一步的提高。\n\n# 高并发性总结\n\n1、减小锁竞争的方式\n（1）减小请求同一个锁的频率\n（2）减小持有锁的时间\n\n2、ConcurrentHashMap 的高并发性来源于三个方面：\n（1）用分离锁实现多个线程间的更深层次的共享访问。\n（2）用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。\n（3）通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。\n\n使用分离锁，减小了请求 同一个锁的频率。\n通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。\n通过减小请求同一个锁的频率和尽量减少持有锁的时间 ，使得 ConcurrentHashMap 的并发性相对于 HashTable 和用同步包装器包装的 HashMap有了质的提高。\n\n[参考文章](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/#ibm-pcon)\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-14-ConcurrentHashMap.markdown","raw":"title: ConcurrentHashMap 浅层次总结\ndate: 2015-09-14 22:18:44\ntags: Java\n---\n\n学习了 ConcurrentHashMap 的源码，不由地为设计者的思想点赞，现在时间有限，先总结一些我觉得比较有用的知识点，先占个坑，等有时间再详细分析源码。\n\n<!--more-->\n\n# Java 内存模型\n\n## 重排序\n- 编译器生成指令的次序，可以不同于源代码所暗示的“显然”版本\n- 处理器可以乱序或者并行的执行指令\n- 缓存会改变写入提交到主内存的变量的次序\n\n## 内存可见性\n- 执行线程 A 的处理器把变量 V 缓存到寄存器中\n- 执行线程 A 的处理器把变量 V 缓存到自己的缓存中，但还没有同步刷新到主内存中去\n- 执行线程 B 的处理器的缓存中有变量 V 的旧值\n- 可以使用 volatile 确保内存可见性\n\n## happens-before 关系\n\nhappens-before 关系保证：如果线程 A 与线程 B 满足 happens-before 关系，则线程 A 执行动作的结果对于线程 B 是可见的。如果两个操作未按 happens-before 排序，JVM 将可以对他们任意重排序。\n\n几个与 ConcurrentHashMap 有关的 happens-before 关系法则：\n- 程序次序法则：如果在程序中，所有动作 A 出现在动作 B 之前，则线程中的每动作 A 都 happens-before 于该线程中的每一个动作 B\n- 监视器锁法则：对一个监视器的解锁 happens-before 于每个后续对同一监视器的加锁\n- Volatile 变量法则：对 Volatile 域的写入操作 happens-before 于每个后续对同一 Volatile 的读操作\n- 传递性：如果 A happens-before 于 B，且 B happens-before C，则 A happens-before C\n\n# 结构图\n\n## 整体结构图\n\n![ConcurrentHashMap](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image005.jpg)\n\n## 局部 segment 结构图\n\n![Segment](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image004.jpg)\n\n\n# HashEntry 类\n\n```\n\t// 注意 key、hash、next 都是 final 类型， value 是 volatile 类型\n\tstatic final class HashEntry<K,V> { \n        final K key;                // 声明 key 为 final 型\n        final int hash;             // 声明 hash 值为 final 型 \n        volatile V value;           // 声明 value 为 volatile 型\n        final HashEntry<K,V> next;  // 声明 next 为 final 型 \n\t}\n```\n\n# ConcurrentHashMap 类\n\nConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。\n\n# 用分离锁实现多个线程间的并发写操作\n\nlock() 只针对某一 segment 进行，最后在 unlock()。\n\n# 用 HashEntery 对象的不变性来降低读操作对加锁的需求\n\nHashEntry 类的 value 域被声明为 Volatile 型，Java 的内存模型可以保证：某个写线程对 value 域的写入马上可以被后续的某个读线程“看”到。在 ConcurrentHashMap 中，不允许用 unll 作为键和值，当读线程读到某个 HashEntry 的 value 域的值为 null 时，便知道产生了冲突——发生了重排序现象，需要加锁后重新读入这个 value 值。这些特性互相配合，使得读线程即使在不加锁状态下，也能正确访问 ConcurrentHashMap。\n\n## 对散列表做非结构性修改\n\n因为使用了 volatile 所以可以保证内存可见性，一个线程修改了某个 value 可以随后被另一个线程看到。\n\n## 对散列表做结构性修改\n\n结构性修改操作包括 put，remove，clear。\n\n（1）clear：将所有的 segment 置空，每个 segment 之前引用的链表还在，只是 segment 不再引用这些链表，所以正在遍历这个链表的读线程依然可以正常执行对该链表的遍历操作。\n（2）put：头插法，原有链表并没有修改，也不会影响原来读链表的线程。\n（3）remove：\n- 执行删除之前的原链表\n\t\n![before-remove](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image007.jpg)\n\n- 执行删除之后的新链表\n![after-remove](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image008.jpg)\n\n# 用 Volatile 变量协调读写线程间的内存可见性\n\n![volatile](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image009.jpg)\n\n此处也用到了 happens-before 法则，另外也需要注意 count 这个变量，其被声明为 transient volatile int count; 所有执行写操作的方法（put, remove, clear），在对链表做结构性修改之后，在退出写方法前都会去写这个 count 变量。所有未加锁的读操作（get, contains, containsKey）在读方法中，都会首先去读取这个 count 变量。\n\n# 基于通常情形而优化\n\n由于散列表读操作频率远远大于写操作，所以 ConcurrentHashMap 针对读操作做了大量的优化。通过 HashEntry 对象的不变性和用 volatile 型变量协调线程间的内存可见性，使得大多数时候，读操作不需要加锁就可以正确获得值。这个特性使得 ConcurrentHashMap 的并发性能在分离锁的基础上又有了近一步的提高。\n\n# 高并发性总结\n\n1、减小锁竞争的方式\n（1）减小请求同一个锁的频率\n（2）减小持有锁的时间\n\n2、ConcurrentHashMap 的高并发性来源于三个方面：\n（1）用分离锁实现多个线程间的更深层次的共享访问。\n（2）用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。\n（3）通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。\n\n使用分离锁，减小了请求 同一个锁的频率。\n通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。\n通过减小请求同一个锁的频率和尽量减少持有锁的时间 ，使得 ConcurrentHashMap 的并发性相对于 HashTable 和用同步包装器包装的 HashMap有了质的提高。\n\n[参考文章](http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/#ibm-pcon)\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-14-ConcurrentHashMap","published":1,"updated":"2015-10-14T13:25:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynyp001gek5x09m8to28"},{"title":"设计模式 - 知识导图","date":"2015-09-14T14:18:44.000Z","_content":"\n设计模式知识导图\n\n<!--more-->\n\n# 设计模式\n\n![设计模式](http://7xivx9.com1.z0.glb.clouddn.com/summary设计模式.png)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-14- 设计模式-导图.markdown","raw":"title: 设计模式 - 知识导图\ndate: 2015-09-14 22:18:44\ntags: 设计模式\n---\n\n设计模式知识导图\n\n<!--more-->\n\n# 设计模式\n\n![设计模式](http://7xivx9.com1.z0.glb.clouddn.com/summary设计模式.png)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-14- 设计模式-导图","published":1,"updated":"2015-09-14T13:35:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynys001iek5xqgxm57ck"},{"title":"《第一行代码》 - 知识导图","date":"2015-09-14T14:18:44.000Z","_content":"\n强制自己使用思维导图，收益匪浅。最近复习 Android 相关知识，涉及 `Java 基础知识`, `《第一行代码》`, `Android 进阶`, `数据结构`, `设计模式`。\n\n<!--more-->\n\n# 《第一行代码》\n\n![第一行代码](http://7xivx9.com1.z0.glb.clouddn.com/summary第一行代码.png)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-14- 第一行代码-导图.markdown","raw":"title: 《第一行代码》 - 知识导图\ndate: 2015-09-14 22:18:44\ntags: Android\n---\n\n强制自己使用思维导图，收益匪浅。最近复习 Android 相关知识，涉及 `Java 基础知识`, `《第一行代码》`, `Android 进阶`, `数据结构`, `设计模式`。\n\n<!--more-->\n\n# 《第一行代码》\n\n![第一行代码](http://7xivx9.com1.z0.glb.clouddn.com/summary第一行代码.png)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-14- 第一行代码-导图","published":1,"updated":"2015-09-14T13:32:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynyu001lek5x4f093rvj"},{"title":"数据结构 - 知识导图","date":"2015-09-14T14:18:44.000Z","_content":"\n数据结构知识导图\n\n<!--more-->\n\n# 数据结构\n\n![数据结构](http://7xivx9.com1.z0.glb.clouddn.com/summary数据结构.png)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-14- 数据结构-导图.markdown","raw":"title: 数据结构 - 知识导图\ndate: 2015-09-14 22:18:44\ntags: 数据结构\n---\n\n数据结构知识导图\n\n<!--more-->\n\n# 数据结构\n\n![数据结构](http://7xivx9.com1.z0.glb.clouddn.com/summary数据结构.png)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-14- 数据结构-导图","published":1,"updated":"2015-09-14T13:35:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynyv001nek5x48mygs4l"},{"title":"单链表逆置","date":"2015-09-14T14:18:44.000Z","_content":"\n明天阿里面，并无卵用的假装复习一下数据结构，总结一下单链表的逆置算法，包括 `复制逆置` 和 `就地逆置`。\n\n<!--more-->\n\n# 复制逆置\n所谓复制逆置，就是再开一个同样的空间，用于存储新的单链表，空间复杂度为O(n)。具体做法：从原链表顺序取元素，采用头插法插入到新的空链表中，完成逆置。\n\n复制逆置没有什么难度，主要考的还是 `就地逆置`。\n\n# 就地逆置\n就地逆置要保证时间复杂度为O(n) && 无辅助空间。总的来说：设置一指针p总是指向第一个结点（即从头到尾都指向的是同一个`第一个`结点），每次都将p后面的结点用头插法移动到头结点后面，循环就好了。\n\n具体算法：\n\n```c\ntypedef struct LNode {\n\tint data;\n\tstruct LNode* next;\n} LNode, *LinkList;\n\nvoid Reverse(LinkList list) {\n\tLinkList p, q; //p总是指向开始就是第一个的结点, q = p->next\n\tif ( list == NULL )\n\t\treturn;\n\n\tp = list->next; //从下面也可以看出来，p的指针就不再变化了\n\n\twhile ( p->next != NULL ){\n\t\tq = p->next;\n\t\tp->next = q->next;\n\t\tq-next = list->next;\n\t\tlist->next = q;\n\t}\n}\n```\n\n参考文章 : [pianoid 博客](http://www.cnblogs.com/pianoid/archive/2011/05/03/reverse-a-singly-linked-list.html)\n\n明天呢，增加下阅历。\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-14- 单链表逆置.markdown","raw":"title: 单链表逆置\ndate: 2015-09-14 22:18:44\ntags: 数据结构与算法\n---\n\n明天阿里面，并无卵用的假装复习一下数据结构，总结一下单链表的逆置算法，包括 `复制逆置` 和 `就地逆置`。\n\n<!--more-->\n\n# 复制逆置\n所谓复制逆置，就是再开一个同样的空间，用于存储新的单链表，空间复杂度为O(n)。具体做法：从原链表顺序取元素，采用头插法插入到新的空链表中，完成逆置。\n\n复制逆置没有什么难度，主要考的还是 `就地逆置`。\n\n# 就地逆置\n就地逆置要保证时间复杂度为O(n) && 无辅助空间。总的来说：设置一指针p总是指向第一个结点（即从头到尾都指向的是同一个`第一个`结点），每次都将p后面的结点用头插法移动到头结点后面，循环就好了。\n\n具体算法：\n\n```c\ntypedef struct LNode {\n\tint data;\n\tstruct LNode* next;\n} LNode, *LinkList;\n\nvoid Reverse(LinkList list) {\n\tLinkList p, q; //p总是指向开始就是第一个的结点, q = p->next\n\tif ( list == NULL )\n\t\treturn;\n\n\tp = list->next; //从下面也可以看出来，p的指针就不再变化了\n\n\twhile ( p->next != NULL ){\n\t\tq = p->next;\n\t\tp->next = q->next;\n\t\tq-next = list->next;\n\t\tlist->next = q;\n\t}\n}\n```\n\n参考文章 : [pianoid 博客](http://www.cnblogs.com/pianoid/archive/2011/05/03/reverse-a-singly-linked-list.html)\n\n明天呢，增加下阅历。\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-14- 单链表逆置","published":1,"updated":"2015-10-02T14:50:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynyx001qek5xj6q6htej"},{"title":"Java 基础知识 - 知识导图","date":"2015-09-14T14:18:44.000Z","_content":"\nJava 基础知识知识导图\n\n<!--more-->\n\n# Java 基础知识\n\n![Java 基础知识](http://7xivx9.com1.z0.glb.clouddn.com/summaryJava基础知识.png)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-14- Java 基础知识-导图.markdown","raw":"title: Java 基础知识 - 知识导图\ndate: 2015-09-14 22:18:44\ntags: Android\n---\n\nJava 基础知识知识导图\n\n<!--more-->\n\n# Java 基础知识\n\n![Java 基础知识](http://7xivx9.com1.z0.glb.clouddn.com/summaryJava基础知识.png)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-14- Java 基础知识-导图","published":1,"updated":"2015-09-14T13:36:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynyy001tek5xn9tw2dv3"},{"title":"Android 进阶 - 知识导图","date":"2015-09-14T14:18:44.000Z","_content":"\nAndroid 进阶知识导图\n\n<!--more-->\n\n# Android 进阶\n\n![Android 进阶](http://7xivx9.com1.z0.glb.clouddn.com/summaryAndroid进阶.png)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-14- Android 进阶-导图.markdown","raw":"title: Android 进阶 - 知识导图\ndate: 2015-09-14 22:18:44\ntags: Android\n---\n\nAndroid 进阶知识导图\n\n<!--more-->\n\n# Android 进阶\n\n![Android 进阶](http://7xivx9.com1.z0.glb.clouddn.com/summaryAndroid进阶.png)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-14- Android 进阶-导图","published":1,"updated":"2015-09-14T13:35:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynz1001vek5xnbvgblzu"},{"title":"Java 字符集与编码","date":"2015-09-13T14:18:44.000Z","_content":"\n读《Java 特种兵》总结之前不会的相关知识。\n\n<!--more-->\n\nJava 中的 char 是 UTF-16 编码，每个字符占两个字节的宽度。\n\n例如发送 2 个汉字，用 UTF-8 编码发送后会占用 6 个字节，对方若知道传来的数据是 UTF-8 编码，便知道这 6 个字节代表哪 2 个汉字，就自然能得到正确的 char 字符了。但是如果对方用 GBK 来编码，则可能会认为有 3 个字符，若按照每 2 个字节计算 1 个字符，得到的 3 个字符自然不是需要传递的 2 个汉字字符。假如此时意识到自己的编码错误了，通过得到的 3 个字符的字符串调用 getBytes(\"GBK\") 还可以还原 6 个字节，然后通过这 6 个字节再用 new String(byte[], \"UTF-8\") 得到实际的 2 个汉字。可真的是这样嘛？要知道这是偶然的，不是必然的，因为 UTF-8 转换出来的 6 个字节，当按照每 2 个字节组成编码时，这个编码未必在 GBK 的编码范围内，若不在 GBK 的编码范围内，就可能会用一个 \"?\" 或其他字符来代表，由于 \"?\" 本身也是一个字符，当再次调用 getBytes(\"GBK\") 时得到的对应字节就是 \"?\" 对应的字节，而不是原来字符的字节，有可能都不再是 6 个字节了。换句话说，这样的情况是永远无法转换回来的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-13- Java字符集与编码.markdown","raw":"title: Java 字符集与编码\ndate: 2015-09-13 22:18:44\ntags: Java\n---\n\n读《Java 特种兵》总结之前不会的相关知识。\n\n<!--more-->\n\nJava 中的 char 是 UTF-16 编码，每个字符占两个字节的宽度。\n\n例如发送 2 个汉字，用 UTF-8 编码发送后会占用 6 个字节，对方若知道传来的数据是 UTF-8 编码，便知道这 6 个字节代表哪 2 个汉字，就自然能得到正确的 char 字符了。但是如果对方用 GBK 来编码，则可能会认为有 3 个字符，若按照每 2 个字节计算 1 个字符，得到的 3 个字符自然不是需要传递的 2 个汉字字符。假如此时意识到自己的编码错误了，通过得到的 3 个字符的字符串调用 getBytes(\"GBK\") 还可以还原 6 个字节，然后通过这 6 个字节再用 new String(byte[], \"UTF-8\") 得到实际的 2 个汉字。可真的是这样嘛？要知道这是偶然的，不是必然的，因为 UTF-8 转换出来的 6 个字节，当按照每 2 个字节组成编码时，这个编码未必在 GBK 的编码范围内，若不在 GBK 的编码范围内，就可能会用一个 \"?\" 或其他字符来代表，由于 \"?\" 本身也是一个字符，当再次调用 getBytes(\"GBK\") 时得到的对应字节就是 \"?\" 对应的字节，而不是原来字符的字节，有可能都不再是 6 个字节了。换句话说，这样的情况是永远无法转换回来的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-13- Java字符集与编码","published":1,"updated":"2015-09-17T13:16:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynz4001xek5xtv20c3yk"},{"title":"Android开发中的大坑","date":"2015-09-06T14:18:44.000Z","_content":"\n在Android开发的过程中，有哪些坑是值得你放在checklist中警示自己的？\n\n<!--more-->\n\n1、TextView（往往 TextView 派生子类同样适用）调用 setText 方法设置一个 int 型的数据，千万要将该值转为 String，否则在某些设备中它会默认去查询 R 文件中定义的资源。\n\n2、上线之前一定要使用正式签名打包\n\n3、在 Activity 中尽可能少的创建 Handler 对象，创建一个主线程 Handler，一个后台 HandlerThread 就可以了。\n\n4、使用 BitMap 之后，一定要记得释放。\n\n5、使用线程的地方尽量不要 new Thread，而是使用 AsyncThread 。\n\n6、创建了四大组件一定记得要在 AndroidManifest 文件中声明（当然 BroadcastReceiver 可以动态注册）。\n\n7. 为Activity声明系统配置变更事件 系统配置变更事件是指转屏，区域语言发生变化，屏幕尺寸发生变化等等，如果Activity没有声明处理这些事件，发生事件时，系统会把Activity杀掉然后重启，并尝试恢复状态，Activity有机会通过onSaveInstanceState()保存一些基本数据到Bundle中，然后此Bundle会在Activity的onCreate()中传递过去。虽然这貌似正常，但是这会引发问题，因为很多其他的东西比如Dialog等是要依赖于具体Activity实例的。所以这种系统默认行为通常都不是我们想要的。\n为了避免这些系统默认行为，就需要为Activity声明这些配置，如下二个是每个Activity必须声明的：\n<activity android:configChanges=\"orientation|keyboardHidden\">\n几乎所有的Activity都要声明如上，为什么Android不把它们变成Default的呢?\n\n8. 尽量使用Android的API 这好像是废话，在Android上面开发不用Android API用什么？因为Android几乎支持Java SE所有的API，所以有很多地方Android API与Java SE的API会有重复的地方，比如说对于文件的操作最好使用Android里面Context封装的API，而不要直接使用File对象：\nContext.openFileOutput(String); // no File file = new File(String)\n原因就是API里面会考虑到Android平台本身的特性；再如，少用Thread，而多使用AsyncTask等。\n\n\n9. 要考虑到Activity和进程被杀掉的情况 如了通常情况退出Activity外，还有Activity因其他原因被杀的情况，比如系统内存过低，系统配置变更，有异常等等，要考虑和测试这种情况，特别是Activity处理重要的数据时，做好的数据的保存。\n\n\n10. 小心多语言 有些语言真的很啰嗦，中文或英文很简短就能表达的事情到了其他语言就变的死长死长的，所以如果是wrap_content就可能把其他控制挤出可视范围； 如果是指定长度就可能显示不全。也要注意特殊语言比如那些从右向左读的语言。\n\n11. 不要用四大组件去实现接口 一是组件的对象都比较大，实现接口比较浪费，而且让代码更不易读和理解； 另外更重要的是导致多方引用，可能会引发内存泄露。\n\n\n12. 用getApplication()来取Context当参数 对于需要使用Context对象作为参数的函数，要使用getApplication()获取Context对象当参数，而不要使用this，除非你需要特定的组件实例！getApplication()返回的Context是属于Application的，它会在整个应用的生命周期内存在，远大于某个组件的生命周期，所以即使某个引用长期持有Context对象也不会引发内存泄露。\n\n13. 主线程只做UI控制和Frameworks回调相关的事。附属线程只做费时的后台操作。交互只通过Handler。这样就可以避免大量的线程问题。\n\n14. Frameworks的回调不要做太多事情仅做必要的初始化，其他不是很重要的事情可以放到其他线程中去做，或者用Handler Schedule到稍后再做。\n\n15. 要考虑多分辨率 至少为hdpi, mdpi, ldpi准备图片和布局。元素的单位也尽可能的使用dip而不要用px。\n\n![image](http://pic1.zhimg.com/d98fb9a8cbe4149340080f74b9fa0324_r.jpg)\n\n参考文章 : [知乎](http://www.zhihu.com/question/27488517)\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-09-06- Android开发中的大坑.markdown","raw":"title: Android开发中的大坑\ndate: 2015-09-06 22:18:44\ntags: Android\n---\n\n在Android开发的过程中，有哪些坑是值得你放在checklist中警示自己的？\n\n<!--more-->\n\n1、TextView（往往 TextView 派生子类同样适用）调用 setText 方法设置一个 int 型的数据，千万要将该值转为 String，否则在某些设备中它会默认去查询 R 文件中定义的资源。\n\n2、上线之前一定要使用正式签名打包\n\n3、在 Activity 中尽可能少的创建 Handler 对象，创建一个主线程 Handler，一个后台 HandlerThread 就可以了。\n\n4、使用 BitMap 之后，一定要记得释放。\n\n5、使用线程的地方尽量不要 new Thread，而是使用 AsyncThread 。\n\n6、创建了四大组件一定记得要在 AndroidManifest 文件中声明（当然 BroadcastReceiver 可以动态注册）。\n\n7. 为Activity声明系统配置变更事件 系统配置变更事件是指转屏，区域语言发生变化，屏幕尺寸发生变化等等，如果Activity没有声明处理这些事件，发生事件时，系统会把Activity杀掉然后重启，并尝试恢复状态，Activity有机会通过onSaveInstanceState()保存一些基本数据到Bundle中，然后此Bundle会在Activity的onCreate()中传递过去。虽然这貌似正常，但是这会引发问题，因为很多其他的东西比如Dialog等是要依赖于具体Activity实例的。所以这种系统默认行为通常都不是我们想要的。\n为了避免这些系统默认行为，就需要为Activity声明这些配置，如下二个是每个Activity必须声明的：\n<activity android:configChanges=\"orientation|keyboardHidden\">\n几乎所有的Activity都要声明如上，为什么Android不把它们变成Default的呢?\n\n8. 尽量使用Android的API 这好像是废话，在Android上面开发不用Android API用什么？因为Android几乎支持Java SE所有的API，所以有很多地方Android API与Java SE的API会有重复的地方，比如说对于文件的操作最好使用Android里面Context封装的API，而不要直接使用File对象：\nContext.openFileOutput(String); // no File file = new File(String)\n原因就是API里面会考虑到Android平台本身的特性；再如，少用Thread，而多使用AsyncTask等。\n\n\n9. 要考虑到Activity和进程被杀掉的情况 如了通常情况退出Activity外，还有Activity因其他原因被杀的情况，比如系统内存过低，系统配置变更，有异常等等，要考虑和测试这种情况，特别是Activity处理重要的数据时，做好的数据的保存。\n\n\n10. 小心多语言 有些语言真的很啰嗦，中文或英文很简短就能表达的事情到了其他语言就变的死长死长的，所以如果是wrap_content就可能把其他控制挤出可视范围； 如果是指定长度就可能显示不全。也要注意特殊语言比如那些从右向左读的语言。\n\n11. 不要用四大组件去实现接口 一是组件的对象都比较大，实现接口比较浪费，而且让代码更不易读和理解； 另外更重要的是导致多方引用，可能会引发内存泄露。\n\n\n12. 用getApplication()来取Context当参数 对于需要使用Context对象作为参数的函数，要使用getApplication()获取Context对象当参数，而不要使用this，除非你需要特定的组件实例！getApplication()返回的Context是属于Application的，它会在整个应用的生命周期内存在，远大于某个组件的生命周期，所以即使某个引用长期持有Context对象也不会引发内存泄露。\n\n13. 主线程只做UI控制和Frameworks回调相关的事。附属线程只做费时的后台操作。交互只通过Handler。这样就可以避免大量的线程问题。\n\n14. Frameworks的回调不要做太多事情仅做必要的初始化，其他不是很重要的事情可以放到其他线程中去做，或者用Handler Schedule到稍后再做。\n\n15. 要考虑多分辨率 至少为hdpi, mdpi, ldpi准备图片和布局。元素的单位也尽可能的使用dip而不要用px。\n\n![image](http://pic1.zhimg.com/d98fb9a8cbe4149340080f74b9fa0324_r.jpg)\n\n参考文章 : [知乎](http://www.zhihu.com/question/27488517)\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-09-06- Android开发中的大坑","published":1,"updated":"2015-09-06T02:39:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynz6001zek5xab9cvlc7"},{"title":"mac抓包工具--Charles","date":"2015-08-30T14:18:44.000Z","_content":"\n上篇文章介绍了 Mac 中 [Debookee](http://icodeyou.com/2015/08/23/2015-08-15-%20mac%E4%B8%8B%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7--Debookee/) 抓局域网数据包的使用方法，主要是基于 ARP 欺骗。这次将要介绍的 Charles 的原理是`设置中间代理`来完成抓包的工作。\n\n<!--more-->\n\n# Charles 的安装与破解（都是程序员，女人何必为难女人）\n\n - 下载原版 Charles 路径：[我的七牛云存储](http://7xivx9.com1.z0.glb.clouddn.com/charles-proxy-3.10.2.dmg) or [官网](http://www.charlesproxy.com/download/)，并正常安装（此版本为 3.10.2，目前为官网最新）\n - 下载破解 jar 包：[我的七牛云存储](http://7xivx9.com1.z0.glb.clouddn.com/charles.jar)\n - 显示 Charles 包的内容\n \t![image](http://7xivx9.com1.z0.glb.clouddn.com/charles-cracker-1.png)\n - 替换 `charles.jar`\n \t![image](http://7xivx9.com1.z0.glb.clouddn.com/charles-cracker-2.png)\n - 完成，打开即可使用\n\n# 使用 Charles 抓取网络请求\n\n参考文章 : [使用Charles抓取App网络请求](http://www.brighttj.com/ios/ios-use-charles-fetch-web-request-in-app.html)\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-08-30- mac下抓包工具--Charles.markdown","raw":"title: mac抓包工具--Charles\ndate: 2015-08-30 22:18:44\ntags: Mac\n---\n\n上篇文章介绍了 Mac 中 [Debookee](http://icodeyou.com/2015/08/23/2015-08-15-%20mac%E4%B8%8B%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7--Debookee/) 抓局域网数据包的使用方法，主要是基于 ARP 欺骗。这次将要介绍的 Charles 的原理是`设置中间代理`来完成抓包的工作。\n\n<!--more-->\n\n# Charles 的安装与破解（都是程序员，女人何必为难女人）\n\n - 下载原版 Charles 路径：[我的七牛云存储](http://7xivx9.com1.z0.glb.clouddn.com/charles-proxy-3.10.2.dmg) or [官网](http://www.charlesproxy.com/download/)，并正常安装（此版本为 3.10.2，目前为官网最新）\n - 下载破解 jar 包：[我的七牛云存储](http://7xivx9.com1.z0.glb.clouddn.com/charles.jar)\n - 显示 Charles 包的内容\n \t![image](http://7xivx9.com1.z0.glb.clouddn.com/charles-cracker-1.png)\n - 替换 `charles.jar`\n \t![image](http://7xivx9.com1.z0.glb.clouddn.com/charles-cracker-2.png)\n - 完成，打开即可使用\n\n# 使用 Charles 抓取网络请求\n\n参考文章 : [使用Charles抓取App网络请求](http://www.brighttj.com/ios/ios-use-charles-fetch-web-request-in-app.html)\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-08-30- mac下抓包工具--Charles","published":1,"updated":"2015-08-30T02:34:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynz90021ek5xl1733yqb"},{"title":"每日学习炸鸡","date":"2015-08-28T14:18:44.000Z","_content":"\n每天都会看些文章视频等学习资料，看的多了有时候当时记住了，但是过后也许就忘了，所以要记录一下，以巩固知识。\n\n<!--more-->\n\n- n个结点的哈夫曼树，叶子结点有 （n/2+1） 个\n\n- 排序算法总结\n\n| 排序法 | 平均 | 最差 | 辅助 | 是否稳定 |\n|:-----:|:----:|:---:|:----:|:------:|\n| 冒泡 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 快排 | O(n\\*logn) | O(n\\*n) | O(logn)-O(n) | 不稳定 |\n| 选择 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 插入 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 堆排 | O(n\\*logn) | O(n\\*logn) | O(1) | 不稳定 |\n| 希尔 |  |  | O(1) | 不稳定 |\n\n![sort](http://7xivx9.com1.z0.glb.clouddn.com/sort.png)\n\n- 关于广播\n - 静态注册广播最大优先级为 2147483647\n - 生命周期只有十秒左右，如果在 onReceive() 内做超过十秒内的事情，就会报ANR(Application No Response) 程序无响应的错误信息，如果需要完成一项比较耗时的工作 , 应该通过发送 Intent 给 Service, 由Service 来完成 . 这里不能使用子线程来解决 , 因为 BroadcastReceiver 的生命周期很短 , 子线程可能还没有结束BroadcastReceiver 就先结束了 .BroadcastReceiver 一旦结束 , 此时 BroadcastReceiver 的所在进程很容易在系统需要内存时被优先杀死 , 因为它属于空进程 ( 没有任何活动组件的进程 ). 如果它的宿主进程被杀死 , 那么正在工作的子线程也会被杀死 . 所以采用子线程来解决是不可靠的。\n\n- Service 运行在主线程中，不能执行耗时操作。要区分 后台 和 子线程 的概念：Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。你可能又会问，前面不是刚刚验证过Service是运行在主线程里的么？在这里一直执行着心跳连接，难道就不会阻塞主线程的运行吗？当然会，但是我们可以在Service中再创建一个子线程，然后在这里去处理耗时逻辑就没问题了。既然在Service里也要创建一个子线程，那为什么不直接在Activity里创建呢？这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。\n\n- 布局原则\n - 尽量多使用RelativeLayout和LinearLayout, 不要使用绝对布局AbsoluteLayout，在布局层次一样的情况下， 建议使用LinearLayout代替RelativeLayout, 因为LinearLayout性能要稍高一点，但往往RelativeLayout可以简单实现LinearLayout嵌套才能实现的布局；\n - 将可复用的组件抽取出来并通过include标签使用；\n - 使用ViewStub标签来加载一些不常用的布局；\n - 使用merge标签减少布局的嵌套层次。\n\n- Hander、Message、Looper 的关系\n - Looper:\n    每个线程有且最多只能有一个Looper对象，它是一个ThreadLocal\n    Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行\n    Looper使一个线程变成Looper线程\n - Handler:\n    handler扮演了往MQ上添加消息和处理消息的角色（只处理由自己发出的消息），即通知MQ它要执行一个任务(sendMessage)，并在loop到自己的时候执行该任务(handleMessage)，整个过程是异步的。handler创建时会关联一个looper，默认的构造方法将关联当前线程的looper，不过这也是可以set的。\n - Message:\n    尽管Message有public的默认构造方法，但是你应该通过Message.obtain()来从消息池中获得空消息对象，以节省资源。\n    如果你的message只需要携带简单的int信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存\n    擅用message.what来标识信息，以便用不同方式处理message。\n\n- AsyncTask\n\t在3.0之前的AsyncTask可以同时有5个任务在执行(再缓存128个)，而3.0之后的AsyncTask同时只能有1个任务在执行。为什么升级之后可以同时执行的任务数反而变少了呢？这是因为更新后的AsyncTask已变得更加灵活，如果不想使用默认的线程池，还可以自由地进行配置。比如使用如下的代码来启动任务：这样就可以使用我们自定义的一个Executor来执行任务，而不是使用SerialExecutor。上述代码的效果允许在同一时刻有15个任务正在执行，并且最多能够存储200个任务。\n\t```\n\t\tExecutor exec = new ThreadPoolExecutor(15, 200, 10,  \n    \tTimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());  \n\t\tnew DownloadTask().executeOnExecutor(exec);  \n\t```\n\n- Async 的问题\n - cancel方法实现不是很好.\n   如果你调用了AsyncTask的cancel(false)，doInBackground()仍然会执行到方法结束，只是不会去调用onPostExecute()方法。但是实际上这是让应用程序执行了没有意义的操作。那么是不是我们调用cancel(true)前面的问题就能解决呢？并非如此。如果mayInterruptIfRunning设置为true，会使任务尽早结束，但是如果的doInBackground()有不可打断的方法会失效，比如这个BitmapFactory.decodeStream() IO操作。但是你可以提前关闭IO流并捕获这样操作抛出的异常。但是这样会使得cancel()方法没有任何意义\n\n - 内存泄露问题\n   还有一种常见的情况就是，在Activity中使用非静态匿名内部AsyncTask类，由于Java内部类的特点，AsyncTask内部类会持有外部类的隐式引用。由于AsyncTask的生命周期可能比Activity的长，当Activity进行销毁AsyncTask还在执行时，由于AsyncTask持有Activity的引用，导致Activity对象无法回收，进而产生内存泄露。\n\n - 结果丢失\n   另一个问题就是在屏幕旋转等造成Activity重新创建时AsyncTask数据丢失的问题。当Activity销毁并创新创建后，还在运行的AsyncTask会持有一个Activity的非法引用即之前的Activity实例。导致onPostExecute()没有任何作用。\n\n - 串行并行多版本不一致\n   1.6之前为串行，1.6到2.3为并行，3.0之后又改回为串行，但是可以通过executeOnExecutor(Executor)实现并行处理任务。\n\n- 子线程中更新UI的三种方法\n - Handler\n - runOnUiThread(Runnable r)\n - View.post(Runnable r)\n\n- Jackson 是一个将java对象转换成JSON与JSON转化java类的类库。Gson 是解决这个问题的流行方案，然而我们发现Jackson更高效,因为它支持替代的方法处理JSON:流、内存树模型,和传统JSON-POJO数据绑定。不过，请记住， Jsonkson库比起GSON更大，所以根据你的情况选择，你可能选择GSON来避免APP 65k个方法限制。\n\n- 小心关于WebViews的问题. 如果你必须显示一个web视图， 比如说对于一个新闻文章，避免做客户端处理HTML的工作， 最好让后端工程师协助，让他返回一个 \"纯\" HTML。 [WebViews 也能导致内存泄露](http://stackoverflow.com/questions/3130654/memory-leak-in-webview) 当保持引他们的Activity，而不是被绑定到ApplicationContext中的时候。\n\n- Android 内存泄露总结\n\n- [Android 开发最佳实践](https://github.com/futurice/android-best-practices/blob/master/translations/Chinese/README.cn.md)\n\n- HttpURLConnection 和 AndroidHttpClient(HttpClient 的封装)如何选择及原因：\n在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，所以在 Froyo 之前使用 HttpURLConnection 需要关闭 keepAlive。\n另外在 Gingerbread(2.3) HttpURLConnection 默认开启了 gzip 压缩，提高了 HTTPS 的性能，Ice Cream Sandwich(4.0) HttpURLConnection 支持了请求结果缓存。\n再加上 HttpURLConnection 本身 API 相对简单，所以对 Android 来说，在 2.3 之后建议使用 HttpURLConnection，之前建议使用 AndroidHttpClient。\n\n- [不要使用 enum](https://www.youtube.com/watch?v=Hzs6OBcvNQE&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE)\n\n- 启动页的splash如何实现\n对该Activity应用主题\n```\n<style name=\"customBackground\" parent=\"@android:style/Theme.Holo.Light\">\n    <item name=\"android:windowBackground\">@drawable/start_app</item>\n    <item name=\"android:windowNoTitle\">true</item>\n</style>\n```\n\n- Android的定时任务一般有两种方式实现，其一是Java API的`Timer`，另外是Android的`Alarm`。但Timer有一个明显的短板，并不太适用于那些需要长期在后台运行的定时任务。Android会在长时间不用的情况下为了省电使CPU进入睡眠状态，可能导致Timer中的定时任务无法执行。而Alarm机制不存在此种问题，它可以唤醒CPU。\n\n-Activity间通过Intent传递数据大小有没有限制？\n貌似是40K。\n\n- Android APK 50M大小限制\n\n- 启动一个程序，可以主界面点击图标进入，也可以从一个程序中跳转过去，二者有什么区别？\n\n因为启动程序（主界面也是一个app），发现了在这个程序中存在一个设置为<category android:name=\"android.intent.category.LAUNCHER\" />的activity,\n\n所以这个launcher会把icon提出来，放在主界面上。当用户点击icon的时候，发出一个Intent：\n\n```\nIntent intent = mActivity.getPackageManager().getLaunchIntentForPackage(packageName);\nmActivity.startActivity(intent);   \n```\n\n跳过去可以跳到任意允许的页面，如一个程序可以下载，那么真正下载的页面可能不是首页（也有可能是首页），这时还是构造一个Intent，startActivity.\n\n这个intent中的action可能有多种view,download都有可能。系统会根据第三方程序向系统注册的功能，为你的Intent选择可以打开的程序或者页面。所以唯一的一点\n\n`不同的是从icon的点击启动的intent的action是相对单一的，从程序中跳转或者启动可能样式更多一些。本质是相同的。`\n\n\n- 程序之间的亲和性的理解。\n\n1、默认情况下一个应用的所有Activity都是具有相同的affinity，都是从application中继承，application的`affinity默认就是manifest的包名`。\n\n2、`affinity对Activity来说，就像是身份证一样，可以告诉所在的Task，自己属于其中的一员。`\n\n3、应用场合：\n\na:根据affinity重新为Activity选择合适的宿主Task;\n\nb:与allowTaskReparenting属性配合;\n\nc:启动Activity使用Intent设置了FLAG_ACTIVITY_NEW_TASK标记。\n\n\n\n- 下面这段代码有内存泄露，能找出来吗？\n\n```\npackage com.zhy._01;\n\nimport java.util.Arrays;\n\n/*\n * 使用数组模拟栈\n */\npublic class MyStack\n{\n  private static final int DEFAULT_INIT_SIZE = 10;\n\n  private Object[] eles = new Object[DEFAULT_INIT_SIZE];\n  /**\n   * 当前栈顶索引\n   */\n  private int currentIndex;\n\n  /**\n   * 弹栈\n   * \n   * @return\n   */\n  public Object pop()\n  {\n    if (currentIndex == 0)\n      throw new ArrayIndexOutOfBoundsException(\"stack is empty\");\n    return eles[--currentIndex];\n  }\n\n  /**\n   * 压栈\n   * \n   * @param o\n   */\n  public void push(Object o)\n  {\n    ensureCapacity();\n    eles[currentIndex++] = o;\n  }\n\n  private void ensureCapacity()\n  {\n    if (eles.length == currentIndex)\n    {\n      eles = Arrays.copyOf(eles, currentIndex * 2 + 1);\n    }\n  }\n\n}\n```\n\n\n- 使用Fragment，一定要清楚这些方法，哪个会销毁视图，哪个会销毁实例，哪个仅仅只是隐藏，这样才能更好的使用它们。\n\na、比如：我在FragmentA中的EditText填了一些数据，当切换到FragmentB时，如果希望会到A还能看到数据，则适合你的就是hide和show；也就是说，希望保留用户操作的面板，你可以使用hide和show，当然了不要使劲在那new实例，进行下非null判断。\n\nb、再比如：我不希望保留用户操作，你可以使用remove()，然后add()；或者使用replace()这个和remove,add是相同的效果。\n\nc、remove和detach有一点细微的区别，在不考虑回退栈的情况下，remove会销毁整个Fragment实例，而detach则只是销毁其视图结构，实例并不会被销毁。那么二者怎么取舍使用呢？如果你的当前Activity一直存在，那么在不希望保留用户操作的时候，你可以优先使用detach。\n\n\n- transaction.remove() \n从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈，这个Fragment实例将会被销毁。\n\n- Handler总结：\n1、首先Looper.prepare()在本线程中保存一个Looper实例，然后该实例中保存一个MessageQueue对象；因为Looper.prepare()在一个线程中只能调用一次，所以MessageQueue在一个线程中只会存在一个。\n\n2、Looper.loop()会让当前线程进入一个无限循环，不端从MessageQueue的实例中读取消息，然后回调msg.target.dispatchMessage(msg)方法。\n\n3、`Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联`。\n\n4、Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。\n\n5、在构造Handler实例时，我们会重写handleMessage方法，也就是msg.target.dispatchMessage(msg)最终调用的方法。\n\n\n- 在3.0以前，最大支持128个线程的并发，10个任务的等待。在3.0以后，无论有多少任务，都会在其内部单线程执行；\n\n\n- EventBus.getDefault().register(this);意思是让EventBus扫描当前类，把所有onEvent开头的方法记录下来，如何记录呢？使用Map，Key为方法的参数类型，Value中包含我们的方法。然后当子线程执行完毕，调用EventBus.getDefault().post(new ItemListEvent(Item.ITEMS))时，EventBus会根据post中实参的类型，去Map中查找对于的方法，于是找到了我们的onEventMainThread，最终调用反射去执行我们的方法。\n\n\n- 关于Activity和Application的Context\n![image](http://img.blog.csdn.net/20150104183450879)\n有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释：\n\n数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐。\n\n数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。\n\n数字3：在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）\n\n注：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。\n\n看下表格，重点看Activity和Application，可以看到，和UI相关的方法基本都不建议或者不可使用Application，并且，前三个操作基本不可能在Application中出现。实际上，只要把握住一点，凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。\n\n\n- MVP\n![image](http://img.blog.csdn.net/20150622212835554)\n转换为\n![image](http://img.blog.csdn.net/20150622212856011)\n\n![image](http://img.blog.csdn.net/20150622212916054)\n\n其实最明显的区别就是，MVC中是允许Model和View进行交互的，而MVP中很明显，Model与View之间的交互由Presenter完成。还有一点就是Presenter与View之间的交互是通过接口的。[参考文章](http://blog.csdn.net/lmj623565791/article/details/46596109)\n\n\n- Reflection\n获取类中方法：\n```\n// 获取 Class 对象中指定函数名和参数的函数，参数一为函数名，参数 2 为参数类型列表\npublic Method getDeclaredMethod (String name, Class...<\\?> parameterTypes)\n\n// 获取该 Class 对象中的所有函数( 不包含从父类继承的函数 )\npublic Method[] getDeclaredMethods ()\n\n// 获取指定的 Class 对象中的**公有**函数，参数一为函数名，参数 2 为参数类型列表\npublic Method getMethod (String name, Class...<\\?> parameterTypes)\n\n// 获取该 Class 对象中的所有**公有**函数 ( 包含从父类和接口类集成下来的函数 )\npublic Method[] getMethods ()\n```\n\n这里需要注意的是 getDeclaredMethod 和 getDeclaredMethods 包含 private、protected、default、public 的函数，并且通过这两个函数获取到的只是在自身中定义的函数，从父类中集成的函数不能够获取到。而 getMethod 和 getMethods 只包含 public 函数，父类中的公有函数也能够获取到。\n\n获取类中属性：\n```\n// 获取 Class 对象中指定属性名的属性，参数一为属性名\npublic Method getDeclaredField (String name)\n\n// 获取该 Class 对象中的所有属性( 不包含从父类继承的属性 )\npublic Method[] getDeclaredFields ()\n\n// 获取指定的 Class 对象中的**公有**属性，参数一为属性名\npublic Method getField (String name)\n\n// 获取该 Class 对象中的所有**公有**属性 ( 包含从父类和接口类集成下来的公有属性 )\npublic Method[] getFields ()\n```\n\n这里需要注意的是 getDeclaredField 和 getDeclaredFields 包含 private、protected、default、public 的属性，并且通过这两个函数获取到的只是在自身中定义的属性，从父类中集成的属性不能够获取到。而 getField 和 getFields 只包含 public 属性，父类中的公有属性也能够获取到。\n\n获取父类\n```\nStudent student = new Student(\"mr.simple\");\n    Class<\\?> superClass = student.getClass().getSuperclass();\n    while (superClass != null) {\n        System.out.println(\"Student's super class is : \" + superClass.getName());\n        // 再获取父类的上一层父类，直到最后的 Object 类，Object 的父类为 null\n        superClass = superClass.getSuperclass();\n}\n```\n\n获取接口\n```\nprivate static void showInterfaces() {\n        Student student = new Student(\"mr.simple\");\n        Class<\\?>[] interfaceses = student.getClass().getInterfaces();\n        for (Class<\\?> class1 : interfaceses) {\n            System.out.println(\"Student's interface is : \" + class1.getName());\n        }\n}\n```\n\n\n- [依赖注入](http://a.codekk.com/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)\n\n- [Java Collections 系类学习](http://zhangshixi.iteye.com/blog/672697)\n\n- [ArrayList 和 LinkedList 各种遍历方式比较](http://www.trinea.cn/android/arraylist-linkedlist-loop-performance/)\n\n- Dalvik根据屏幕尺寸和密度决定应用程序的heap size，例如Android4.0.3的应用默认最小内存如下：\n![image](http://farm4.staticflickr.com/3686/9449083513_a56b59b17d_o.jpg)\n\n- ScrollView 只允许包含一个子 View\n\n- [TextView 添加链接](http://www.trinea.cn/android/textview-add-link/)\n\n- [Android应用如何开机自启动、自启动失败原因](http://www.trinea.cn/android/android-boot_completed-not-work/)\n\n- [关于Android线程优先级](http://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice/)\n\n- 有时候写的 BroadcastReceiver 中让线程 Thread.sleep(60*1000) 也不会出现 ANR，是因为确实发生了 ANR，只是没有弹窗而已，这种是 Background ANR，可以通过过滤日志验证，或者在开发者选项中勾选 \"显示应用程序无响应\" 对话框即可。\n\n- 在Java中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用。静态的内部类不会持有外部类的引用\n\n- [Handler引起的内存泄露](http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/?droid_refer=random_recommend)\n\n- [依赖注入](http://droidyue.com/blog/2015/06/13/talk-show-about-dependency-injection/?droid_refer=ninki_posts) 开始看这个名字的时候我还以为是安全性问题，读过文章之后才知道这是设计模式中依赖倒置的问题。先看段代码，看看有什么问题：\n\n```java\ninterface Energy {     \n}\n  \nclass GasEnergy implements Energy {\n}\n  \nclass Car {\n  Energy energy = new GasEnergy();\n}\n```\n\n采用组合依赖的形式本就是设计模式所推荐的，这无可厚非，可问题出现在直接 new 具体对象了，导致了耦合度增加，假如以后要修改具体对象类型了，此时还得修改 Car 类，这绝对不符合开闭原则，所以也就有了依赖注入，代码不写了，给三种方法：`构造器注入`,`Setters 方法注入`,`接口注入(接口里有 set 方法)`\n\n注入框架：\n（1）Guice采用的是运行时读取注解，通过反射的形式生成依赖并进行注入。这种形式不太适合Android移动设备，毕竟这些操作都在运行时处理，对性能要求较高。\n（2）Dagger则是Android开发适合的依赖注入库，其同样采用类注解的形式，不同的是它是在编译时生成辅助类，等到在运行时使用生成的辅助类完成依赖注入。\n\n- 我知道 Reader、Writer 字符流比 InputStream、OutputStream 多了一个缓存（缓冲）的特点，原来就是有些情况不调用 flush、close 的话不会将数据真正发送出去，才明白\n\n- [Android 系统设置中的清除数据究竟会清除哪些数据](http://droidyue.com/blog/2014/06/15/what-will-be-removed-if-you-click-clear-data-button-in-system-application-item/)\n\n- [申请权限支持设备不减少](http://droidyue.com/blog/2014/07/04/attentions-when-adding-permission-for-android-application/)\n\n- [Webview加载网页时发送HTTP头信息](http://droidyue.com/blog/2014/07/12/load-url-with-extra-header-in-android-webview-chinese-edition/)\n\n- [顶部带进度条的Webview](http://droidyue.com/blog/2014/07/12/ding-bu-dai-jin-du-tiao-de-webview/)\n\n- [捕获Android文本中链接点击事件](http://droidyue.com/blog/2014/07/27/capture-link-click-event-in-text-on-android/)\n\n- [超简单生成微博微信应用签名](http://droidyue.com/blog/2014/08/13/create-fignerprint-for-weibo-or-wechat-in-the-easiest-way/)\n\n- [终于可以使用Markdown写邮件啦](http://droidyue.com/blog/archives/)\n\n- [有关 Java 字符串的拼接](http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/)\n\n- [Android根据资源名获取资源ID](http://droidyue.com/blog/2014/09/12/get-resource-id-by-name-in-android/)\n\n- [Android中Java和JavaScript交互](http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android/)\n\n- [细话Java：\"失效\"的private修饰符](http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/)\n\n- [Java 四种引用类型](http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/)\n\n- [糟糕的 AsyncTask](http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/)\n\n- [如何使用 Loaders](http://developer.android.com/intl/zh-cn/guide/components/loaders.html)\n\n- [Android 垃圾回收日志](http://droidyue.com/blog/2014/11/08/understanding-garbage-collection-output-messages-in-android/)\n\n- [自定义 Toast 自己实现下](http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app/)\n\n- [Java 中堆和栈的区别 非常好的总结](http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/)\n\n- [关于 subString() 引起的\"内存泄露\"](http://droidyue.com/blog/2014/12/14/substring-memory-issue-in-java/) \n\n- [JVM运行时的数据区](http://droidyue.com/blog/2014/12/21/java-runtime-data-areas/)\n\n- 字符串常量池中存储的是字符串引用，而不是字符串本身，因为在 Java 中，对象都创建在堆内存中，[参考文章](http://droidyue.com/blog/2014/12/21/string-literal-pool-in-java/)\n\n- 对于使用new创建的字符串，如果也想将其引用放到字符串常量池中，可以使用intern方法\n```\nString str4 = str3.intern();\nSystem.out.println(str4 == str1);\n```\n\n- [Java 中的动态绑定和静态绑定](http://droidyue.com/blog/2014/12/28/static-biding-and-dynamic-binding-in-java/)。可以简单理解就是，重载是静态绑定，覆写是动态绑定。[又一动态绑定](http://www.cnblogs.com/dolphin0520/p/3803432.html)\n\n- [单例模式双重加锁时也要记得给instace加上volatile](http://droidyue.com/blog/2015/01/11/looking-into-singleton/)。另外 IoDH 技术可以用静态内部类实现在类加载时对instance进行初始化，类似于 Holder。\n\n- [单例模式可以被打破](http://droidyue.com/blog/2015/01/11/looking-into-singleton/)\n\n- [AutoBoxing UnBoxing == 与 Integer缓存-128~127的坑](http://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/)\n\n- [Context 泄露](http://droidyue.com/blog/2015/04/12/avoid-memory-leaks-on-context-in-android/)。其中也说到了Drawable引起的内存泄露。\n\n- [关于 HttpUrlConnection 和 HttpClient 的区别](http://droidyue.com/blog/2015/05/30/android-http-clients/)\n\n- [关于 lint](http://droidyue.com/blog/2015/07/25/use-android-lint-to-find-higher-api-usage/)\n\n- android:sharedUserId是指共用一个uid\n\n- 大多数static的数据被mmapped到一个进程中。这不仅仅让同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被paged out。常见的static数据包括Dalvik Code、app resources、so文件等。\n\n- Bitmap decode format 解码格式的差异？\n\n- 利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率\n\n- [内存泄露](http://www.csdn.net/article/2015-09-18/2825737/4)\n\n- 谨慎使用static对象。因为static的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在Android中应该谨慎使用static对象\n![image](http://img.ptcms.csdn.net/article/201509/18/55fbe22546ba6.jpg)\n\n- [LeakCanary](http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/)\n\n- [MAT的使用](http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/)\n\n- [Android Performance 中文](http://androidperformance.com/)\n\n- [JobScheduler](http://developer.android.com/intl/zh-cn/reference/android/app/job/JobScheduler.html)\n\n- 如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。\n![image](http://hukai.me/images/android_perf_2_ondraw_paint.png)\n\n- [Strict Mode 防止出现ANR 第11部分](http://hukai.me/android-performance-patterns-season-2/) \n\n- 尽量使用ClipRect等方法来提高绘制的性能 ?\n\n- 执行延时任务的三种方式：AlarmManager、SyncAdapter、JobSchedulor\n\n- Android 图片解码格式\n![image](http://hukai.me/images/android_perf_2_pixel_format.png)\n\n- Android 图片解码率\n![image](http://hukai.me/images/android_perf_2_pixel_decode.png)\n\n- 一种新的图片格式：Webp，它是由Google推出的一种既保留png格式的优点，又能够减少图片大小的一种新型图片格式\n\n- 缩放Bitmap的几种方式比较\ncreateScaledBitmap(),这种方法能够快速得到一张经过缩放的图片，可是这个方法能够执行的前提是，原图片需要事先加载到内存中，如果原图片过大，很可能导致OOM；\ninSampleSize能够等比的缩放显示图片，同时还避免了需要先把原图加载进内存的缺点；\n![image](http://hukai.me/images/android_perf_2_sacle_bitmap_code.png)\n还可以使用inScaled，inDensity，inTargetDensity的属性来对图片解码做处理；\n![image](http://hukai.me/images/android_perf_2_sacle_bitmap_inscale.png)\n使用inJustDecodeBounds，可以事先获取到图片的大小而不至于占用内存。\n![image](http://hukai.me/images/android_perf_2_sacle_bitmap_injust.png)\n\n- inBitmap\n\n- Glide 库\n\n- 对象池？\n\n- [继承中的隐藏和覆盖](http://www.cnblogs.com/dolphin0520/p/3803432.html)\n\n- 单线程私有：程序计数器、JVM栈、本地方法栈\n  多线程共享：堆内存、方法区、运行时常量池\n\n- 子 View 可以通过调用 getParent().requestDisallowInterceptTouchEvent(true);  阻止 ViewGroup 对其 MOVE 或者 UP 事件进行拦截。\n\n- 产生 ANR 的前提是要有输入事件，如果用户没有触发任何输入事件，即便是主线程阻塞了，也不会产生 ANR，因为 InputDispatcher 没有分发事件给应用程序，当然也不会检测处理超时和报告ANR了。\n\n- 不会参与对象序列化的是：类的静态成员变量和 transient 关键字标记的。\n\n- 类 ServiceConnection 中的 onServiceDisconnected() 方法在正常情况下是不被调用的，它的调用时机是当 Service 服务被异外销毁时，例如内存的资源不足时这个方法才被自动调用。\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-08-28- 每日学习炸鸡.markdown","raw":"title: 每日学习炸鸡\ndate: 2015-08-28 22:18:44\ntags: Android\n----\n\n每天都会看些文章视频等学习资料，看的多了有时候当时记住了，但是过后也许就忘了，所以要记录一下，以巩固知识。\n\n<!--more-->\n\n- n个结点的哈夫曼树，叶子结点有 （n/2+1） 个\n\n- 排序算法总结\n\n| 排序法 | 平均 | 最差 | 辅助 | 是否稳定 |\n|:-----:|:----:|:---:|:----:|:------:|\n| 冒泡 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 快排 | O(n\\*logn) | O(n\\*n) | O(logn)-O(n) | 不稳定 |\n| 选择 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 插入 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 堆排 | O(n\\*logn) | O(n\\*logn) | O(1) | 不稳定 |\n| 希尔 |  |  | O(1) | 不稳定 |\n\n![sort](http://7xivx9.com1.z0.glb.clouddn.com/sort.png)\n\n- 关于广播\n - 静态注册广播最大优先级为 2147483647\n - 生命周期只有十秒左右，如果在 onReceive() 内做超过十秒内的事情，就会报ANR(Application No Response) 程序无响应的错误信息，如果需要完成一项比较耗时的工作 , 应该通过发送 Intent 给 Service, 由Service 来完成 . 这里不能使用子线程来解决 , 因为 BroadcastReceiver 的生命周期很短 , 子线程可能还没有结束BroadcastReceiver 就先结束了 .BroadcastReceiver 一旦结束 , 此时 BroadcastReceiver 的所在进程很容易在系统需要内存时被优先杀死 , 因为它属于空进程 ( 没有任何活动组件的进程 ). 如果它的宿主进程被杀死 , 那么正在工作的子线程也会被杀死 . 所以采用子线程来解决是不可靠的。\n\n- Service 运行在主线程中，不能执行耗时操作。要区分 后台 和 子线程 的概念：Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。你可能又会问，前面不是刚刚验证过Service是运行在主线程里的么？在这里一直执行着心跳连接，难道就不会阻塞主线程的运行吗？当然会，但是我们可以在Service中再创建一个子线程，然后在这里去处理耗时逻辑就没问题了。既然在Service里也要创建一个子线程，那为什么不直接在Activity里创建呢？这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。\n\n- 布局原则\n - 尽量多使用RelativeLayout和LinearLayout, 不要使用绝对布局AbsoluteLayout，在布局层次一样的情况下， 建议使用LinearLayout代替RelativeLayout, 因为LinearLayout性能要稍高一点，但往往RelativeLayout可以简单实现LinearLayout嵌套才能实现的布局；\n - 将可复用的组件抽取出来并通过include标签使用；\n - 使用ViewStub标签来加载一些不常用的布局；\n - 使用merge标签减少布局的嵌套层次。\n\n- Hander、Message、Looper 的关系\n - Looper:\n    每个线程有且最多只能有一个Looper对象，它是一个ThreadLocal\n    Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行\n    Looper使一个线程变成Looper线程\n - Handler:\n    handler扮演了往MQ上添加消息和处理消息的角色（只处理由自己发出的消息），即通知MQ它要执行一个任务(sendMessage)，并在loop到自己的时候执行该任务(handleMessage)，整个过程是异步的。handler创建时会关联一个looper，默认的构造方法将关联当前线程的looper，不过这也是可以set的。\n - Message:\n    尽管Message有public的默认构造方法，但是你应该通过Message.obtain()来从消息池中获得空消息对象，以节省资源。\n    如果你的message只需要携带简单的int信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存\n    擅用message.what来标识信息，以便用不同方式处理message。\n\n- AsyncTask\n\t在3.0之前的AsyncTask可以同时有5个任务在执行(再缓存128个)，而3.0之后的AsyncTask同时只能有1个任务在执行。为什么升级之后可以同时执行的任务数反而变少了呢？这是因为更新后的AsyncTask已变得更加灵活，如果不想使用默认的线程池，还可以自由地进行配置。比如使用如下的代码来启动任务：这样就可以使用我们自定义的一个Executor来执行任务，而不是使用SerialExecutor。上述代码的效果允许在同一时刻有15个任务正在执行，并且最多能够存储200个任务。\n\t```\n\t\tExecutor exec = new ThreadPoolExecutor(15, 200, 10,  \n    \tTimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());  \n\t\tnew DownloadTask().executeOnExecutor(exec);  \n\t```\n\n- Async 的问题\n - cancel方法实现不是很好.\n   如果你调用了AsyncTask的cancel(false)，doInBackground()仍然会执行到方法结束，只是不会去调用onPostExecute()方法。但是实际上这是让应用程序执行了没有意义的操作。那么是不是我们调用cancel(true)前面的问题就能解决呢？并非如此。如果mayInterruptIfRunning设置为true，会使任务尽早结束，但是如果的doInBackground()有不可打断的方法会失效，比如这个BitmapFactory.decodeStream() IO操作。但是你可以提前关闭IO流并捕获这样操作抛出的异常。但是这样会使得cancel()方法没有任何意义\n\n - 内存泄露问题\n   还有一种常见的情况就是，在Activity中使用非静态匿名内部AsyncTask类，由于Java内部类的特点，AsyncTask内部类会持有外部类的隐式引用。由于AsyncTask的生命周期可能比Activity的长，当Activity进行销毁AsyncTask还在执行时，由于AsyncTask持有Activity的引用，导致Activity对象无法回收，进而产生内存泄露。\n\n - 结果丢失\n   另一个问题就是在屏幕旋转等造成Activity重新创建时AsyncTask数据丢失的问题。当Activity销毁并创新创建后，还在运行的AsyncTask会持有一个Activity的非法引用即之前的Activity实例。导致onPostExecute()没有任何作用。\n\n - 串行并行多版本不一致\n   1.6之前为串行，1.6到2.3为并行，3.0之后又改回为串行，但是可以通过executeOnExecutor(Executor)实现并行处理任务。\n\n- 子线程中更新UI的三种方法\n - Handler\n - runOnUiThread(Runnable r)\n - View.post(Runnable r)\n\n- Jackson 是一个将java对象转换成JSON与JSON转化java类的类库。Gson 是解决这个问题的流行方案，然而我们发现Jackson更高效,因为它支持替代的方法处理JSON:流、内存树模型,和传统JSON-POJO数据绑定。不过，请记住， Jsonkson库比起GSON更大，所以根据你的情况选择，你可能选择GSON来避免APP 65k个方法限制。\n\n- 小心关于WebViews的问题. 如果你必须显示一个web视图， 比如说对于一个新闻文章，避免做客户端处理HTML的工作， 最好让后端工程师协助，让他返回一个 \"纯\" HTML。 [WebViews 也能导致内存泄露](http://stackoverflow.com/questions/3130654/memory-leak-in-webview) 当保持引他们的Activity，而不是被绑定到ApplicationContext中的时候。\n\n- Android 内存泄露总结\n\n- [Android 开发最佳实践](https://github.com/futurice/android-best-practices/blob/master/translations/Chinese/README.cn.md)\n\n- HttpURLConnection 和 AndroidHttpClient(HttpClient 的封装)如何选择及原因：\n在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，所以在 Froyo 之前使用 HttpURLConnection 需要关闭 keepAlive。\n另外在 Gingerbread(2.3) HttpURLConnection 默认开启了 gzip 压缩，提高了 HTTPS 的性能，Ice Cream Sandwich(4.0) HttpURLConnection 支持了请求结果缓存。\n再加上 HttpURLConnection 本身 API 相对简单，所以对 Android 来说，在 2.3 之后建议使用 HttpURLConnection，之前建议使用 AndroidHttpClient。\n\n- [不要使用 enum](https://www.youtube.com/watch?v=Hzs6OBcvNQE&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE)\n\n- 启动页的splash如何实现\n对该Activity应用主题\n```\n<style name=\"customBackground\" parent=\"@android:style/Theme.Holo.Light\">\n    <item name=\"android:windowBackground\">@drawable/start_app</item>\n    <item name=\"android:windowNoTitle\">true</item>\n</style>\n```\n\n- Android的定时任务一般有两种方式实现，其一是Java API的`Timer`，另外是Android的`Alarm`。但Timer有一个明显的短板，并不太适用于那些需要长期在后台运行的定时任务。Android会在长时间不用的情况下为了省电使CPU进入睡眠状态，可能导致Timer中的定时任务无法执行。而Alarm机制不存在此种问题，它可以唤醒CPU。\n\n-Activity间通过Intent传递数据大小有没有限制？\n貌似是40K。\n\n- Android APK 50M大小限制\n\n- 启动一个程序，可以主界面点击图标进入，也可以从一个程序中跳转过去，二者有什么区别？\n\n因为启动程序（主界面也是一个app），发现了在这个程序中存在一个设置为<category android:name=\"android.intent.category.LAUNCHER\" />的activity,\n\n所以这个launcher会把icon提出来，放在主界面上。当用户点击icon的时候，发出一个Intent：\n\n```\nIntent intent = mActivity.getPackageManager().getLaunchIntentForPackage(packageName);\nmActivity.startActivity(intent);   \n```\n\n跳过去可以跳到任意允许的页面，如一个程序可以下载，那么真正下载的页面可能不是首页（也有可能是首页），这时还是构造一个Intent，startActivity.\n\n这个intent中的action可能有多种view,download都有可能。系统会根据第三方程序向系统注册的功能，为你的Intent选择可以打开的程序或者页面。所以唯一的一点\n\n`不同的是从icon的点击启动的intent的action是相对单一的，从程序中跳转或者启动可能样式更多一些。本质是相同的。`\n\n\n- 程序之间的亲和性的理解。\n\n1、默认情况下一个应用的所有Activity都是具有相同的affinity，都是从application中继承，application的`affinity默认就是manifest的包名`。\n\n2、`affinity对Activity来说，就像是身份证一样，可以告诉所在的Task，自己属于其中的一员。`\n\n3、应用场合：\n\na:根据affinity重新为Activity选择合适的宿主Task;\n\nb:与allowTaskReparenting属性配合;\n\nc:启动Activity使用Intent设置了FLAG_ACTIVITY_NEW_TASK标记。\n\n\n\n- 下面这段代码有内存泄露，能找出来吗？\n\n```\npackage com.zhy._01;\n\nimport java.util.Arrays;\n\n/*\n * 使用数组模拟栈\n */\npublic class MyStack\n{\n  private static final int DEFAULT_INIT_SIZE = 10;\n\n  private Object[] eles = new Object[DEFAULT_INIT_SIZE];\n  /**\n   * 当前栈顶索引\n   */\n  private int currentIndex;\n\n  /**\n   * 弹栈\n   * \n   * @return\n   */\n  public Object pop()\n  {\n    if (currentIndex == 0)\n      throw new ArrayIndexOutOfBoundsException(\"stack is empty\");\n    return eles[--currentIndex];\n  }\n\n  /**\n   * 压栈\n   * \n   * @param o\n   */\n  public void push(Object o)\n  {\n    ensureCapacity();\n    eles[currentIndex++] = o;\n  }\n\n  private void ensureCapacity()\n  {\n    if (eles.length == currentIndex)\n    {\n      eles = Arrays.copyOf(eles, currentIndex * 2 + 1);\n    }\n  }\n\n}\n```\n\n\n- 使用Fragment，一定要清楚这些方法，哪个会销毁视图，哪个会销毁实例，哪个仅仅只是隐藏，这样才能更好的使用它们。\n\na、比如：我在FragmentA中的EditText填了一些数据，当切换到FragmentB时，如果希望会到A还能看到数据，则适合你的就是hide和show；也就是说，希望保留用户操作的面板，你可以使用hide和show，当然了不要使劲在那new实例，进行下非null判断。\n\nb、再比如：我不希望保留用户操作，你可以使用remove()，然后add()；或者使用replace()这个和remove,add是相同的效果。\n\nc、remove和detach有一点细微的区别，在不考虑回退栈的情况下，remove会销毁整个Fragment实例，而detach则只是销毁其视图结构，实例并不会被销毁。那么二者怎么取舍使用呢？如果你的当前Activity一直存在，那么在不希望保留用户操作的时候，你可以优先使用detach。\n\n\n- transaction.remove() \n从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈，这个Fragment实例将会被销毁。\n\n- Handler总结：\n1、首先Looper.prepare()在本线程中保存一个Looper实例，然后该实例中保存一个MessageQueue对象；因为Looper.prepare()在一个线程中只能调用一次，所以MessageQueue在一个线程中只会存在一个。\n\n2、Looper.loop()会让当前线程进入一个无限循环，不端从MessageQueue的实例中读取消息，然后回调msg.target.dispatchMessage(msg)方法。\n\n3、`Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联`。\n\n4、Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。\n\n5、在构造Handler实例时，我们会重写handleMessage方法，也就是msg.target.dispatchMessage(msg)最终调用的方法。\n\n\n- 在3.0以前，最大支持128个线程的并发，10个任务的等待。在3.0以后，无论有多少任务，都会在其内部单线程执行；\n\n\n- EventBus.getDefault().register(this);意思是让EventBus扫描当前类，把所有onEvent开头的方法记录下来，如何记录呢？使用Map，Key为方法的参数类型，Value中包含我们的方法。然后当子线程执行完毕，调用EventBus.getDefault().post(new ItemListEvent(Item.ITEMS))时，EventBus会根据post中实参的类型，去Map中查找对于的方法，于是找到了我们的onEventMainThread，最终调用反射去执行我们的方法。\n\n\n- 关于Activity和Application的Context\n![image](http://img.blog.csdn.net/20150104183450879)\n有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释：\n\n数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐。\n\n数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。\n\n数字3：在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）\n\n注：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。\n\n看下表格，重点看Activity和Application，可以看到，和UI相关的方法基本都不建议或者不可使用Application，并且，前三个操作基本不可能在Application中出现。实际上，只要把握住一点，凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。\n\n\n- MVP\n![image](http://img.blog.csdn.net/20150622212835554)\n转换为\n![image](http://img.blog.csdn.net/20150622212856011)\n\n![image](http://img.blog.csdn.net/20150622212916054)\n\n其实最明显的区别就是，MVC中是允许Model和View进行交互的，而MVP中很明显，Model与View之间的交互由Presenter完成。还有一点就是Presenter与View之间的交互是通过接口的。[参考文章](http://blog.csdn.net/lmj623565791/article/details/46596109)\n\n\n- Reflection\n获取类中方法：\n```\n// 获取 Class 对象中指定函数名和参数的函数，参数一为函数名，参数 2 为参数类型列表\npublic Method getDeclaredMethod (String name, Class...<\\?> parameterTypes)\n\n// 获取该 Class 对象中的所有函数( 不包含从父类继承的函数 )\npublic Method[] getDeclaredMethods ()\n\n// 获取指定的 Class 对象中的**公有**函数，参数一为函数名，参数 2 为参数类型列表\npublic Method getMethod (String name, Class...<\\?> parameterTypes)\n\n// 获取该 Class 对象中的所有**公有**函数 ( 包含从父类和接口类集成下来的函数 )\npublic Method[] getMethods ()\n```\n\n这里需要注意的是 getDeclaredMethod 和 getDeclaredMethods 包含 private、protected、default、public 的函数，并且通过这两个函数获取到的只是在自身中定义的函数，从父类中集成的函数不能够获取到。而 getMethod 和 getMethods 只包含 public 函数，父类中的公有函数也能够获取到。\n\n获取类中属性：\n```\n// 获取 Class 对象中指定属性名的属性，参数一为属性名\npublic Method getDeclaredField (String name)\n\n// 获取该 Class 对象中的所有属性( 不包含从父类继承的属性 )\npublic Method[] getDeclaredFields ()\n\n// 获取指定的 Class 对象中的**公有**属性，参数一为属性名\npublic Method getField (String name)\n\n// 获取该 Class 对象中的所有**公有**属性 ( 包含从父类和接口类集成下来的公有属性 )\npublic Method[] getFields ()\n```\n\n这里需要注意的是 getDeclaredField 和 getDeclaredFields 包含 private、protected、default、public 的属性，并且通过这两个函数获取到的只是在自身中定义的属性，从父类中集成的属性不能够获取到。而 getField 和 getFields 只包含 public 属性，父类中的公有属性也能够获取到。\n\n获取父类\n```\nStudent student = new Student(\"mr.simple\");\n    Class<\\?> superClass = student.getClass().getSuperclass();\n    while (superClass != null) {\n        System.out.println(\"Student's super class is : \" + superClass.getName());\n        // 再获取父类的上一层父类，直到最后的 Object 类，Object 的父类为 null\n        superClass = superClass.getSuperclass();\n}\n```\n\n获取接口\n```\nprivate static void showInterfaces() {\n        Student student = new Student(\"mr.simple\");\n        Class<\\?>[] interfaceses = student.getClass().getInterfaces();\n        for (Class<\\?> class1 : interfaceses) {\n            System.out.println(\"Student's interface is : \" + class1.getName());\n        }\n}\n```\n\n\n- [依赖注入](http://a.codekk.com/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)\n\n- [Java Collections 系类学习](http://zhangshixi.iteye.com/blog/672697)\n\n- [ArrayList 和 LinkedList 各种遍历方式比较](http://www.trinea.cn/android/arraylist-linkedlist-loop-performance/)\n\n- Dalvik根据屏幕尺寸和密度决定应用程序的heap size，例如Android4.0.3的应用默认最小内存如下：\n![image](http://farm4.staticflickr.com/3686/9449083513_a56b59b17d_o.jpg)\n\n- ScrollView 只允许包含一个子 View\n\n- [TextView 添加链接](http://www.trinea.cn/android/textview-add-link/)\n\n- [Android应用如何开机自启动、自启动失败原因](http://www.trinea.cn/android/android-boot_completed-not-work/)\n\n- [关于Android线程优先级](http://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice/)\n\n- 有时候写的 BroadcastReceiver 中让线程 Thread.sleep(60*1000) 也不会出现 ANR，是因为确实发生了 ANR，只是没有弹窗而已，这种是 Background ANR，可以通过过滤日志验证，或者在开发者选项中勾选 \"显示应用程序无响应\" 对话框即可。\n\n- 在Java中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用。静态的内部类不会持有外部类的引用\n\n- [Handler引起的内存泄露](http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/?droid_refer=random_recommend)\n\n- [依赖注入](http://droidyue.com/blog/2015/06/13/talk-show-about-dependency-injection/?droid_refer=ninki_posts) 开始看这个名字的时候我还以为是安全性问题，读过文章之后才知道这是设计模式中依赖倒置的问题。先看段代码，看看有什么问题：\n\n```java\ninterface Energy {     \n}\n  \nclass GasEnergy implements Energy {\n}\n  \nclass Car {\n  Energy energy = new GasEnergy();\n}\n```\n\n采用组合依赖的形式本就是设计模式所推荐的，这无可厚非，可问题出现在直接 new 具体对象了，导致了耦合度增加，假如以后要修改具体对象类型了，此时还得修改 Car 类，这绝对不符合开闭原则，所以也就有了依赖注入，代码不写了，给三种方法：`构造器注入`,`Setters 方法注入`,`接口注入(接口里有 set 方法)`\n\n注入框架：\n（1）Guice采用的是运行时读取注解，通过反射的形式生成依赖并进行注入。这种形式不太适合Android移动设备，毕竟这些操作都在运行时处理，对性能要求较高。\n（2）Dagger则是Android开发适合的依赖注入库，其同样采用类注解的形式，不同的是它是在编译时生成辅助类，等到在运行时使用生成的辅助类完成依赖注入。\n\n- 我知道 Reader、Writer 字符流比 InputStream、OutputStream 多了一个缓存（缓冲）的特点，原来就是有些情况不调用 flush、close 的话不会将数据真正发送出去，才明白\n\n- [Android 系统设置中的清除数据究竟会清除哪些数据](http://droidyue.com/blog/2014/06/15/what-will-be-removed-if-you-click-clear-data-button-in-system-application-item/)\n\n- [申请权限支持设备不减少](http://droidyue.com/blog/2014/07/04/attentions-when-adding-permission-for-android-application/)\n\n- [Webview加载网页时发送HTTP头信息](http://droidyue.com/blog/2014/07/12/load-url-with-extra-header-in-android-webview-chinese-edition/)\n\n- [顶部带进度条的Webview](http://droidyue.com/blog/2014/07/12/ding-bu-dai-jin-du-tiao-de-webview/)\n\n- [捕获Android文本中链接点击事件](http://droidyue.com/blog/2014/07/27/capture-link-click-event-in-text-on-android/)\n\n- [超简单生成微博微信应用签名](http://droidyue.com/blog/2014/08/13/create-fignerprint-for-weibo-or-wechat-in-the-easiest-way/)\n\n- [终于可以使用Markdown写邮件啦](http://droidyue.com/blog/archives/)\n\n- [有关 Java 字符串的拼接](http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/)\n\n- [Android根据资源名获取资源ID](http://droidyue.com/blog/2014/09/12/get-resource-id-by-name-in-android/)\n\n- [Android中Java和JavaScript交互](http://droidyue.com/blog/2014/09/20/interaction-between-java-and-javascript-in-android/)\n\n- [细话Java：\"失效\"的private修饰符](http://droidyue.com/blog/2014/10/02/the-private-modifier-in-java/)\n\n- [Java 四种引用类型](http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/)\n\n- [糟糕的 AsyncTask](http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/)\n\n- [如何使用 Loaders](http://developer.android.com/intl/zh-cn/guide/components/loaders.html)\n\n- [Android 垃圾回收日志](http://droidyue.com/blog/2014/11/08/understanding-garbage-collection-output-messages-in-android/)\n\n- [自定义 Toast 自己实现下](http://droidyue.com/blog/2014/11/29/custom-toast-like-tencent-news-app/)\n\n- [Java 中堆和栈的区别 非常好的总结](http://droidyue.com/blog/2014/12/07/differences-between-stack-and-heap-in-java/)\n\n- [关于 subString() 引起的\"内存泄露\"](http://droidyue.com/blog/2014/12/14/substring-memory-issue-in-java/) \n\n- [JVM运行时的数据区](http://droidyue.com/blog/2014/12/21/java-runtime-data-areas/)\n\n- 字符串常量池中存储的是字符串引用，而不是字符串本身，因为在 Java 中，对象都创建在堆内存中，[参考文章](http://droidyue.com/blog/2014/12/21/string-literal-pool-in-java/)\n\n- 对于使用new创建的字符串，如果也想将其引用放到字符串常量池中，可以使用intern方法\n```\nString str4 = str3.intern();\nSystem.out.println(str4 == str1);\n```\n\n- [Java 中的动态绑定和静态绑定](http://droidyue.com/blog/2014/12/28/static-biding-and-dynamic-binding-in-java/)。可以简单理解就是，重载是静态绑定，覆写是动态绑定。[又一动态绑定](http://www.cnblogs.com/dolphin0520/p/3803432.html)\n\n- [单例模式双重加锁时也要记得给instace加上volatile](http://droidyue.com/blog/2015/01/11/looking-into-singleton/)。另外 IoDH 技术可以用静态内部类实现在类加载时对instance进行初始化，类似于 Holder。\n\n- [单例模式可以被打破](http://droidyue.com/blog/2015/01/11/looking-into-singleton/)\n\n- [AutoBoxing UnBoxing == 与 Integer缓存-128~127的坑](http://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/)\n\n- [Context 泄露](http://droidyue.com/blog/2015/04/12/avoid-memory-leaks-on-context-in-android/)。其中也说到了Drawable引起的内存泄露。\n\n- [关于 HttpUrlConnection 和 HttpClient 的区别](http://droidyue.com/blog/2015/05/30/android-http-clients/)\n\n- [关于 lint](http://droidyue.com/blog/2015/07/25/use-android-lint-to-find-higher-api-usage/)\n\n- android:sharedUserId是指共用一个uid\n\n- 大多数static的数据被mmapped到一个进程中。这不仅仅让同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被paged out。常见的static数据包括Dalvik Code、app resources、so文件等。\n\n- Bitmap decode format 解码格式的差异？\n\n- 利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率\n\n- [内存泄露](http://www.csdn.net/article/2015-09-18/2825737/4)\n\n- 谨慎使用static对象。因为static的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在Android中应该谨慎使用static对象\n![image](http://img.ptcms.csdn.net/article/201509/18/55fbe22546ba6.jpg)\n\n- [LeakCanary](http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/)\n\n- [MAT的使用](http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/)\n\n- [Android Performance 中文](http://androidperformance.com/)\n\n- [JobScheduler](http://developer.android.com/intl/zh-cn/reference/android/app/job/JobScheduler.html)\n\n- 如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。\n![image](http://hukai.me/images/android_perf_2_ondraw_paint.png)\n\n- [Strict Mode 防止出现ANR 第11部分](http://hukai.me/android-performance-patterns-season-2/) \n\n- 尽量使用ClipRect等方法来提高绘制的性能 ?\n\n- 执行延时任务的三种方式：AlarmManager、SyncAdapter、JobSchedulor\n\n- Android 图片解码格式\n![image](http://hukai.me/images/android_perf_2_pixel_format.png)\n\n- Android 图片解码率\n![image](http://hukai.me/images/android_perf_2_pixel_decode.png)\n\n- 一种新的图片格式：Webp，它是由Google推出的一种既保留png格式的优点，又能够减少图片大小的一种新型图片格式\n\n- 缩放Bitmap的几种方式比较\ncreateScaledBitmap(),这种方法能够快速得到一张经过缩放的图片，可是这个方法能够执行的前提是，原图片需要事先加载到内存中，如果原图片过大，很可能导致OOM；\ninSampleSize能够等比的缩放显示图片，同时还避免了需要先把原图加载进内存的缺点；\n![image](http://hukai.me/images/android_perf_2_sacle_bitmap_code.png)\n还可以使用inScaled，inDensity，inTargetDensity的属性来对图片解码做处理；\n![image](http://hukai.me/images/android_perf_2_sacle_bitmap_inscale.png)\n使用inJustDecodeBounds，可以事先获取到图片的大小而不至于占用内存。\n![image](http://hukai.me/images/android_perf_2_sacle_bitmap_injust.png)\n\n- inBitmap\n\n- Glide 库\n\n- 对象池？\n\n- [继承中的隐藏和覆盖](http://www.cnblogs.com/dolphin0520/p/3803432.html)\n\n- 单线程私有：程序计数器、JVM栈、本地方法栈\n  多线程共享：堆内存、方法区、运行时常量池\n\n- 子 View 可以通过调用 getParent().requestDisallowInterceptTouchEvent(true);  阻止 ViewGroup 对其 MOVE 或者 UP 事件进行拦截。\n\n- 产生 ANR 的前提是要有输入事件，如果用户没有触发任何输入事件，即便是主线程阻塞了，也不会产生 ANR，因为 InputDispatcher 没有分发事件给应用程序，当然也不会检测处理超时和报告ANR了。\n\n- 不会参与对象序列化的是：类的静态成员变量和 transient 关键字标记的。\n\n- 类 ServiceConnection 中的 onServiceDisconnected() 方法在正常情况下是不被调用的，它的调用时机是当 Service 服务被异外销毁时，例如内存的资源不足时这个方法才被自动调用。\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-08-28- 每日学习炸鸡","published":1,"updated":"2015-10-26T13:52:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynzb0023ek5xpbusnwhy"},{"layout":"post","title":"【视频教程】Android 开发实战：自动检测更新功能的实现","date":"2015-08-24T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n在当今的互联网环境下，APP 版本的迭代更新非常迅速，如何能在第一时间让用户体验到最新版本是开发者必须要考虑的问题。传统的应用市场固然可以实现程序更新的功能，但开发者不得不维护多个应用市场的版本信息，用户也不得不到应用市场进行更新。这也就要求我们，要尽量在程序内部实现自动检测更新的功能。 \n\n**核心内容**\n\n1.使用友盟 SDK 实现自动更新\n2.JSON 数据解析\n3.本地版本的检测\n4.对话框的使用\n5.网络下载文件\n6.本地安装 APK\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1607.html?hmsr=teacher_icodeyou_c1607)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_Android%20开发实战：自动检测更新功能的实现.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-08-24-【视频教程】Android 开发实战：自动检测更新功能的实现.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】Android 开发实战：自动检测更新功能的实现\"\ndate: 2015-08-24 15:20:33 +0800\ncomments: true\ntags: [极客学院, Android]\n---\n\n**课程背景**\n\n在当今的互联网环境下，APP 版本的迭代更新非常迅速，如何能在第一时间让用户体验到最新版本是开发者必须要考虑的问题。传统的应用市场固然可以实现程序更新的功能，但开发者不得不维护多个应用市场的版本信息，用户也不得不到应用市场进行更新。这也就要求我们，要尽量在程序内部实现自动检测更新的功能。 \n\n**核心内容**\n\n1.使用友盟 SDK 实现自动更新\n2.JSON 数据解析\n3.本地版本的检测\n4.对话框的使用\n5.网络下载文件\n6.本地安装 APK\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1607.html?hmsr=teacher_icodeyou_c1607)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_Android%20开发实战：自动检测更新功能的实现.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-08-24-【视频教程】Android 开发实战：自动检测更新功能的实现","published":1,"updated":"2015-08-24T10:30:06.000Z","photos":[],"link":"","_id":"ciw22ynzc0025ek5x4rggh3v3"},{"title":"mac工具--通过 arp 欺骗抓取局域网内设备数据包","date":"2015-08-23T14:18:44.000Z","_content":"\n\n使用 `Debookee` 抓取同局域网内设备数据包，太神奇了。\n\n<!--more-->\n\n因为有个需求，就是想看某手机app内部网络部分是如何实现的，所以要抓取其数据包（主要是 Http 协议部分），Windows 下可以用 Fidder 为手机设置代理实现，Mac 下有一款 `Debookee` 的软件可以实现同样的功能，但是原理不同 Fidder 设置代理。首先先看截图：\n\n这是扫出来的局域网内所有主机情况：\n\n![扫描主机列表](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_list.png)\n\n将目标主机设置为 target，此处是我的手机，然后再点击左上角的 `Start Dbk`，就会抓取到手机上的数据包，如图：\n\n![抓手机数据包](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_phone.png)\n\n很神奇，什么都不用设置，只要在 `Debookee` 上点几下，同个局域网中所有设备数据包我都能监控到了。基于什么原理呢？\n\n我的另一台 Samsung 电脑打开了 Wireshark 抓取数据包，发现 `Debookee` 只要一扫描或者对其抓包，就会有满屏幕的 ARP 欺骗--所以原理也就清楚了，是`基于 ARP 欺骗`的（感谢大哥教导），如图：\n\n![ARP 欺骗](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_arp.jpg)\n\n其实很简单，最后，视频演示下吧：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/debookeeDebookee.mp4\" controls=\"controls\"></video>\n</div>\n\n总的来说，这款工具非常好用！—— `Debookee`\n\n另外，还有另一种方式，即通过`设置中间代理`的方式来抓包，在我的这篇文章中有讲解 [Charles 的安装破解与使用](http://icodeyou.com/2015/08/30/2015-08-30-%20mac%E4%B8%8B%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7--Charles/)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-08-15- mac下抓包工具--Debookee.markdown","raw":"title: mac工具--通过 arp 欺骗抓取局域网内设备数据包\ndate: 2015-08-23 22:18:44\ntags: Mac\n---\n\n\n使用 `Debookee` 抓取同局域网内设备数据包，太神奇了。\n\n<!--more-->\n\n因为有个需求，就是想看某手机app内部网络部分是如何实现的，所以要抓取其数据包（主要是 Http 协议部分），Windows 下可以用 Fidder 为手机设置代理实现，Mac 下有一款 `Debookee` 的软件可以实现同样的功能，但是原理不同 Fidder 设置代理。首先先看截图：\n\n这是扫出来的局域网内所有主机情况：\n\n![扫描主机列表](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_list.png)\n\n将目标主机设置为 target，此处是我的手机，然后再点击左上角的 `Start Dbk`，就会抓取到手机上的数据包，如图：\n\n![抓手机数据包](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_phone.png)\n\n很神奇，什么都不用设置，只要在 `Debookee` 上点几下，同个局域网中所有设备数据包我都能监控到了。基于什么原理呢？\n\n我的另一台 Samsung 电脑打开了 Wireshark 抓取数据包，发现 `Debookee` 只要一扫描或者对其抓包，就会有满屏幕的 ARP 欺骗--所以原理也就清楚了，是`基于 ARP 欺骗`的（感谢大哥教导），如图：\n\n![ARP 欺骗](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_arp.jpg)\n\n其实很简单，最后，视频演示下吧：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/debookeeDebookee.mp4\" controls=\"controls\"></video>\n</div>\n\n总的来说，这款工具非常好用！—— `Debookee`\n\n另外，还有另一种方式，即通过`设置中间代理`的方式来抓包，在我的这篇文章中有讲解 [Charles 的安装破解与使用](http://icodeyou.com/2015/08/30/2015-08-30-%20mac%E4%B8%8B%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7--Charles/)\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-08-15- mac下抓包工具--Debookee","published":1,"updated":"2015-08-30T02:28:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22ynze0029ek5xrorp0fzy"},{"layout":"post","title":"设置 urllib 的访问超时时间","date":"2015-07-25T07:25:33.000Z","comments":1,"_content":"\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n```\n\n<!--more-->\n\n今天用了 python 的 urllib 库，主要是想编写 sql 基于时间的盲注脚本，要通过网络访问超时来进行异常捕获。`urllib2.openurl(url, timeout=1)` 可以直接设置超时时间，但是 urllib 并不能这样，解决方法：\n\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n```\n\n因为 urllib 是基于 socket 的，这样就设置了读取网络的超时时间为 5 秒，结合 try 来异常捕获的话，如下：\n\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n\n\ttry:\n        urllib.urlopen(url).read()\n    except:\n        some operation\n        pass\n```\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-07-25- python-urllib超时.markdown","raw":"---\nlayout: post\ntitle: \"设置 urllib 的访问超时时间\"\ndate: 2015-07-25 15:25:33 +0800\ncomments: true\ntags: Python\n---\n\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n```\n\n<!--more-->\n\n今天用了 python 的 urllib 库，主要是想编写 sql 基于时间的盲注脚本，要通过网络访问超时来进行异常捕获。`urllib2.openurl(url, timeout=1)` 可以直接设置超时时间，但是 urllib 并不能这样，解决方法：\n\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n```\n\n因为 urllib 是基于 socket 的，这样就设置了读取网络的超时时间为 5 秒，结合 try 来异常捕获的话，如下：\n\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n\n\ttry:\n        urllib.urlopen(url).read()\n    except:\n        some operation\n        pass\n```\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-07-25- python-urllib超时","published":1,"updated":"2015-08-24T10:23:54.000Z","photos":[],"link":"","_id":"ciw22ynzf002bek5xo0dzjhxy"},{"layout":"post","title":"【视频教程】网站登录模块开发安全加固","date":"2015-06-23T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n现今很多网站为了完成功能而使用明文传输或存储数据，这一不安全的做法使得敏感数据容易被窃听，从而造成隐私泄露。一次又一次的用户信息泄露事件警示我们应注重信息传输和存储的安全性，从而加固 Web 应用开发的安全性。\n\n**核心内容**\n\n1.使用 JSP+MySQL 编写登录模块\n2.在 MySQL 中使用 MD5 和 SHA1 对数据加密\n3.在 MySQL 中对数据进行加盐处理\n4.在浏览器端对数据进行摘要处理\n5.使用 WireShark 抓取分析数据包 \n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1424.html?hmsr=teacher_icodeyou_c1424)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_网站登录模块开发安全加固.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-06-23- 网站登录模块开发安全加固.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】网站登录模块开发安全加固\"\ndate: 2015-06-23 15:20:33 +0800\ncomments: true\ntags: [极客学院, 密码学, Java]\n---\n\n**课程背景**\n\n现今很多网站为了完成功能而使用明文传输或存储数据，这一不安全的做法使得敏感数据容易被窃听，从而造成隐私泄露。一次又一次的用户信息泄露事件警示我们应注重信息传输和存储的安全性，从而加固 Web 应用开发的安全性。\n\n**核心内容**\n\n1.使用 JSP+MySQL 编写登录模块\n2.在 MySQL 中使用 MD5 和 SHA1 对数据加密\n3.在 MySQL 中对数据进行加盐处理\n4.在浏览器端对数据进行摘要处理\n5.使用 WireShark 抓取分析数据包 \n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1424.html?hmsr=teacher_icodeyou_c1424)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_网站登录模块开发安全加固.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-06-23- 网站登录模块开发安全加固","published":1,"updated":"2015-08-24T10:41:40.000Z","photos":[],"link":"","_id":"ciw22ynzh002eek5xmrxtw6s3"},{"layout":"post","title":"【视频教程】网站登录模块开发安全加固","date":"2015-06-23T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n现今很多网站为了完成功能而使用明文传输或存储数据，这一不安全的做法使得敏感数据容易被窃听，从而造成隐私泄露。一次又一次的用户信息泄露事件警示我们应注重信息传输和存储的安全性，从而加固 Web 应用开发的安全性。\n\n**核心内容**\n\n1.使用 JSP+MySQL 编写登录模块\n2.在 MySQL 中使用 MD5 和 SHA1 对数据加密\n3.在 MySQL 中对数据进行加盐处理\n4.在浏览器端对数据进行摘要处理\n5.使用 WireShark 抓取分析数据包 \n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1424.html?hmsr=teacher_icodeyou_c1424)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_网站登录模块开发安全加固.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-06-23- 【视频教程】网站登录模块开发安全加固.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】网站登录模块开发安全加固\"\ndate: 2015-06-23 15:20:33 +0800\ncomments: true\ntags: [极客学院, 密码学, Java]\n---\n\n**课程背景**\n\n现今很多网站为了完成功能而使用明文传输或存储数据，这一不安全的做法使得敏感数据容易被窃听，从而造成隐私泄露。一次又一次的用户信息泄露事件警示我们应注重信息传输和存储的安全性，从而加固 Web 应用开发的安全性。\n\n**核心内容**\n\n1.使用 JSP+MySQL 编写登录模块\n2.在 MySQL 中使用 MD5 和 SHA1 对数据加密\n3.在 MySQL 中对数据进行加盐处理\n4.在浏览器端对数据进行摘要处理\n5.使用 WireShark 抓取分析数据包 \n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1424.html?hmsr=teacher_icodeyou_c1424)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_网站登录模块开发安全加固.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-06-23- 【视频教程】网站登录模块开发安全加固","published":1,"updated":"2015-08-24T10:39:17.000Z","photos":[],"link":"","_id":"ciw22ynzi002jek5xj5iip7ob"},{"layout":"post","title":"【视频教程】安全协议和认证服务","date":"2015-06-17T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n网站通信时既需要数字证书，也需要安全协议的支持。常用的 HTTPS 协议实际上是基于 SSL/TLS 的 HTTP 协议，即该位于传输层的 SSL/TLS 协议自身带有加密信息，提供给上层的应用层使用，以达到数据安全通信的目的。 \n\n**核心内容**\n\n1.安全协议的概念\n2.TLS 协议内容和通信模型\n3.基于 Tomcat 构建单双向认证服务  \n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1383.html?hmsr=teacher_icodeyou_c1383)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_安全协议和认证服务.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-06-17- 【视频教程】安全协议和认证服务.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】安全协议和认证服务\"\ndate: 2015-06-17 15:20:33 +0800\ncomments: true\ntags: [极客学院, 密码学, Java]\n---\n\n**课程背景**\n\n网站通信时既需要数字证书，也需要安全协议的支持。常用的 HTTPS 协议实际上是基于 SSL/TLS 的 HTTP 协议，即该位于传输层的 SSL/TLS 协议自身带有加密信息，提供给上层的应用层使用，以达到数据安全通信的目的。 \n\n**核心内容**\n\n1.安全协议的概念\n2.TLS 协议内容和通信模型\n3.基于 Tomcat 构建单双向认证服务  \n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1383.html?hmsr=teacher_icodeyou_c1383)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_安全协议和认证服务.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-06-17- 【视频教程】安全协议和认证服务","published":1,"updated":"2015-08-24T10:39:06.000Z","photos":[],"link":"","_id":"ciw22ynzk002nek5x8u06ym4b"},{"layout":"post","title":"【视频教程】典型 TCP 攻击实验","date":"2015-06-10T07:25:33.000Z","comments":1,"_content":"\n记录典型 TCP 攻击实验的原理及操作步骤。\n\n<!--more-->\n\n在本次实验中，启用了三个虚拟机，处于同一子网中。同时使用了 Wireshark 来进行网络抓包分析，使用 netwox 工具箱来进行攻击实验。\n\n1.ARP缓存中毒（ARP cache poisoning）\n\nARP 缓存是 ARP 协议的重要组成部分。ARP 协议运行的目标就是建立 MAC 地址和 IP 地址的映射，然后把这一映射关系保存在 ARP 缓存中，使得不必重复运行 ARP 协议。因为 ARP 缓存中的映射表并不是一直不变的，主机会定期发送 ARP 请求来更新它的 ARP 映射表，利用这个机制，攻击者可以伪造 ARP 应答帧使得主机错误的更新自己的 ARP 映射表，这个过程就是 ARP 缓存中毒。\n\n这样的后果即使要么使主机发送 MAC 帧到错误的 MAC 地址，导致数据被窃听；要么由于 MAC 地址不存在，导致数据发送不成功。\n\n关键 netwox 命令:\n\n`netwox 80 --eth \"00:00:00:00:00:00\" --ip \"192.168.224.134\"` 表示 发送 ARP 的响应包，Wireshark 抓包如下：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_01arp.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_01ARP_cache_poisoning.mp4\" controls=\"controls\"></video>\n</div>\n\n2.SYN 泛洪攻击\n\nSYN 攻击是一种 DoS（Denial of Service）攻击，在这种攻击中黑客向被攻击者的 TCP 端口发送很多 SYN 请求，但是黑客并不是想完成三次握手协议，而是使用伪造的 IP 地址或者只进行三次握手协议中的第一次握手。因为 SYN 数据包用来打开一个 TCP 链接，所以受害者的机器会向伪造的地址发送一个 SYN/ACK 数据包作为回应，并等待预期的 ACK 响应。每个处于等待状态，半开的链接队列都讲进入空间有限的待处理队列。由于伪造的源地址实际上并不存在，所以将那些等待队列中的记录删除并完成建立 TCP 连接所需的 ACK 响应用于不会到来，相反每个半开的连接一定会超时，这将花费一段比较长的时间。\n\n只要攻击者使用伪造的 SYN 数据包继续泛洪受害者的系统，受害者的待处理队列将一直处于满员，这使得真正的 SYN 数据包几乎不可能到达系统并打开有效的 TCP 连接。\n\n关键 netwox 命令:\n\n`netwox 76 -i \"192.168.224.134\" -p \"23\"` 代表向目标主机的23号端口发送大量 TCP 连接请求，目标主机连接请求如图：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_03synflooding.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_03SYN_Flooding_Attack.mp4\" controls=\"controls\"></video>\n</div>\n\n3.对 Telnet 的 TCP RST 攻击\n\nTCP RST 攻击可以终止两个被攻击主机之间的 TCP 连接。\n\nA和服务器B之间建立了 TCP 连接，此时C伪造了一个 TCP 包发给B，使B异常的断开了与A之间的 TCP 连接，就是 RST 攻击了。实际上从RST 标志位的功能已经可以看出这种攻击如何达到效果了。\n\n关键 netwox 命令:\n\n`netwox 78 -i \"192.168.224.138\"` 代表向目标主机发送 TCP RST 数据包，使其中断 telnet 连接：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_04tcprst.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_04TCP_RST.mp4\" controls=\"controls\"></video>\n</div>\n\n最后，感谢 静姐 提供 [知道创宇研发技能表](http://blog.knownsec.com/Knownsec_RD_Checklist/v2.2.html)！\n\n\n###个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-06-10- 典型tcp攻击实验.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】典型 TCP 攻击实验\"\ndate: 2015-06-10 15:25:33 +0800\ncomments: true\ntags: [TCP, netwox]\n---\n\n记录典型 TCP 攻击实验的原理及操作步骤。\n\n<!--more-->\n\n在本次实验中，启用了三个虚拟机，处于同一子网中。同时使用了 Wireshark 来进行网络抓包分析，使用 netwox 工具箱来进行攻击实验。\n\n1.ARP缓存中毒（ARP cache poisoning）\n\nARP 缓存是 ARP 协议的重要组成部分。ARP 协议运行的目标就是建立 MAC 地址和 IP 地址的映射，然后把这一映射关系保存在 ARP 缓存中，使得不必重复运行 ARP 协议。因为 ARP 缓存中的映射表并不是一直不变的，主机会定期发送 ARP 请求来更新它的 ARP 映射表，利用这个机制，攻击者可以伪造 ARP 应答帧使得主机错误的更新自己的 ARP 映射表，这个过程就是 ARP 缓存中毒。\n\n这样的后果即使要么使主机发送 MAC 帧到错误的 MAC 地址，导致数据被窃听；要么由于 MAC 地址不存在，导致数据发送不成功。\n\n关键 netwox 命令:\n\n`netwox 80 --eth \"00:00:00:00:00:00\" --ip \"192.168.224.134\"` 表示 发送 ARP 的响应包，Wireshark 抓包如下：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_01arp.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_01ARP_cache_poisoning.mp4\" controls=\"controls\"></video>\n</div>\n\n2.SYN 泛洪攻击\n\nSYN 攻击是一种 DoS（Denial of Service）攻击，在这种攻击中黑客向被攻击者的 TCP 端口发送很多 SYN 请求，但是黑客并不是想完成三次握手协议，而是使用伪造的 IP 地址或者只进行三次握手协议中的第一次握手。因为 SYN 数据包用来打开一个 TCP 链接，所以受害者的机器会向伪造的地址发送一个 SYN/ACK 数据包作为回应，并等待预期的 ACK 响应。每个处于等待状态，半开的链接队列都讲进入空间有限的待处理队列。由于伪造的源地址实际上并不存在，所以将那些等待队列中的记录删除并完成建立 TCP 连接所需的 ACK 响应用于不会到来，相反每个半开的连接一定会超时，这将花费一段比较长的时间。\n\n只要攻击者使用伪造的 SYN 数据包继续泛洪受害者的系统，受害者的待处理队列将一直处于满员，这使得真正的 SYN 数据包几乎不可能到达系统并打开有效的 TCP 连接。\n\n关键 netwox 命令:\n\n`netwox 76 -i \"192.168.224.134\" -p \"23\"` 代表向目标主机的23号端口发送大量 TCP 连接请求，目标主机连接请求如图：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_03synflooding.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_03SYN_Flooding_Attack.mp4\" controls=\"controls\"></video>\n</div>\n\n3.对 Telnet 的 TCP RST 攻击\n\nTCP RST 攻击可以终止两个被攻击主机之间的 TCP 连接。\n\nA和服务器B之间建立了 TCP 连接，此时C伪造了一个 TCP 包发给B，使B异常的断开了与A之间的 TCP 连接，就是 RST 攻击了。实际上从RST 标志位的功能已经可以看出这种攻击如何达到效果了。\n\n关键 netwox 命令:\n\n`netwox 78 -i \"192.168.224.138\"` 代表向目标主机发送 TCP RST 数据包，使其中断 telnet 连接：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_04tcprst.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_04TCP_RST.mp4\" controls=\"controls\"></video>\n</div>\n\n最后，感谢 静姐 提供 [知道创宇研发技能表](http://blog.knownsec.com/Knownsec_RD_Checklist/v2.2.html)！\n\n\n###个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-06-10- 典型tcp攻击实验","published":1,"updated":"2015-08-24T10:29:27.000Z","photos":[],"link":"","_id":"ciw22ynzl002rek5x9jno8hgb"},{"layout":"post","title":"Ubuntu 下安装好 Wireshark 却找不到 Interface 的解决办法","date":"2015-06-10T07:25:33.000Z","comments":1,"_content":"\n今天在做网络攻防时需要在 Ubuntu 中使用 Wireshark 来抓取观察网络数据包，也就有了这篇文章。\n\n<!--more-->\n\n注：本篇文章非原创，部分内容参考：[http://www.94cat.com/blog/?p=1107](http://www.94cat.com/blog/?p=1107)\n\n1.安装 Wireshark\n\tUbuntu 下安装 Wireshark 的话直接从`软件中心`搜索安装即可\n\n2.启动 Wireshark\n\t直接启动 Wireshark 的话会发现 Interface 列表里为空（如果有蓝牙模块，会显示一个蓝牙的），可以使用 `sudo wireshark` 来启动，会有个错误信息，显示 Load Error，但是 Interface 正常，也可以正常使用，但不推荐这种做法。\n\n**3.推荐的方法--使用用户组功能使用 Wireshark**\n\n- 添加用户组，此处以 `wireshark` 用户组为例\n```\nsudo groupadd wireshark\n```\n\n- 将 dumpcap 更改为 wireshark 用户组\n```\nsudo chgrp wireshark /usr/bin/dumpcap\n```\n\n- 让 wireshark 用户组有 root 权限使用 dumpcap\n```\nsudo chmod 4755 /usr/bin/dumpcap\n```\n(PS:4754 Wireshark 还是会提示没有权限 )\n\n- 将当前用户加入 wireshark 用户组，我的用户是 `huan`，你添加需要更改这个。\n```\nsudo gpasswd -a huan wireshark\n```\n\n这样就完成了，你可以使用自己的用户打开 Wireshark，能够看到所有 Interface，并且有权限进行操作了。\n\n###个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-06-10- wireshark找不到interface.markdown","raw":"---\nlayout: post\ntitle: \"Ubuntu 下安装好 Wireshark 却找不到 Interface 的解决办法\"\ndate: 2015-06-10 15:25:33 +0800\ncomments: true\ntags: [Linux, Wireshark]\n---\n\n今天在做网络攻防时需要在 Ubuntu 中使用 Wireshark 来抓取观察网络数据包，也就有了这篇文章。\n\n<!--more-->\n\n注：本篇文章非原创，部分内容参考：[http://www.94cat.com/blog/?p=1107](http://www.94cat.com/blog/?p=1107)\n\n1.安装 Wireshark\n\tUbuntu 下安装 Wireshark 的话直接从`软件中心`搜索安装即可\n\n2.启动 Wireshark\n\t直接启动 Wireshark 的话会发现 Interface 列表里为空（如果有蓝牙模块，会显示一个蓝牙的），可以使用 `sudo wireshark` 来启动，会有个错误信息，显示 Load Error，但是 Interface 正常，也可以正常使用，但不推荐这种做法。\n\n**3.推荐的方法--使用用户组功能使用 Wireshark**\n\n- 添加用户组，此处以 `wireshark` 用户组为例\n```\nsudo groupadd wireshark\n```\n\n- 将 dumpcap 更改为 wireshark 用户组\n```\nsudo chgrp wireshark /usr/bin/dumpcap\n```\n\n- 让 wireshark 用户组有 root 权限使用 dumpcap\n```\nsudo chmod 4755 /usr/bin/dumpcap\n```\n(PS:4754 Wireshark 还是会提示没有权限 )\n\n- 将当前用户加入 wireshark 用户组，我的用户是 `huan`，你添加需要更改这个。\n```\nsudo gpasswd -a huan wireshark\n```\n\n这样就完成了，你可以使用自己的用户打开 Wireshark，能够看到所有 Interface，并且有权限进行操作了。\n\n###个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-06-10- wireshark找不到interface","published":1,"updated":"2015-08-24T10:29:46.000Z","photos":[],"link":"","_id":"ciw22ynzo002wek5xn2uds239"},{"layout":"post","title":"Android 窃取手机中微信聊天记录","date":"2015-06-05T07:25:33.000Z","comments":1,"_content":"\n关于如何在 Android 手机上窃取微信聊天记录。\n\n<!--more-->\n\n这几天事情比较多，可还是想尽快写下这篇文章。\n\n本以为微信的聊天记录以我本人现存能力获取不到，但经过一番尝试，还是成功了。前提：手机需要已经 `root`。\n\n在我的直觉里，微信的聊天记录一定会是加密的，而且是用了现代密码学中的加密算法，只要官方保存好密钥那么我等平民不可能获取得到。而接下来，我想说的是我等平民如何能够获取到微信的所有聊天记录。\n\n一般来说，Android 应用程序的数据库文件会保存在 `/data/data/packagename/database` 文件夹下，而微信稍稍有些不同，但也不难发现其数据库文件保存位置，位于：`/data/data/com.tencent.mm/MicroMsg` 路径下，注意这里有两个像是乱码的很长名字的文件夹，这两个文件夹正是用户的个人信息保存的位置（我这里有两个，估计是之前谁用我的手机登录过微信。。。），再看这个文件夹里面有一个很显眼的数据库文件 **`EnMicroMsg.db`** ，凭猜测也可以感觉到前缀 En 应该是 Encrypt 的缩写，果然，用 SQLite Professional 打开提示该数据库文件被加密，具体如下几幅图\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx1.png)\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx2.png)\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx3.png)\n\n说实话，给 SQLite 加密，我还是第一次遇到。于是放狗搜，发现有一个软件叫做 sqlcipher.exe，在有密钥的情况下可以打开被加密的 db 文件（这个软件国内很难找，我放在了我的七牛云存储上，[点此下载](http://7xivx9.com1.z0.glb.clouddn.com/wxsqlcipher.exe)）。那么问题来了，密钥是什么？\n\n不懂微信为何要这样做，密钥是当前手机的 `IMEI + 微信UIN 的 MD5值（32位小写）前7位`。（注：此处信息不是自己发现的，是无意中在网上搜到的）分别说如何获得如上内容：\n\n- 获取 IMEI 码 : \n\t手机拨号输入 `*#06#`  显示出来的即是所需 IMEI\n- 获取微信 UIN 码 : \n\t相信大家都用过微信的网页版，我们就通过它来获取。首先登录微信版网页，再新建一个标签页 `chrome://net-internals/#events`，这个是 chrome 内置的抓包工具，所有进出的数据包都能看到，所以类似于下面这样\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx4.png)\n\t\n之后在网页聊天界面随意给某个联系人发送一条消息，回到抓包标签页，按 Ctrl + F 全局搜索 `uin` ，这个时候就会看到下图中的 uin 码，我这里是 9 位\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx5.png)\n\t\n到此为止，我们获取了设备的 IMEI(如12345) 和 微信账号的 UIN(如67890) 码，下面来计算 `32 位 MD5 消息摘要值`，使用 [MD5](http://md5jiami.51240.com/) 在线加密的网站就可以，则要加密的字符串为 `IMEI+UIN`，即 `1234567890`，加密后就会得到四种 MD5 值，我们需要的是32位长度小写的，如图\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx6.png)\n\n取该 `MD5 值前 7 位`，即为密钥。接下来，打开 sqlcipher.exe ，File->Open Database， 选择 EnMicroMsg.db 文件，打开后就可以看到让我们输入密钥，输入刚才的7位密钥，点击OK，如图\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx7.png)\n\n如果你成功看到了下图的界面，则说明99%已经成功了。\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx8.png)\n\n那如何能看到真正的聊天记录内容呢，点击 Browse Data，再筛选 message ，看吧，赤裸裸的聊天记录赫然摆在眼前。。。\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx10.png)\n\n**最后，想跟各位说的是，手机千万不要交给程序员。。。**\n\n###个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","source":"_posts/2015-06-05- 获取微信聊天记录.markdown","raw":"---\nlayout: post\ntitle: \"Android 窃取手机中微信聊天记录\"\ndate: 2015-06-05 15:25:33 +0800\ncomments: true\ntags: Android\n---\n\n关于如何在 Android 手机上窃取微信聊天记录。\n\n<!--more-->\n\n这几天事情比较多，可还是想尽快写下这篇文章。\n\n本以为微信的聊天记录以我本人现存能力获取不到，但经过一番尝试，还是成功了。前提：手机需要已经 `root`。\n\n在我的直觉里，微信的聊天记录一定会是加密的，而且是用了现代密码学中的加密算法，只要官方保存好密钥那么我等平民不可能获取得到。而接下来，我想说的是我等平民如何能够获取到微信的所有聊天记录。\n\n一般来说，Android 应用程序的数据库文件会保存在 `/data/data/packagename/database` 文件夹下，而微信稍稍有些不同，但也不难发现其数据库文件保存位置，位于：`/data/data/com.tencent.mm/MicroMsg` 路径下，注意这里有两个像是乱码的很长名字的文件夹，这两个文件夹正是用户的个人信息保存的位置（我这里有两个，估计是之前谁用我的手机登录过微信。。。），再看这个文件夹里面有一个很显眼的数据库文件 **`EnMicroMsg.db`** ，凭猜测也可以感觉到前缀 En 应该是 Encrypt 的缩写，果然，用 SQLite Professional 打开提示该数据库文件被加密，具体如下几幅图\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx1.png)\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx2.png)\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx3.png)\n\n说实话，给 SQLite 加密，我还是第一次遇到。于是放狗搜，发现有一个软件叫做 sqlcipher.exe，在有密钥的情况下可以打开被加密的 db 文件（这个软件国内很难找，我放在了我的七牛云存储上，[点此下载](http://7xivx9.com1.z0.glb.clouddn.com/wxsqlcipher.exe)）。那么问题来了，密钥是什么？\n\n不懂微信为何要这样做，密钥是当前手机的 `IMEI + 微信UIN 的 MD5值（32位小写）前7位`。（注：此处信息不是自己发现的，是无意中在网上搜到的）分别说如何获得如上内容：\n\n- 获取 IMEI 码 : \n\t手机拨号输入 `*#06#`  显示出来的即是所需 IMEI\n- 获取微信 UIN 码 : \n\t相信大家都用过微信的网页版，我们就通过它来获取。首先登录微信版网页，再新建一个标签页 `chrome://net-internals/#events`，这个是 chrome 内置的抓包工具，所有进出的数据包都能看到，所以类似于下面这样\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx4.png)\n\t\n之后在网页聊天界面随意给某个联系人发送一条消息，回到抓包标签页，按 Ctrl + F 全局搜索 `uin` ，这个时候就会看到下图中的 uin 码，我这里是 9 位\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx5.png)\n\t\n到此为止，我们获取了设备的 IMEI(如12345) 和 微信账号的 UIN(如67890) 码，下面来计算 `32 位 MD5 消息摘要值`，使用 [MD5](http://md5jiami.51240.com/) 在线加密的网站就可以，则要加密的字符串为 `IMEI+UIN`，即 `1234567890`，加密后就会得到四种 MD5 值，我们需要的是32位长度小写的，如图\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx6.png)\n\n取该 `MD5 值前 7 位`，即为密钥。接下来，打开 sqlcipher.exe ，File->Open Database， 选择 EnMicroMsg.db 文件，打开后就可以看到让我们输入密钥，输入刚才的7位密钥，点击OK，如图\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx7.png)\n\n如果你成功看到了下图的界面，则说明99%已经成功了。\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx8.png)\n\n那如何能看到真正的聊天记录内容呢，点击 Browse Data，再筛选 message ，看吧，赤裸裸的聊天记录赫然摆在眼前。。。\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxwx10.png)\n\n**最后，想跟各位说的是，手机千万不要交给程序员。。。**\n\n###个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n","slug":"2015-06-05- 获取微信聊天记录","published":1,"updated":"2015-08-24T10:29:04.000Z","photos":[],"link":"","_id":"ciw22ynzp0031ek5xmdlohhcq"},{"layout":"post","title":"今天第一次给女生撑伞是不是应该在我的技术博客里记录一下","date":"2015-06-05T07:25:33.000Z","comments":1,"_content":"\n给女生撑伞还真是个技术活\n\n<!--more-->\n\n第一次给女生撑伞比编程还难，关键还不能 Debug，一有错误直接抛异常，还 catch 不住。\n\n所以，给女生撑伞还真是个技术活，正应该写在技术博客里让自己不断反省进步不是吗？\n\n--update at 2015.11.19\n\n今天又给她撑伞了，确实有很大进步，看来写博客确实是个能让程序员不断进步的方法。","source":"_posts/2015-06-05- helen.markdown","raw":"---\nlayout: post\ntitle: \"今天第一次给女生撑伞是不是应该在我的技术博客里记录一下\"\ndate: 2015-06-05 15:25:33 +0800\ncomments: true\ntags: icodeyou\n---\n\n给女生撑伞还真是个技术活\n\n<!--more-->\n\n第一次给女生撑伞比编程还难，关键还不能 Debug，一有错误直接抛异常，还 catch 不住。\n\n所以，给女生撑伞还真是个技术活，正应该写在技术博客里让自己不断反省进步不是吗？\n\n--update at 2015.11.19\n\n今天又给她撑伞了，确实有很大进步，看来写博客确实是个能让程序员不断进步的方法。","slug":"2015-06-05- helen","published":1,"updated":"2015-11-29T07:17:33.000Z","photos":[],"link":"","_id":"ciw22ynzr0033ek5xkl0c4bgl"},{"layout":"post","title":"【视频教程】证书的概念和使用","date":"2015-06-04T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n无论是公钥密码还是数字签名，其中公钥都扮演了重要的角色。然而，如果不能判断自己手上的公钥是否合法，就有可能遭到中间人攻击。为了应对此种情况，就需要使用证书技术对公钥的合法性提供证明。\n\n**核心内容**\n\n* 证书的概念和应用场景\n* 公钥基础设施的概念和作用\n* 使用 VeriSign 服务生成证书\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1271.html?hmsr=teacher_icodeyou_c1271)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_证书的概念和使用.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-06-04-【视频教程】证书的概念和使用.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】证书的概念和使用\"\ndate: 2015-06-04 15:20:33 +0800\ncomments: true\ntags: [极客学院, 密码学, Java]\n---\n\n**课程背景**\n\n无论是公钥密码还是数字签名，其中公钥都扮演了重要的角色。然而，如果不能判断自己手上的公钥是否合法，就有可能遭到中间人攻击。为了应对此种情况，就需要使用证书技术对公钥的合法性提供证明。\n\n**核心内容**\n\n* 证书的概念和应用场景\n* 公钥基础设施的概念和作用\n* 使用 VeriSign 服务生成证书\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1271.html?hmsr=teacher_icodeyou_c1271)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_证书的概念和使用.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-06-04-【视频教程】证书的概念和使用","published":1,"updated":"2015-08-24T10:28:26.000Z","photos":[],"link":"","_id":"ciw22ynzs0035ek5x5o89d1px"},{"layout":"post","title":"【视频教程】数字签名的编程使用","date":"2015-06-02T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n数字签名算法是公钥基础设施（PKI）以及许多网络安全机制（SSL/TLS、VPN等）的基础，能够验证数据完整性、认证数据来源、并起到抗否认的作用。同时，数字签名算法可以看做是一种带有密钥的消息摘要算法，并且这种密钥包含了公钥和私钥，也就是说，数字签名算法是非对称加密算法和消息摘要算法的结合体。\n\n**核心内容**\n\n* 数字签名概述\n* RSASignature 算法的编程使用\n* DSASignature 算法的编程使用 \n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1239.html?hmsr=teacher_icodeyou_c1239)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_数字签名的编程使用.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-06-02-【视频教程】数字签名的编程使用.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】数字签名的编程使用\"\ndate: 2015-06-02 15:20:33 +0800\ncomments: true\ntags: [极客学院, 密码学, Java]\n---\n\n**课程背景**\n\n数字签名算法是公钥基础设施（PKI）以及许多网络安全机制（SSL/TLS、VPN等）的基础，能够验证数据完整性、认证数据来源、并起到抗否认的作用。同时，数字签名算法可以看做是一种带有密钥的消息摘要算法，并且这种密钥包含了公钥和私钥，也就是说，数字签名算法是非对称加密算法和消息摘要算法的结合体。\n\n**核心内容**\n\n* 数字签名概述\n* RSASignature 算法的编程使用\n* DSASignature 算法的编程使用 \n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/1239.html?hmsr=teacher_icodeyou_c1239)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_数字签名的编程使用.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-06-02-【视频教程】数字签名的编程使用","published":1,"updated":"2015-08-24T10:28:20.000Z","photos":[],"link":"","_id":"ciw22ynzu0039ek5xghlhx5mh"},{"layout":"post","title":"【视频教程】非对称密码的编程使用","date":"2015-05-21T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n相比于对称密码算法的的单钥体系，非对称密码算法的双钥体系更为安全，且不再存在密钥管理问题，往往应用在一些安全性要求相当高的领域，比如 B2C、B2B 等电子商务平台。\n\n**核心内容**\n\n* 非对称密码概述\n* DH 算法的编程使用\n* RSA 算法的编程使用\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/932.html?hmsr=teacher_icodeyou_c932)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_非对称密码的编程使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-05-21-【视频教程】非对称密码的编程使用.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】非对称密码的编程使用\"\ndate: 2015-05-21 15:20:33 +0800\ncomments: true\ntags: [极客学院, 密码学, Java]\n---\n\n**课程背景**\n\n相比于对称密码算法的的单钥体系，非对称密码算法的双钥体系更为安全，且不再存在密钥管理问题，往往应用在一些安全性要求相当高的领域，比如 B2C、B2B 等电子商务平台。\n\n**核心内容**\n\n* 非对称密码概述\n* DH 算法的编程使用\n* RSA 算法的编程使用\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/932.html?hmsr=teacher_icodeyou_c932)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_非对称密码的编程使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-05-21-【视频教程】非对称密码的编程使用","published":1,"updated":"2015-08-24T10:28:15.000Z","photos":[],"link":"","_id":"ciw22ynzw003dek5x9qjqu0q7"},{"layout":"post","title":"Android常用网络请求框架的使用","date":"2015-05-03T07:25:33.000Z","comments":1,"_content":"\n此篇待更新\n\n<!--more-->\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-05-15- Android常用网络请求框架的使用.markdown","raw":"---\nlayout: post\ntitle: \"Android常用网络请求框架的使用\"\ndate: 2015-05-03 15:25:33 +0800\ncomments: true\ntags: Android\n---\n\n此篇待更新\n\n<!--more-->\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-05-15- Android常用网络请求框架的使用","published":1,"updated":"2015-08-24T10:28:56.000Z","photos":[],"link":"","_id":"ciw22ynzx003hek5xqxhongxr"},{"layout":"post","title":"【视频教程】Octopress 搭建静态博客网站","date":"2015-05-13T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n在IT领域，很多大牛通过写博客来分享自己的成果，让更多的人能够学习；在面试时，一个有高质量博客的程序员也会更加受到青睐。对于IT人来说，写博客这件事很重要，同时用什么方式来写更能体现一个人的水平。在此，我们弃用传统的 Wordpress，而真正使用程序员的方式来写属于我们自己的博客。\n\n**核心内容**\n\n* Git 与 GitHub 的基本使用\n* 使用 Ruby 结合 Octopress 生成静态网站\n* 使用 Markdown 语法写博客\n* 自定义 Octopress\n* 发布网站至 Github\n* 配置网站的自定义域名\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/887.html?hmsr=teacher_icodeyou_c887)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_Octopress 搭建静态博客网站.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-05-13-【视频教程】Octopress 搭建静态博客网站.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】Octopress 搭建静态博客网站\"\ndate: 2015-05-13 15:20:33 +0800\ncomments: true\ntags: [极客学院, Octopress]\n---\n\n**课程背景**\n\n在IT领域，很多大牛通过写博客来分享自己的成果，让更多的人能够学习；在面试时，一个有高质量博客的程序员也会更加受到青睐。对于IT人来说，写博客这件事很重要，同时用什么方式来写更能体现一个人的水平。在此，我们弃用传统的 Wordpress，而真正使用程序员的方式来写属于我们自己的博客。\n\n**核心内容**\n\n* Git 与 GitHub 的基本使用\n* 使用 Ruby 结合 Octopress 生成静态网站\n* 使用 Markdown 语法写博客\n* 自定义 Octopress\n* 发布网站至 Github\n* 配置网站的自定义域名\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/887.html?hmsr=teacher_icodeyou_c887)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_Octopress 搭建静态博客网站.mp4\" controls=\"controls\"></video>\n</div>\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-05-13-【视频教程】Octopress 搭建静态博客网站","published":1,"updated":"2015-08-24T10:28:49.000Z","photos":[],"link":"","_id":"ciw22ynzz003jek5xkqedqwhl"},{"layout":"post","title":"【视频教程】对称密码的编程使用","date":"2015-05-04T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n对称密码算法是当今应用范围最广，使用频率最高的加密算法。它不仅应用于软件行业，在硬件行业同样流行。各种基础设施凡是涉及到安全需求，都会优先考虑对称加密算法。\n\n**核心内容**\n\n* 对称密码概述\n* DES 算法的编程使用\n* 3DES 算法的编程使用\n* AES 算法的编程使用\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/833.html?hmsr=teacher_icodeyou_c833)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_对称密码的编程使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-05-04-【视频教程】对称密码的编程使用.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】对称密码的编程使用\"\ndate: 2015-05-04 15:20:33 +0800\ncomments: true\ntags: [极客学院, 密码学, Java]\n---\n\n**课程背景**\n\n对称密码算法是当今应用范围最广，使用频率最高的加密算法。它不仅应用于软件行业，在硬件行业同样流行。各种基础设施凡是涉及到安全需求，都会优先考虑对称加密算法。\n\n**核心内容**\n\n* 对称密码概述\n* DES 算法的编程使用\n* 3DES 算法的编程使用\n* AES 算法的编程使用\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/833.html?hmsr=teacher_icodeyou_c833)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_对称密码的编程使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-05-04-【视频教程】对称密码的编程使用","published":1,"updated":"2015-08-24T10:28:09.000Z","photos":[],"link":"","_id":"ciw22yo01003nek5xex8t6l7l"},{"layout":"post","title":"Ubuntu12.04 管理员无法登录桌面，只能guest登录","date":"2015-05-03T07:25:33.000Z","comments":1,"_content":"\n今天使用Ubuntu的时候遇到了一个问题，在登录界面输入正确的管理员密码后却无法登录到桌面，一直在那里循环，访客模式就可以登录进桌面，网上查了一下，找到了解决办法。\n\n<!--more-->\n\n解决办法步骤如下：\n\n- 在登录界面按下  `Ctrl + Alt + F1` 切换到tty， 输入管理员账号和密码\n- 输入 `sudo rm -r .Xauthority*`\n- 输入 `sudo reboot`\n\nOK，解决~\n\n截图如下：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/Ubuntu1204.png)\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-05-03- Ubuntu1204无法登录桌面.markdown","raw":"---\nlayout: post\ntitle: \"Ubuntu12.04 管理员无法登录桌面，只能guest登录\"\ndate: 2015-05-03 15:25:33 +0800\ncomments: true\ntags: Linux\n---\n\n今天使用Ubuntu的时候遇到了一个问题，在登录界面输入正确的管理员密码后却无法登录到桌面，一直在那里循环，访客模式就可以登录进桌面，网上查了一下，找到了解决办法。\n\n<!--more-->\n\n解决办法步骤如下：\n\n- 在登录界面按下  `Ctrl + Alt + F1` 切换到tty， 输入管理员账号和密码\n- 输入 `sudo rm -r .Xauthority*`\n- 输入 `sudo reboot`\n\nOK，解决~\n\n截图如下：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/Ubuntu1204.png)\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-05-03- Ubuntu1204无法登录桌面","published":1,"updated":"2015-08-24T10:28:35.000Z","photos":[],"link":"","_id":"ciw22yo05003rek5xjwwbnsvg"},{"layout":"post","title":"【视频教程】消息摘要的编程使用","date":"2015-04-28T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n当在互联网上传输文件时，偶尔也会有遇到传输文件损坏的情况，严重时，还可能从某软件的官网上下载到被篡改的文件。如何来验证下载到的文件和官方提供的源文件是否一致，此时需要使用消息摘要进行对比。\n\n**核心内容**\n\n* 消息摘要的概念、种类和作用\n* MD 类消息摘要的编程使用\n* SHA 类消息摘要的编程使用\n* HMAC 消息摘要的编程使用\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/804.html?hmsr=teacher_icodeyou_c804)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_消息摘要的编程使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-04-28-【视频教程】消息摘要的编程使用.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】消息摘要的编程使用\"\ndate: 2015-04-28 15:20:33 +0800\ncomments: true\ntags: [极客学院, 密码学, Java]\n---\n\n**课程背景**\n\n当在互联网上传输文件时，偶尔也会有遇到传输文件损坏的情况，严重时，还可能从某软件的官网上下载到被篡改的文件。如何来验证下载到的文件和官方提供的源文件是否一致，此时需要使用消息摘要进行对比。\n\n**核心内容**\n\n* 消息摘要的概念、种类和作用\n* MD 类消息摘要的编程使用\n* SHA 类消息摘要的编程使用\n* HMAC 消息摘要的编程使用\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/804.html?hmsr=teacher_icodeyou_c804)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_消息摘要的编程使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-04-28-【视频教程】消息摘要的编程使用","published":1,"updated":"2015-08-24T10:28:01.000Z","photos":[],"link":"","_id":"ciw22yo06003tek5x79muv858"},{"title":"算法之数组","date":"2015-04-18T14:18:44.000Z","_content":"\n数组的常见算法题，记录一下，以备忘。\n\n<!--more-->\n\n1、整型数组的逆置算法\n\n2、旋转数组\n   For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]。\n```\n\treverse(array, 0, n-k-1); // 反转前一半\n\treverse(array, n-k, n-1); // 反转后一半\n\treverse(array, 0, n-1);   // 反转整个数组\t\n```\n\n3、排序数组中和为 s 的两个数字\n   头尾两个指针相加，根据和的大小前后移动。也可以只用一个指针，在该指针后面的数组用二分查找看有没有满足要求的数『 mid = (low + high) >>> 1 』。\n\n4、和为 s 的连续正整数序列\n   两个指针，一个从1开始，一个从2开始，计算 start 指针到 end 指针的 sum，根据 sum 比较并移动指针。\n\n5、删除排序数组中的重复元素\n   借助 ArrayList；使用 ArrayCopy；使用临时变量\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-04-18-算法之数组.markdown","raw":"title: 算法之数组\ndate: 2015-04-18 22:18:44\ntags: 算法\n---\n\n数组的常见算法题，记录一下，以备忘。\n\n<!--more-->\n\n1、整型数组的逆置算法\n\n2、旋转数组\n   For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]。\n```\n\treverse(array, 0, n-k-1); // 反转前一半\n\treverse(array, n-k, n-1); // 反转后一半\n\treverse(array, 0, n-1);   // 反转整个数组\t\n```\n\n3、排序数组中和为 s 的两个数字\n   头尾两个指针相加，根据和的大小前后移动。也可以只用一个指针，在该指针后面的数组用二分查找看有没有满足要求的数『 mid = (low + high) >>> 1 』。\n\n4、和为 s 的连续正整数序列\n   两个指针，一个从1开始，一个从2开始，计算 start 指针到 end 指针的 sum，根据 sum 比较并移动指针。\n\n5、删除排序数组中的重复元素\n   借助 ArrayList；使用 ArrayCopy；使用临时变量\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-04-18-算法之数组","published":1,"updated":"2015-10-16T02:47:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yo07003xek5x2gc434cu"},{"title":"排序查找算法总结","date":"2015-04-18T14:18:44.000Z","_content":"\n总结下常见的各种排序算法，包括改进的冒泡排序、直接插入、快排、堆排等。\n\n<!--more-->\n\n# 普通冒泡排序\n\n```\nvoid BubbleSort(int data[], int n) {\n\tint i, j;\n\tfor ( i=0; i<\\n-1; i++ )\n\t\tfor ( j=n-1; j>i; j-- )\n\t\t\tswap(data, i, j);\n}\n```\n\n优化后的冒泡排序\n```\nvoid BubbleSort(int data[], int n) {\n\tint i, j;\n\tbool flag = true;\n\tfor ( i=0; i<\\n-1 && flag; i++) {\n\t\tflag = false;\n\t\tfor ( j=n-1; j>i; j--)\n\t\t\tif (needSwap) {\n\t\t\t\tswap(data, i, j);\n\t\t\t\tflag = true;\n\t\t\t}\n\t}\n}\n```\n\n# 快排\n```\nvoid QSort(int data[], int low, int high) {\n\tint pivot;\n\tif (low < high) {\n\t\tpivot = Partition(data, low, high);\n\t\tQSort(data, low, pivot-1);\n\t\tQSort(data, pivot+1, high);\n\t}\n}\n\nint Partition(int data[], int low, int high) {\n\tint pivotKey = data[low];\n\twhile (low < high) {\n\t\twhile (low < high && data[high] >= pivotKey)\n\t\t\thigh--;\n\t\tswap(data, low, high);\n\n\t\twhile (low <high && data[low] <= pivotKey)\n\t\t\tlow++;\n\t\tswap(data, low, high);\n\t}\n\treturn low;\n}\n```\n\n# 二分查找\n\n```\nint BinarySearch(int data[], int n, int key) {\n\tint low = 0, high = n-1, mid;\n\t\n\twhile ( low <= high ) {\n\t\tmid = (low + high) >>> 1;\n\t\tif ( data[mid] > key ) \n\t\t\thigh = mid - 1;\n\t\telse if ( data[mid] < key )\n\t\t\tlow = mid + 1;\n\t\telse if ( data[mid] == key )\n\t\t\treturn mid;\n\t}\n\n\treturn -1;\n}\n```\n\n# 二叉排序树查找\n\n```\ntypedef struct BiTNode {\n\tint data;\n\tstruct BiTNode *left, *right;\n}BiTNode, *BiTree;\n\nBiTree search(BiTree root, int key) {\n\tif (root == NULL) \n\t\treturn NULL;\n\tif (key < root->data)\n\t\treturn search(root->left, key);\n\tif (key > root->data)\n\t\treturn search(root->right, key);\n\treturn root;\n}\n```\n\n# 散列表\n```\nvoid InsertHash(int data[], int key, int n) {\n\tint addr = indexFor(key);\n\twhile (data[addr] != NULL_KEY)\n\t\taddr = (addr + 1) % n;\n\tdata[addr] = key;\n}\n\nint SearchHash(int data[], int key, int n) {\n\taddr = indexFor(key);\n\twhile (data[addr] != key) {\n\t\taddr = (addr + 1) % n;\n\t\tif (data[addr] == NULL_KEY || addr = indexFor(key))\n\t\t\treturn -1;\n\t}\n\treturn addr;\n}\n```\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-04-18-排序算法总结.markdown","raw":"title: 排序查找算法总结\ndate: 2015-04-18 22:18:44\ntags: 数据结构与算法\n---\n\n总结下常见的各种排序算法，包括改进的冒泡排序、直接插入、快排、堆排等。\n\n<!--more-->\n\n# 普通冒泡排序\n\n```\nvoid BubbleSort(int data[], int n) {\n\tint i, j;\n\tfor ( i=0; i<\\n-1; i++ )\n\t\tfor ( j=n-1; j>i; j-- )\n\t\t\tswap(data, i, j);\n}\n```\n\n优化后的冒泡排序\n```\nvoid BubbleSort(int data[], int n) {\n\tint i, j;\n\tbool flag = true;\n\tfor ( i=0; i<\\n-1 && flag; i++) {\n\t\tflag = false;\n\t\tfor ( j=n-1; j>i; j--)\n\t\t\tif (needSwap) {\n\t\t\t\tswap(data, i, j);\n\t\t\t\tflag = true;\n\t\t\t}\n\t}\n}\n```\n\n# 快排\n```\nvoid QSort(int data[], int low, int high) {\n\tint pivot;\n\tif (low < high) {\n\t\tpivot = Partition(data, low, high);\n\t\tQSort(data, low, pivot-1);\n\t\tQSort(data, pivot+1, high);\n\t}\n}\n\nint Partition(int data[], int low, int high) {\n\tint pivotKey = data[low];\n\twhile (low < high) {\n\t\twhile (low < high && data[high] >= pivotKey)\n\t\t\thigh--;\n\t\tswap(data, low, high);\n\n\t\twhile (low <high && data[low] <= pivotKey)\n\t\t\tlow++;\n\t\tswap(data, low, high);\n\t}\n\treturn low;\n}\n```\n\n# 二分查找\n\n```\nint BinarySearch(int data[], int n, int key) {\n\tint low = 0, high = n-1, mid;\n\t\n\twhile ( low <= high ) {\n\t\tmid = (low + high) >>> 1;\n\t\tif ( data[mid] > key ) \n\t\t\thigh = mid - 1;\n\t\telse if ( data[mid] < key )\n\t\t\tlow = mid + 1;\n\t\telse if ( data[mid] == key )\n\t\t\treturn mid;\n\t}\n\n\treturn -1;\n}\n```\n\n# 二叉排序树查找\n\n```\ntypedef struct BiTNode {\n\tint data;\n\tstruct BiTNode *left, *right;\n}BiTNode, *BiTree;\n\nBiTree search(BiTree root, int key) {\n\tif (root == NULL) \n\t\treturn NULL;\n\tif (key < root->data)\n\t\treturn search(root->left, key);\n\tif (key > root->data)\n\t\treturn search(root->right, key);\n\treturn root;\n}\n```\n\n# 散列表\n```\nvoid InsertHash(int data[], int key, int n) {\n\tint addr = indexFor(key);\n\twhile (data[addr] != NULL_KEY)\n\t\taddr = (addr + 1) % n;\n\tdata[addr] = key;\n}\n\nint SearchHash(int data[], int key, int n) {\n\taddr = indexFor(key);\n\twhile (data[addr] != key) {\n\t\taddr = (addr + 1) % n;\n\t\tif (data[addr] == NULL_KEY || addr = indexFor(key))\n\t\t\treturn -1;\n\t}\n\treturn addr;\n}\n```\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-04-18-排序算法总结","published":1,"updated":"2015-10-16T02:46:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yo090040ek5xr6abun4p"},{"title":"图总结","date":"2015-04-18T14:18:44.000Z","_content":"\n图的遍历。\n\n<!--more-->\n\n## 结构体定义\n\n```\ntypedef struct EdgeNode {\n\tint adjvex;\n\tstruct EdgeNode *next;\n}EdgeNode;\n\ntypedef struct VertexNode {\n\tchar data;\n\tEdgeNode *firstedge;\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct {\n\tAdjList adjList;\n\tint numVertexes, numEdges;\n}GraphAdjList;\n```\n\n## 邻接表的深度优先递归算法\n\n```\nvoid DFS(GraphAdjList GL, int i) {\n\tvisited[i] = true;\n\tprint(GL->adjList[i].data);\n\tEdgeNode *p = GL->adjList[i].firstedge;\n\n\twhile (p) {\n\t\tif ( !visited[p->adjvex] )\n\t\t\tDFS(GL, p->adjVex);\n\t\tp = p->next;\n\t}\n}\n\nvoid DFSTraverse(GraphAdjList GL) {\n\tfor (i=0;i<GL->numVertexes;i++)\n\t\tvisited[i] = false;\n\tfor (i=0;i<GL->numVertexes;i++)\n\t\tif (!visited[i])\n\t\t\tDFS(GL, i);\n}\n```\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-04-18-图总结.markdown","raw":"title: 图总结\ndate: 2015-04-18 22:18:44\ntags: 数据结构与算法\n---\n\n图的遍历。\n\n<!--more-->\n\n## 结构体定义\n\n```\ntypedef struct EdgeNode {\n\tint adjvex;\n\tstruct EdgeNode *next;\n}EdgeNode;\n\ntypedef struct VertexNode {\n\tchar data;\n\tEdgeNode *firstedge;\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct {\n\tAdjList adjList;\n\tint numVertexes, numEdges;\n}GraphAdjList;\n```\n\n## 邻接表的深度优先递归算法\n\n```\nvoid DFS(GraphAdjList GL, int i) {\n\tvisited[i] = true;\n\tprint(GL->adjList[i].data);\n\tEdgeNode *p = GL->adjList[i].firstedge;\n\n\twhile (p) {\n\t\tif ( !visited[p->adjvex] )\n\t\t\tDFS(GL, p->adjVex);\n\t\tp = p->next;\n\t}\n}\n\nvoid DFSTraverse(GraphAdjList GL) {\n\tfor (i=0;i<GL->numVertexes;i++)\n\t\tvisited[i] = false;\n\tfor (i=0;i<GL->numVertexes;i++)\n\t\tif (!visited[i])\n\t\t\tDFS(GL, i);\n}\n```\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-04-18-图总结","published":1,"updated":"2015-10-16T13:30:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yo0a0042ek5xogmxdgjc"},{"title":"二叉树算法总结","date":"2015-04-18T14:18:44.000Z","_content":"\n二叉树的相关算法，建立、遍历等。\n\n<!--more-->\n\n## 结构体定义\n\n```\ntypedef struct BiTNode {\n\tElemType data;\n\tstruct BiTNode *left, *right;\n}BiTNode, *BiTree;\n```\n\n## 递归遍历（前序）\n\n```\nvoid PreOrderTraverse(BiTree T) {\n\tif ( T == NULL)\n\t\treturn;\n\tprint(T->data);\n\tPreOrderTraverse(T->left);\n\tPreOrderTraverse(T->right);\n}\n```\n\n## 非递归遍历（前序）\n\n```\nvoid PreOrderTraverse(BiTree T) {\n\tif (T == NULL)\n\t\treturn;\n\tBiTree p = T;\n\tStack<BiTree> s;\n\n\twhile (p!=NULL || !s.empty()) {\n\n\t\twhile (p != NULL) {\n\t\t\tprint(p->data);\n\t\t\ts.push(p);\n\t\t\tp = p->left;\n\t\t}\n\n\t\tif (!s.empty()) {\n\t\t\tp = s.pop();\n\t\t\tp = p->right;\n\t\t}\n\n\t}\t\n}\n```\n\n## 非递归遍历（中序）\n\n```\nvoid InOrderTraverse(BiTree T) {\n\tif (T == NULL)\n\t\treturn;\n\tBiTree p = T;\n\tStack<BiTree> s;\n\n\twhile (p!=NULL || !s.empty()) {\n\n\t\twhile (p!=NULL) {\n\t\t\ts.push(p);\n\t\t\tp = p->left;\n\t\t}\n\n\t\tif (!s.empty()) {\n\t\t\tp = s.pop();\n\t\t\tprint(p->data);\n\t\t\tp = p->right;\n\t\t}\n\n\t}\n}\n```\n\n## 非递归遍历（后序）\n\n注意，只有在栈顶出现两次才能输出。\n\n```\nvoid PostOrderTraverse(BiTree T) {\n\tif (T == NULL)\n\t\treturn;\n\tBiTree p;\n\tBTNode temp;\n\tStack<BTNode> s;\n\n\twhile (p !=NULL || !s.empty()) {\n\t\tBTNode btn = malloc();\n\t\tbtn->node = p;\n\t\tbtn->isFirst = true;\n\t\ts.push(btn);\n\t\tp = p->left;\n\t}\n\n\tif (!s.empty()) {\n\t\ttemp = s.pop();\n\t\tif (temp->isFirst == true) {\n\t\t\ttemp->isFirst = false;\n\t\t\ts.push(temp);\n\t\t\tp = temp->node->right;\n\t\t}\n\t\telse {\n\t\t\tprint(temp->node->data);\n\t\t\tp = NULL;\n\t\t}\n\t}\n\n}\n```\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-04-18-二叉树总结.markdown","raw":"title: 二叉树算法总结\ndate: 2015-04-18 22:18:44\ntags: 数据结构与算法\n---\n\n二叉树的相关算法，建立、遍历等。\n\n<!--more-->\n\n## 结构体定义\n\n```\ntypedef struct BiTNode {\n\tElemType data;\n\tstruct BiTNode *left, *right;\n}BiTNode, *BiTree;\n```\n\n## 递归遍历（前序）\n\n```\nvoid PreOrderTraverse(BiTree T) {\n\tif ( T == NULL)\n\t\treturn;\n\tprint(T->data);\n\tPreOrderTraverse(T->left);\n\tPreOrderTraverse(T->right);\n}\n```\n\n## 非递归遍历（前序）\n\n```\nvoid PreOrderTraverse(BiTree T) {\n\tif (T == NULL)\n\t\treturn;\n\tBiTree p = T;\n\tStack<BiTree> s;\n\n\twhile (p!=NULL || !s.empty()) {\n\n\t\twhile (p != NULL) {\n\t\t\tprint(p->data);\n\t\t\ts.push(p);\n\t\t\tp = p->left;\n\t\t}\n\n\t\tif (!s.empty()) {\n\t\t\tp = s.pop();\n\t\t\tp = p->right;\n\t\t}\n\n\t}\t\n}\n```\n\n## 非递归遍历（中序）\n\n```\nvoid InOrderTraverse(BiTree T) {\n\tif (T == NULL)\n\t\treturn;\n\tBiTree p = T;\n\tStack<BiTree> s;\n\n\twhile (p!=NULL || !s.empty()) {\n\n\t\twhile (p!=NULL) {\n\t\t\ts.push(p);\n\t\t\tp = p->left;\n\t\t}\n\n\t\tif (!s.empty()) {\n\t\t\tp = s.pop();\n\t\t\tprint(p->data);\n\t\t\tp = p->right;\n\t\t}\n\n\t}\n}\n```\n\n## 非递归遍历（后序）\n\n注意，只有在栈顶出现两次才能输出。\n\n```\nvoid PostOrderTraverse(BiTree T) {\n\tif (T == NULL)\n\t\treturn;\n\tBiTree p;\n\tBTNode temp;\n\tStack<BTNode> s;\n\n\twhile (p !=NULL || !s.empty()) {\n\t\tBTNode btn = malloc();\n\t\tbtn->node = p;\n\t\tbtn->isFirst = true;\n\t\ts.push(btn);\n\t\tp = p->left;\n\t}\n\n\tif (!s.empty()) {\n\t\ttemp = s.pop();\n\t\tif (temp->isFirst == true) {\n\t\t\ttemp->isFirst = false;\n\t\t\ts.push(temp);\n\t\t\tp = temp->node->right;\n\t\t}\n\t\telse {\n\t\t\tprint(temp->node->data);\n\t\t\tp = NULL;\n\t\t}\n\t}\n\n}\n```\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-04-18-二叉树总结","published":1,"updated":"2015-10-16T03:32:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yo0b0044ek5x0570b1ra"},{"layout":"post","title":"【视频教程】Base64 编码的编程使用","date":"2015-04-16T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\nBase64 算法最早应用于解决电子邮件传输的问题，在早期，由于“历史问题”，电子邮件只允许 ASCII 码字符，如果要传送一封带有非 ASCII 码字符的电子邮件，当它通过一些网关的时候就可能出现问题。这个网关很可能会对这个非 ASCII 码字符的二进制位做调整，即将这个非 ASCII 码的 8 位二进制码的最高位置为 0，此用户收到的邮件就会是一封纯粹的乱码邮件，基于这个原因产生了 Base64 算法。\n\n**核心内容**\n\n* 综述密码学\n* 概述密码学中关键概念（尤其区分密钥和口令）\n* 简介 Base64 的概念、应用\n* Base64 的编程使用\n* 利用 telnet 客户端演示 Base64 在登录邮件系统中的作用\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/738.html?hmsr=teacher_icodeyou_c738)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_Base64编码的编程使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-04-16-【视频教程】Base64编码的编程使用.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】Base64 编码的编程使用\"\ndate: 2015-04-16 15:20:33 +0800\ncomments: true\ntags: [极客学院, 密码学, Java]\n---\n\n**课程背景**\n\nBase64 算法最早应用于解决电子邮件传输的问题，在早期，由于“历史问题”，电子邮件只允许 ASCII 码字符，如果要传送一封带有非 ASCII 码字符的电子邮件，当它通过一些网关的时候就可能出现问题。这个网关很可能会对这个非 ASCII 码字符的二进制位做调整，即将这个非 ASCII 码的 8 位二进制码的最高位置为 0，此用户收到的邮件就会是一封纯粹的乱码邮件，基于这个原因产生了 Base64 算法。\n\n**核心内容**\n\n* 综述密码学\n* 概述密码学中关键概念（尤其区分密钥和口令）\n* 简介 Base64 的概念、应用\n* Base64 的编程使用\n* 利用 telnet 客户端演示 Base64 在登录邮件系统中的作用\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/738.html?hmsr=teacher_icodeyou_c738)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/jike_Base64编码的编程使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-04-16-【视频教程】Base64编码的编程使用","published":1,"updated":"2015-08-24T10:27:53.000Z","photos":[],"link":"","_id":"ciw22yo0c0046ek5x33s4ysa7"},{"layout":"post","title":"在 Mac 下安装 mysql for python","date":"2015-04-10T11:49:33.000Z","comments":1,"_content":"\n在 Mac 中使用 XAMPP 环境下，如何来为 python 安装 mysql\n\n<!--more-->\n\n停下手头的，写点东西。\n\n关于如何能在 Mac 下为 python 安装 mysql，真是折腾了一会。之前在 windows 下装过，很顺利，这次到 Mac 下居然这么坎坷了。特来记录一下过程，共享学习。\n\n我的环境：Mac Yosetime 10.10.2 + python 2.7 + XAMPP\n\n凡是在搜索“python mysqldb 安装 mac”等类关键字时，得到的教程基本都是一致的，教程如下，我开始也是照着这个来的但是不成功，原因是我用的是 XAMPP（下文具体讲）。\n\n在下面的网址下载mysqldb模块：\n```\nhttp://sourceforge.net/projects/mysql-python/\n```\n\n在mac os x直接双击解压,命令行进入解压后的目录， 执行\n```\npython setup.py build\n```\n\n如果有\n```\nsh: mysql_config: command not found\n```\n\n提示，我们需要编辑下mysql的路径，打开setup_posix.py\n\n找到:\n```\nmysql_config.path = \"mysql_config\"\n```\n\n改为：\n```\nmysql_config.path = \"/usr/local/mysql/bin/mysql_config\"\n```\n\n再执行一次 build：\n```\npython setup.py build\n```\n\nbuild 没问题了，然后执行：\n```\nsudo python setup.py install\n```\n\n安装成功后，在命令行输入 python 进入 python 环境，如果报下面的错误：\n```\nImportError: dlopen(/Library/Python/2.7/site-packages/MySQL_python-1.2.4b4-py2.7-macosx-10.8-intel.egg/_mysql.so, 2): Library not loaded: libmysqlclient.18.dylib\n  Referenced from: /Library/Python/2.7/site-packages/MySQL_python-1.2.4b4-py2.7-macosx-10.8-intel.egg/_mysql.so\n  Reason: image not found\n```\n\n解决方法，建立一个软链就可以了\n```\nsudo ln -s /usr/local/mysql/lib/libmysqlclient.18.dylib /usr/lib/libmysqlclient.18.dylib\n```\n\nOver~如果你的 mysql 是手动安装的话，也许上面的教程就没有问题了，但关键是在于，我在 `python setup.py build` 的时候总是告诉我 mysql_config 命令找不到。根本原因是我这里的 mysql 是在 xampp 中的，所以 `mysql_config` 命令是在 `/Applications/XAMPP/xamppfiles/bin/mysql_config` 这里的，找到原因了，再打开 setup_posix.py\n\n找到:\n```\nmysql_config.path = \"mysql_config\"\n```\n\n这次改为：\n```\nmysql_config.path = \"/Applications/XAMPP/xamppfiles/bin/mysql_config\"\n```\n\n之后再build：\n```\npython setup.py build\n```\n\n发现就成功了，并且没有报任何错误，另外还有同样的一点，在设置软链接时，也需要做相同的修改：\n```\nsudo ln -s /Applications/XAMPP/xamppfiles/bin/libmysqlclient.18.dylib /usr/lib/libmysqlclient.18.dylib\n```\n\n其余部分按照刚才教程之后的步骤操作就可以了。\n\n总结：本次为 python 安装 mysql 屡屡失败的根本原因是在于自己过于相信网上的教程了，并不是说教程不对，而是说自己太不过脑子了，直接照抄并不思考为什么，刚才的错误只要稍微思考一下就能知道错误原因在哪里了，也不用浪费那么多时间了。\n\n好了，继续了。\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-04-10- 在 Mac 下安装 mysql for python.markdown","raw":"---\nlayout: post\ntitle: \"在 Mac 下安装 mysql for python\"\ndate: 2015-04-10 19:49:33 +0800\ncomments: true\ntags: [Python, Mysql]\n---\n\n在 Mac 中使用 XAMPP 环境下，如何来为 python 安装 mysql\n\n<!--more-->\n\n停下手头的，写点东西。\n\n关于如何能在 Mac 下为 python 安装 mysql，真是折腾了一会。之前在 windows 下装过，很顺利，这次到 Mac 下居然这么坎坷了。特来记录一下过程，共享学习。\n\n我的环境：Mac Yosetime 10.10.2 + python 2.7 + XAMPP\n\n凡是在搜索“python mysqldb 安装 mac”等类关键字时，得到的教程基本都是一致的，教程如下，我开始也是照着这个来的但是不成功，原因是我用的是 XAMPP（下文具体讲）。\n\n在下面的网址下载mysqldb模块：\n```\nhttp://sourceforge.net/projects/mysql-python/\n```\n\n在mac os x直接双击解压,命令行进入解压后的目录， 执行\n```\npython setup.py build\n```\n\n如果有\n```\nsh: mysql_config: command not found\n```\n\n提示，我们需要编辑下mysql的路径，打开setup_posix.py\n\n找到:\n```\nmysql_config.path = \"mysql_config\"\n```\n\n改为：\n```\nmysql_config.path = \"/usr/local/mysql/bin/mysql_config\"\n```\n\n再执行一次 build：\n```\npython setup.py build\n```\n\nbuild 没问题了，然后执行：\n```\nsudo python setup.py install\n```\n\n安装成功后，在命令行输入 python 进入 python 环境，如果报下面的错误：\n```\nImportError: dlopen(/Library/Python/2.7/site-packages/MySQL_python-1.2.4b4-py2.7-macosx-10.8-intel.egg/_mysql.so, 2): Library not loaded: libmysqlclient.18.dylib\n  Referenced from: /Library/Python/2.7/site-packages/MySQL_python-1.2.4b4-py2.7-macosx-10.8-intel.egg/_mysql.so\n  Reason: image not found\n```\n\n解决方法，建立一个软链就可以了\n```\nsudo ln -s /usr/local/mysql/lib/libmysqlclient.18.dylib /usr/lib/libmysqlclient.18.dylib\n```\n\nOver~如果你的 mysql 是手动安装的话，也许上面的教程就没有问题了，但关键是在于，我在 `python setup.py build` 的时候总是告诉我 mysql_config 命令找不到。根本原因是我这里的 mysql 是在 xampp 中的，所以 `mysql_config` 命令是在 `/Applications/XAMPP/xamppfiles/bin/mysql_config` 这里的，找到原因了，再打开 setup_posix.py\n\n找到:\n```\nmysql_config.path = \"mysql_config\"\n```\n\n这次改为：\n```\nmysql_config.path = \"/Applications/XAMPP/xamppfiles/bin/mysql_config\"\n```\n\n之后再build：\n```\npython setup.py build\n```\n\n发现就成功了，并且没有报任何错误，另外还有同样的一点，在设置软链接时，也需要做相同的修改：\n```\nsudo ln -s /Applications/XAMPP/xamppfiles/bin/libmysqlclient.18.dylib /usr/lib/libmysqlclient.18.dylib\n```\n\n其余部分按照刚才教程之后的步骤操作就可以了。\n\n总结：本次为 python 安装 mysql 屡屡失败的根本原因是在于自己过于相信网上的教程了，并不是说教程不对，而是说自己太不过脑子了，直接照抄并不思考为什么，刚才的错误只要稍微思考一下就能知道错误原因在哪里了，也不用浪费那么多时间了。\n\n好了，继续了。\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-04-10- 在 Mac 下安装 mysql for python","published":1,"updated":"2015-08-24T10:24:58.000Z","photos":[],"link":"","_id":"ciw22yo0e004aek5x98w94p1l"},{"layout":"post","title":"【视频教程】Fedora 升级 Kernel 至最新版本","date":"2015-03-15T07:20:33.000Z","comments":1,"_content":"\n此视频中演示 Fedora 升级 Kernel 至 `3.19`\n\n<!--more-->\n\n<div class=\"video-container\">\n\t<video src=\"http://202.112.144.242/mp4files/5002000000371652/icodeyou.qiniudn.com/FedoraUpdateKernelBYicodeyou.mp4\" controls=\"controls\"></video>\n</div>\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-03-15-【视频教程】Fedora 升级 Kernel 至最新版本.markdown","raw":"\n---\nlayout: post\ntitle: \"【视频教程】Fedora 升级 Kernel 至最新版本\"\ndate: 2015-03-15 15:20:33 +0800\ncomments: true\ntags: Linux\n---\n\n此视频中演示 Fedora 升级 Kernel 至 `3.19`\n\n<!--more-->\n\n<div class=\"video-container\">\n\t<video src=\"http://202.112.144.242/mp4files/5002000000371652/icodeyou.qiniudn.com/FedoraUpdateKernelBYicodeyou.mp4\" controls=\"controls\"></video>\n</div>\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-03-15-【视频教程】Fedora 升级 Kernel 至最新版本","published":1,"updated":"2015-08-24T10:27:21.000Z","photos":[],"link":"","_id":"ciw22yo0g004eek5x06tq67rl"},{"layout":"post","title":"【视频教程】Android 项目开发实战--新闻客户端","date":"2015-02-28T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n移动互联网背景下，手机凭借其随时随地、移动与便携等优势发展成为重要的大众传播媒体，成为媒介融合的新平台。移动新闻客户端凭借其丰富的资讯资源、实时的信息推送被越来越多的用户认可。对于各行各业来说，为了展示企业良好形象，新闻客户端是面向用户中必不可少的一部分。\n\n**核心内容**\n\n* 在 PHP 中生成 JSON 数据，在 Android 中进行 JSON 数据解析\n* Android 中 BaseAdapter 的使用\n* Android 中 WebView 的使用\n* Android 网络编程\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/559.html)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://icodeyou.qiniudn.com/Android 项目开发实战--新闻客户端.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-02-28-【视频教程】Android 项目开发实战--新闻客户端.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】Android 项目开发实战--新闻客户端\"\ndate: 2015-02-28 15:20:33 +0800\ncomments: true\ntags: [极客学院, Android]\n---\n\n**课程背景**\n\n移动互联网背景下，手机凭借其随时随地、移动与便携等优势发展成为重要的大众传播媒体，成为媒介融合的新平台。移动新闻客户端凭借其丰富的资讯资源、实时的信息推送被越来越多的用户认可。对于各行各业来说，为了展示企业良好形象，新闻客户端是面向用户中必不可少的一部分。\n\n**核心内容**\n\n* 在 PHP 中生成 JSON 数据，在 Android 中进行 JSON 数据解析\n* Android 中 BaseAdapter 的使用\n* Android 中 WebView 的使用\n* Android 网络编程\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/559.html)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://icodeyou.qiniudn.com/Android 项目开发实战--新闻客户端.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-02-28-【视频教程】Android 项目开发实战--新闻客户端","published":1,"updated":"2015-08-24T10:27:05.000Z","photos":[],"link":"","_id":"ciw22yo0h004gek5x1xa2suy5"},{"layout":"post","title":"【视频教程】Android 中 Action Bar 的使用","date":"2015-01-15T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\nAction Bar 是一个标识应用程序和用户位置的窗口功能，并且给用户提供操作和导航模式。在大多数的情况下，当需要突出展现用户行为或全局导航的 Activity 中使用 Action Bar，因为其能够使应用程序给用户提供一致的界面，并且系统能够很好根据不同的屏幕配置来适应操作栏的外观。\n\n**核心内容**\n\n* 在程序中启用 Action Bar\n* 在 Action Bar 中添加按钮\n* 自定义 Action Bar Style\n* 开启 Overlay Mode\n* 使用 ActionBarSherlock 开源库\n* 使用一键生成工具 Android Action Bar Style Generator\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/493.html)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://icodeyou.qiniudn.com/Android 中 Action Bar 的使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2015-01-15-【视频教程】Android 中 Action Bar 的使用.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】Android 中 Action Bar 的使用\"\ndate: 2015-01-15 15:20:33 +0800\ncomments: true\ntags: [极客学院, Android]\n---\n\n**课程背景**\n\nAction Bar 是一个标识应用程序和用户位置的窗口功能，并且给用户提供操作和导航模式。在大多数的情况下，当需要突出展现用户行为或全局导航的 Activity 中使用 Action Bar，因为其能够使应用程序给用户提供一致的界面，并且系统能够很好根据不同的屏幕配置来适应操作栏的外观。\n\n**核心内容**\n\n* 在程序中启用 Action Bar\n* 在 Action Bar 中添加按钮\n* 自定义 Action Bar Style\n* 开启 Overlay Mode\n* 使用 ActionBarSherlock 开源库\n* 使用一键生成工具 Android Action Bar Style Generator\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/493.html)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://icodeyou.qiniudn.com/Android 中 Action Bar 的使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2015-01-15-【视频教程】Android 中 Action Bar 的使用","published":1,"updated":"2015-08-24T10:27:00.000Z","photos":[],"link":"","_id":"ciw22yo0j004jek5x9tmksw79"},{"layout":"post","title":"【视频教程】Android 侧滑菜单之 DrawerLayout 的使用","date":"2014-12-30T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n目前侧滑菜单已广泛应用于各大应用，这一菜单形式简洁明了，深受用户的喜爱。在谷歌官方推出 DrawerLayout 之前，开发者大都通过 SlidingMenu 开源库来实现这一功能。而现在 DrawerLayout 被谷歌包含在了 android-support-v4.jar 这个包下，可以让开发者更简单方便的实现侧滑菜单这一功能。\n\n**核心内容**\n\n* DrawerLayout 的基本使用\n* Fragment 的动态创建\n* Action Bar 的基本使用\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/449.html)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://icodeyou.qiniudn.com/Android 侧滑菜单之 DrawerLayout 的使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2014-12-30-【视频教程】Android 侧滑菜单之 DrawerLayout 的使用.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】Android 侧滑菜单之 DrawerLayout 的使用\"\ndate: 2014-12-30 15:20:33 +0800\ncomments: true\ntags: [极客学院, Android]\n---\n\n**课程背景**\n\n目前侧滑菜单已广泛应用于各大应用，这一菜单形式简洁明了，深受用户的喜爱。在谷歌官方推出 DrawerLayout 之前，开发者大都通过 SlidingMenu 开源库来实现这一功能。而现在 DrawerLayout 被谷歌包含在了 android-support-v4.jar 这个包下，可以让开发者更简单方便的实现侧滑菜单这一功能。\n\n**核心内容**\n\n* DrawerLayout 的基本使用\n* Fragment 的动态创建\n* Action Bar 的基本使用\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/449.html)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://icodeyou.qiniudn.com/Android 侧滑菜单之 DrawerLayout 的使用.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2014-12-30-【视频教程】Android 侧滑菜单之 DrawerLayout 的使用","published":1,"updated":"2015-08-24T10:26:54.000Z","photos":[],"link":"","_id":"ciw22yo0k004mek5xlvtx4zgt"},{"title":"Android 中线程同步异步方式总结","date":"2014-10-22T14:18:44.000Z","_content":"\n学了这么多年 Java 和 Android，居然连线程同步还是异步都分不清，还好被人问到了『线程同步和异步的区别』，当时我的回答是：\"这两个有区别吗。。？不都是控制线程之间先后的执行顺序吗？比如 Android 里常用的 Handler、接口回调、事件分发、synchronized、wait、Semaphore、CountDownLatch\"等等，我还说了一堆能够控制线程先后执行顺序的方式。后来发现，确实同步和异步不一样，所以本篇文章主要就讲讲同步异步的概念区别以及 Android 中同步异步的各种实现方式。\n\n备注：此篇文章为目录，具体内容后续分篇更新。\n\n<!--more-->\n\n# 同步和异步的区别\n\n首先以一个常见的开发场景来区别一下同步和异步的区别，比如我们要获取一张网络图片并完成显示。在这个场景中我们需要开启两个线程，一个是子线程—即下载图片的线程；另外是主 UI 线程—即图片下载完成后进行显示的线程。针对这个场景分别用两幅实现的流程图来区分同步和异步。\n\n\n\n从图中可以看到，二者的区别在于：同步时当前主线程会阻塞，直到子线程通知主线程为止（先不考虑ANR）；而异步的时候主线程可以继续干其它的事情，当子线程完成任务的时候通知一下主线程就可以了，类似于接口回调或消息队列的思想。`所以很关键的一点，在于它们是否会阻塞。`\n\n\n\n# Android 中同步的实现方式\n\n1. synchronized、wait/notify 等（Java 中的基础知识，不做过多说明了）\n   \n2. Semaphore （操作系统中非常重要的概念）\n   \n3. CountDownLatch\n   \n4. CyclicBarrier\n   \n5. 。。。\n   \n   ​\n\n# Android 中异步的实现方式\n\n1. Handler\n2. 接口回调\n3. EventBus 等事件分发\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2014-12-22-ThreadSynchronization.markdown","raw":"title: Android 中线程同步异步方式总结\ndate: 2014-10-22 22:18:44 \ntags: Android\n----\n\n学了这么多年 Java 和 Android，居然连线程同步还是异步都分不清，还好被人问到了『线程同步和异步的区别』，当时我的回答是：\"这两个有区别吗。。？不都是控制线程之间先后的执行顺序吗？比如 Android 里常用的 Handler、接口回调、事件分发、synchronized、wait、Semaphore、CountDownLatch\"等等，我还说了一堆能够控制线程先后执行顺序的方式。后来发现，确实同步和异步不一样，所以本篇文章主要就讲讲同步异步的概念区别以及 Android 中同步异步的各种实现方式。\n\n备注：此篇文章为目录，具体内容后续分篇更新。\n\n<!--more-->\n\n# 同步和异步的区别\n\n首先以一个常见的开发场景来区别一下同步和异步的区别，比如我们要获取一张网络图片并完成显示。在这个场景中我们需要开启两个线程，一个是子线程—即下载图片的线程；另外是主 UI 线程—即图片下载完成后进行显示的线程。针对这个场景分别用两幅实现的流程图来区分同步和异步。\n\n\n\n从图中可以看到，二者的区别在于：同步时当前主线程会阻塞，直到子线程通知主线程为止（先不考虑ANR）；而异步的时候主线程可以继续干其它的事情，当子线程完成任务的时候通知一下主线程就可以了，类似于接口回调或消息队列的思想。`所以很关键的一点，在于它们是否会阻塞。`\n\n\n\n# Android 中同步的实现方式\n\n1. synchronized、wait/notify 等（Java 中的基础知识，不做过多说明了）\n   \n2. Semaphore （操作系统中非常重要的概念）\n   \n3. CountDownLatch\n   \n4. CyclicBarrier\n   \n5. 。。。\n   \n   ​\n\n# Android 中异步的实现方式\n\n1. Handler\n2. 接口回调\n3. EventBus 等事件分发\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2014-12-22-ThreadSynchronization","published":1,"updated":"2015-10-31T12:42:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yo0m004pek5x7krwonvj"},{"layout":"post","title":"【视频教程】Android 扫描二维码实现网页登录","date":"2014-12-19T07:20:33.000Z","comments":1,"_content":"\n**课程背景**\n\n起初微信网页版有客户端扫描二维码登录的功能，之后越来越多的站点开始利用这一新兴形式，开发出了使用二维码登录网站的各种应用。这种方式既不需要用户在网页端输入个人信息，又能保证安全性，可以切实提高用户体验度。\n\n**核心内容**\n\n* 下载使用 ZXing 库\n* 利用 API 实现 PHP 生成二维码\n* 使用 PHP 制定 API 接口，利用 Android的HttpUrlConnection 对其进行访问\n* 扫描二维码登录网页流程\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/420.html)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://icodeyou.qiniudn.com/Android 扫描二维码实现网页登录.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2014-12-19-【视频教程】Android 扫描二维码实现网页登录.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】Android 扫描二维码实现网页登录\"\ndate: 2014-12-19 15:20:33 +0800\ncomments: true\ntags: [极客学院, Android]\n---\n\n**课程背景**\n\n起初微信网页版有客户端扫描二维码登录的功能，之后越来越多的站点开始利用这一新兴形式，开发出了使用二维码登录网站的各种应用。这种方式既不需要用户在网页端输入个人信息，又能保证安全性，可以切实提高用户体验度。\n\n**核心内容**\n\n* 下载使用 ZXing 库\n* 利用 API 实现 PHP 生成二维码\n* 使用 PHP 制定 API 接口，利用 Android的HttpUrlConnection 对其进行访问\n* 扫描二维码登录网页流程\n\n<!--more-->\n\n在此只提供视频第一课，具体课程请至**[极客学院](http://www.jikexueyuan.com/course/420.html)**学习~\n\n<div class=\"video-container\">\n\t<video src=\"http://icodeyou.qiniudn.com/Android 扫描二维码实现网页登录.mp4\" controls=\"controls\"></video>\n</div>\n\n\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2014-12-19-【视频教程】Android 扫描二维码实现网页登录","published":1,"updated":"2015-08-24T10:26:48.000Z","photos":[],"link":"","_id":"ciw22yo0o004rek5xrjeacp6q"},{"title":"Android 遇到问题随手记","date":"2014-12-04T07:04:44.000Z","_content":"\n从即日起收集自身在 Android 开发过程中遇到的问题及解决方案。\n\n<!--more-->\n\n### 如何添加 .so 库\n\n将 .so 库拷贝到 libs 文件夹，此时不能像 jar 一样右键 add as library，因为根本就没这个菜单项！解决的办法是要借助于 gradle，打开本 module 的 build.grade,添加如下代码即可:\n\n``` java\nsourceSets {\n\tmain {\n\t\tjniLibs.srcDirs = ['libs']\n\t}\n}\n```\n\n### 将应用安装到模拟器上时出现错误 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE\n\n原因是添加 .so 库的时候一般都会添加 armeabi，因为 arm 的手机基本用的都是这个，但是应用在装到模拟器，比如 Genymotion 上的时候就会出现问题了，因为 Genymotion 运行在电脑上用着 x86 或 x64 的处理器，当然就会出现 CPU_ABI_INCOMPATIBLE 的错误了。解决办法是下载 [Genymotion-ARM-Translation.zip](http://7xivx9.com1.z0.glb.clouddn.com/Genymotion-ARM-Translation.zip) 这个文件，然后直接拖到 Genymotion 窗口中等待安装完成就可以了，简直爽。\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2014-12-04-AndroidCollection.markdown","raw":"title: Android 遇到问题随手记\ndate: 2014-12-04 15:04:44 \ntags: icodeyou\n----\n\n从即日起收集自身在 Android 开发过程中遇到的问题及解决方案。\n\n<!--more-->\n\n### 如何添加 .so 库\n\n将 .so 库拷贝到 libs 文件夹，此时不能像 jar 一样右键 add as library，因为根本就没这个菜单项！解决的办法是要借助于 gradle，打开本 module 的 build.grade,添加如下代码即可:\n\n``` java\nsourceSets {\n\tmain {\n\t\tjniLibs.srcDirs = ['libs']\n\t}\n}\n```\n\n### 将应用安装到模拟器上时出现错误 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE\n\n原因是添加 .so 库的时候一般都会添加 armeabi，因为 arm 的手机基本用的都是这个，但是应用在装到模拟器，比如 Genymotion 上的时候就会出现问题了，因为 Genymotion 运行在电脑上用着 x86 或 x64 的处理器，当然就会出现 CPU_ABI_INCOMPATIBLE 的错误了。解决办法是下载 [Genymotion-ARM-Translation.zip](http://7xivx9.com1.z0.glb.clouddn.com/Genymotion-ARM-Translation.zip) 这个文件，然后直接拖到 Genymotion 窗口中等待安装完成就可以了，简直爽。\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2014-12-04-AndroidCollection","published":1,"updated":"2015-12-06T02:20:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yo0q004uek5xuov7u7vx"},{"layout":"post","title":"编程实现可靠数据传输原理Go-Back-N","date":"2014-11-29T07:20:33.000Z","comments":1,"_content":"\n有一个计算机网络的实验，需要模拟GBN的过程，即在本地条件下模拟丢包重传机制。刚看到这个实验时有些不知所措，因为不知道怎样能实现丢包，在本地编程，即使是使用不可靠数据传输UDP的DatagramSocket，由于localhost到localhost走的是回环链路，也就是从客户机的应用层--传输层--网络层 到 服务器的网络层--传输层--应用层，这个肯定无法丢包，也用实验进行验证了（比如连续发送1万个DatagramPacket，发现每一个都被收到了）。\n\n那么问题来了，怎样才能丢包？\n\n<!--more-->\n\n通过前面的叙述，可知在链路上丢包是不可能的了，那我们可以从服务器端下手，也就是说，即使服务器收到了某个数据包，也不给客户机发ACK，那么到了客户机设置的定时器后，客户机自然就认为是丢包了。所以可以给服务器设置一个丢包概率，用Math.random()函数来实现，该函数返回一个从0到1之间的随机数，可用来设置“丢包”概率。如设置丢包概率为0.3：\n\n```\nif (Math.random()<=0.7){ \n    //接收成功，发ack; \n}else{\n    //呵呵，什么都不做\n}\n```\n\n“丢包”问题解决了，下面就是怎么发送数据包，用之前学过的TCP的Socket也行，用UDP的DatagramSocket也行，这个实验就采用UDP编程吧，所以，下一个问题就是，如何用UDP编程。\n\n同样也需要Socket（不理解Socket是什么的可以看前几篇文章），不过这次的是DatagramSocket，代表是UDP的数据报套接字。DatagramSocket要往外发送数据包，也就是DatagramPacket。举一个客户机可以向服务器发送数据并在服务器显示的例子。\n\n客户端代码如下：\n\n```\npublic class UDPClient { \n    public static void main(String[] args) throws Exception { \n        //创建UDP的socket \n        DatagramSocket socket = new DatagramSocket(); \n        //通过域名来获得服务器的IP地址 \n        InetAddress serverAddress = InetAddress.getByName(\"localhost\"); \n        String str = \"Hello Server, I am client\"; \n        //需要将发送的字符串转换成字节数组，才能在互联网中传输 \n        byte[] data = str.getBytes(); \n        //新建数据包，指明发送数据内容，发送的长度，服务器地址，服务器端口号 \n        DatagramPacket packet = new DatagramPacket(data, data.length, \n                serverAddress, 8899); \n        //使用socket发送数据包 \n        socket.send(packet); \n    } \n}\n```\n\n对应服务器端代码如下：\n\n```\npublic class UDPServer { \n    public static void main(String[] args) throws Exception { \n        //新建服务器端socket，并同时设置监听端口 \n        DatagramSocket socket = new DatagramSocket(8899); \n        while (true){ \n            byte[] data = new byte[1024]; \n            //新建数据包，会把后面收到的内容放到data字节数组里，最大长度为data.length \n            DatagramPacket packet = new DatagramPacket(data, data.length); \n            //此方法为阻塞方法（block method）,直到监听到数据包后才会往下执行，不然就一直等待，就像ServerSocket.accept()方法一样 \n            socket.receive(packet); \n            //执行到这里说明监听到了数据包，并把其中内容转换为字符串 \n            String result = new String(packet.getData()); \n            //打印 \n            System.out.println(\"receive result : \" + result); \n        } \n    } \n}\n```\n\n务必先运行服务器端，再运行客户端。运行结果如下：\n\n![image](http://img.blog.csdn.net/20141129165114704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n若想服务器端给客户端发送数据，可同样操作。\n\n利用DatagramSocket发送DatagramPacket的问题解决了，那么下一个问题，在GBN协议里面，客户端发送一个数据之后要设置定时器的，这个定时器怎么设置？\n\n在java里有两种方式来设置定时器，首先是第一种方法，使用Timer结合ActionListener即可。\n\n代码如下，其中值得注意的一点是Timer要导入java.swing这个包中的，而不是java.util这个包中的，否则不能正确运行。\n\n```\nimport java.awt.event.ActionEvent; \nimport java.awt.event.ActionListener;\nimport javax.swing.Timer;\npublic class TimerMain { \n    public static void main(String[] args) { \n        //设置定时器，第一个参数为延迟执行时间，单位是毫秒；第二个参数为到时间后执行的动作，类型为ActionListener \n        Timer timer = new Timer(3000, new DelayActionListener()); \n        //这个必须写，才可以使得timer生效 \n        timer.start(); \n        //为了不让程序结束，加个死循环，不然timer定时器还没到，主程序就结束了 \n        while (true){ \n        } \n    } \n}\n//自定义动作类实现ActionListener接口 \nclass DelayActionListener implements ActionListener{ \n    //此为回调方法，当时间到后自动执行actionPerformed方法 \n    @Override \n    public void actionPerformed(ActionEvent e) { \n        System.out.println(\"定时器时间到\"); \n    } \n}\n```\n\n运行结果如下：每隔3秒执行一次。如果需要取消定时器，使用timer.stop()方法即可。\n\n![image](http://img.blog.csdn.net/20141129165207500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n设置定时器的第二种方法是使用Timer结合TimerTask，在android里很常用，其实本来就是java的东西，代码如下：\n\n```\nimport java.util.Timer; \nimport java.util.TimerTask;\npublic class TimerTaskMain { \n    public static void main(String[] args) { \n        //使用TimerTask \n        TimerTask timerTask = new TimerTask() { \n            @Override \n            public void run() { \n                System.out.println(\"timerTask定时器时间到\"); \n            } \n        }; \n        Timer timer = new Timer(); \n        //第一个参数为要执行的目标，第二个参数为第一次执行延迟的时间，第三个参数为循环执行的时间间隔，单位都是毫秒 \n        timer.schedule(timerTask, 3000, 3000); \n    } \n}\n```\n\n运行结果如下：每隔3秒执行一次。如果需要取消定时器，使用timerTask.cancel()方法即可。\n\n![image](http://img.blog.csdn.net/20141129165146918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n有了如上这些东西，再结合GBN的原理和自己控制的逻辑操作，写GBN就应该可以实现了，就不贴完整代码了，自己实现印象更深刻些。\n\nupdate--------\n\n很多人跟我说你的 GBN 程序没源码。。。。虽然这里没贴源码，但我下面给了Github链接了，进去找找就好了，很明显的 GBN 开头的仓库就是了，一定要学会使用Github啊。。。方便的话帮我点几个`star`也好哈。\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2014-11-29-编程实现可靠数据传输原理 Go-Back-N.markdown","raw":"---\nlayout: post\ntitle: \"编程实现可靠数据传输原理Go-Back-N\"\ndate: 2014-11-29 15:20:33 +0800\ncomments: true\ntags: [Java, GBN]\n---\n\n有一个计算机网络的实验，需要模拟GBN的过程，即在本地条件下模拟丢包重传机制。刚看到这个实验时有些不知所措，因为不知道怎样能实现丢包，在本地编程，即使是使用不可靠数据传输UDP的DatagramSocket，由于localhost到localhost走的是回环链路，也就是从客户机的应用层--传输层--网络层 到 服务器的网络层--传输层--应用层，这个肯定无法丢包，也用实验进行验证了（比如连续发送1万个DatagramPacket，发现每一个都被收到了）。\n\n那么问题来了，怎样才能丢包？\n\n<!--more-->\n\n通过前面的叙述，可知在链路上丢包是不可能的了，那我们可以从服务器端下手，也就是说，即使服务器收到了某个数据包，也不给客户机发ACK，那么到了客户机设置的定时器后，客户机自然就认为是丢包了。所以可以给服务器设置一个丢包概率，用Math.random()函数来实现，该函数返回一个从0到1之间的随机数，可用来设置“丢包”概率。如设置丢包概率为0.3：\n\n```\nif (Math.random()<=0.7){ \n    //接收成功，发ack; \n}else{\n    //呵呵，什么都不做\n}\n```\n\n“丢包”问题解决了，下面就是怎么发送数据包，用之前学过的TCP的Socket也行，用UDP的DatagramSocket也行，这个实验就采用UDP编程吧，所以，下一个问题就是，如何用UDP编程。\n\n同样也需要Socket（不理解Socket是什么的可以看前几篇文章），不过这次的是DatagramSocket，代表是UDP的数据报套接字。DatagramSocket要往外发送数据包，也就是DatagramPacket。举一个客户机可以向服务器发送数据并在服务器显示的例子。\n\n客户端代码如下：\n\n```\npublic class UDPClient { \n    public static void main(String[] args) throws Exception { \n        //创建UDP的socket \n        DatagramSocket socket = new DatagramSocket(); \n        //通过域名来获得服务器的IP地址 \n        InetAddress serverAddress = InetAddress.getByName(\"localhost\"); \n        String str = \"Hello Server, I am client\"; \n        //需要将发送的字符串转换成字节数组，才能在互联网中传输 \n        byte[] data = str.getBytes(); \n        //新建数据包，指明发送数据内容，发送的长度，服务器地址，服务器端口号 \n        DatagramPacket packet = new DatagramPacket(data, data.length, \n                serverAddress, 8899); \n        //使用socket发送数据包 \n        socket.send(packet); \n    } \n}\n```\n\n对应服务器端代码如下：\n\n```\npublic class UDPServer { \n    public static void main(String[] args) throws Exception { \n        //新建服务器端socket，并同时设置监听端口 \n        DatagramSocket socket = new DatagramSocket(8899); \n        while (true){ \n            byte[] data = new byte[1024]; \n            //新建数据包，会把后面收到的内容放到data字节数组里，最大长度为data.length \n            DatagramPacket packet = new DatagramPacket(data, data.length); \n            //此方法为阻塞方法（block method）,直到监听到数据包后才会往下执行，不然就一直等待，就像ServerSocket.accept()方法一样 \n            socket.receive(packet); \n            //执行到这里说明监听到了数据包，并把其中内容转换为字符串 \n            String result = new String(packet.getData()); \n            //打印 \n            System.out.println(\"receive result : \" + result); \n        } \n    } \n}\n```\n\n务必先运行服务器端，再运行客户端。运行结果如下：\n\n![image](http://img.blog.csdn.net/20141129165114704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n若想服务器端给客户端发送数据，可同样操作。\n\n利用DatagramSocket发送DatagramPacket的问题解决了，那么下一个问题，在GBN协议里面，客户端发送一个数据之后要设置定时器的，这个定时器怎么设置？\n\n在java里有两种方式来设置定时器，首先是第一种方法，使用Timer结合ActionListener即可。\n\n代码如下，其中值得注意的一点是Timer要导入java.swing这个包中的，而不是java.util这个包中的，否则不能正确运行。\n\n```\nimport java.awt.event.ActionEvent; \nimport java.awt.event.ActionListener;\nimport javax.swing.Timer;\npublic class TimerMain { \n    public static void main(String[] args) { \n        //设置定时器，第一个参数为延迟执行时间，单位是毫秒；第二个参数为到时间后执行的动作，类型为ActionListener \n        Timer timer = new Timer(3000, new DelayActionListener()); \n        //这个必须写，才可以使得timer生效 \n        timer.start(); \n        //为了不让程序结束，加个死循环，不然timer定时器还没到，主程序就结束了 \n        while (true){ \n        } \n    } \n}\n//自定义动作类实现ActionListener接口 \nclass DelayActionListener implements ActionListener{ \n    //此为回调方法，当时间到后自动执行actionPerformed方法 \n    @Override \n    public void actionPerformed(ActionEvent e) { \n        System.out.println(\"定时器时间到\"); \n    } \n}\n```\n\n运行结果如下：每隔3秒执行一次。如果需要取消定时器，使用timer.stop()方法即可。\n\n![image](http://img.blog.csdn.net/20141129165207500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n设置定时器的第二种方法是使用Timer结合TimerTask，在android里很常用，其实本来就是java的东西，代码如下：\n\n```\nimport java.util.Timer; \nimport java.util.TimerTask;\npublic class TimerTaskMain { \n    public static void main(String[] args) { \n        //使用TimerTask \n        TimerTask timerTask = new TimerTask() { \n            @Override \n            public void run() { \n                System.out.println(\"timerTask定时器时间到\"); \n            } \n        }; \n        Timer timer = new Timer(); \n        //第一个参数为要执行的目标，第二个参数为第一次执行延迟的时间，第三个参数为循环执行的时间间隔，单位都是毫秒 \n        timer.schedule(timerTask, 3000, 3000); \n    } \n}\n```\n\n运行结果如下：每隔3秒执行一次。如果需要取消定时器，使用timerTask.cancel()方法即可。\n\n![image](http://img.blog.csdn.net/20141129165146918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n有了如上这些东西，再结合GBN的原理和自己控制的逻辑操作，写GBN就应该可以实现了，就不贴完整代码了，自己实现印象更深刻些。\n\nupdate--------\n\n很多人跟我说你的 GBN 程序没源码。。。。虽然这里没贴源码，但我下面给了Github链接了，进去找找就好了，很明显的 GBN 开头的仓库就是了，一定要学会使用Github啊。。。方便的话帮我点几个`star`也好哈。\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2014-11-29-编程实现可靠数据传输原理 Go-Back-N","published":1,"updated":"2015-12-06T02:19:05.000Z","photos":[],"link":"","_id":"ciw22yo0r004wek5xp04cjknm"},{"layout":"post","title":"编程实现路由算法--迪杰斯特拉算法","date":"2014-11-27T07:20:33.000Z","comments":1,"_content":"\n路由算法有很多，本篇采用迪杰斯特拉最短路径法实现简单的路由算法。可能很多人一看到这个就会想到数据结构了，想到数据结构中必须要建立图的结构就很头疼，今天这种写法可以先不采用数据结构书上的写法，也可以实现相同的功能，毕竟，咱们的重点是要学习使用迪杰斯特拉算法，而不是构建图结构。\n\n<!--more-->\n\n首先先来说一下迪杰斯特拉算法，从大概念上来说，该方法属于一种贪心算法，即当加进一个点后，算其相邻所有点的最短路径。详细过程如下：\n\n如下图，要计算其中 点1 到其余各点的最短路径\n\n![image](http://img.blog.csdn.net/20141127161359885)\n\n总的计算过程见下表\n\n![image](http://img.blog.csdn.net/20141127161400447)\n\n表中红颜色代表当前行未加入到点集中的最小值，蓝颜色代表和上一个新加入点集中的点相邻的点，可能这样说还不是很清楚，就看下面的具体过程了。\n\n第一步：初始化，把和 点1 相连的所有点的D（i）初始化，从图中可以看出，1和2、4、5相连，所以D（2）=10，D（4）=30，D（5）=100，点1和点3不直接相连，所以D（3）=65535，代表无穷大（在java里，可以用Integer.MAX_VALUE来表示无穷大）。由于现在点集中只有点1，所以找出刚才步骤1那行中D（i）最小的点，为点2（图中红色标明），将其加入到点集中。\n\n第二步：此时点集中新加入了点2，则以点2为出发点，从图中看到只有点3与其相连，所以这一步中只需要更新D（3）即可，D（3）= min{D（3）， D（2）+ d（2,3）}，即D（3）= min{65535， 10+ 50} = 60，更新D（3）=60，其余点不变。这行更新完毕，发现未加入到点集中的D（4）最小，所以将点4加入到点集中。\n\n第三步： 此时点集中新加入了点4，则以点4为出发点，从图中看到点3和点5与其相连，所以这一步需要更新D（3）和D（5）的值，D（3）= min{D（3）， D（4）+ d（4,3）} ，即D（3） = min{60, 30+20} = 50；D（5） = min{D（5）， D（4）+ d（4,5）} = min {100， 30 + 60} = 90。此时这一行其他数据不用变，此行更新完毕，找出未加入到点集中的 点3、点5 中的最小值，应该是点3，加入到点集中。\n\n第四步，此时点集中新加入了点3，则以点3为出发点，发现点5与其相连，只需要更新D（5）即可。D（5） = min{D（5）， D（3）+ d（3,5）} = min {90， 50 + 10} = 60，此时这行更新完毕，只有最后一个 点5 未加入到点集中了，所以将其加入。\n\n第五步，此时点集中新加入了点5，则以点5为出发点，发现根本没有点与其相连，甚好，此行就不用再更新了。\n\n第六步，机智的我发现所有点都被包含在了点集中，所以本次迪杰斯特拉算法就到此结束了。\n\n剩下的就是代码实现了。\n\n用一个二维数组d[i][j]来存从第i个点到第j个点的路径权重，其中65535为无穷大； 用一个一维数组f[i]才表示从第1个节点到第i个节点的最短路径。\n\n```\n/* \n*王欢   12283013 \n*实验四 编程实现路由算法 \n*/ \npublic class Dijkstra_Router { \n    public static void main(String[] args) throws IOException { \n        Scanner scanner = new Scanner(System.in); \n        int i, j; \n        int n = scanner.nextInt(); \n        //因为第0个单元我不用，所以就多开了两个空间 \n        int[][] d = new int [n+2][n+2];  //二维矩阵存储点之间的距离 \n        int []book = new int [n+2];    //标志数组，book[i]=0代表第i个点未在点集中，book[i]=1代表第i个点在点集中 \n        int []f = new int[n+2];  //f[i]表示从第1个节点到第i个节点的最短路径 \n        int min = 65535, min_pos = 0;   //最小值设置为65535，为了比较出最小值， min_pos表示当前步骤中最小路径值的小标 \n        for (i=0;i<n+2;i++)   //初始化标志数组，并把第一个点添加到点集中，即book[1] = 1 \n            book[i] = 0; \n        book[1] = 1; \n        for (i=1;i<=n;i++) \n            for (j=1;j<=n;j++) \n                d[i][j] = scanner.nextInt();   //读入二维矩阵，表示各个点的连接情况 \n        for (i=2;i<=n;i++) \n            f[i] = d[1][i];   //按照上文所说的第一步进行初始化 \n        System.out.println(\"运算过程：\"); \n        while (containsAllNodes(book, n)){ \n            min = 65535;  //每一步都要比较出最小值，所以记得在每一步的开始初始化一下最小值 \n            for (i=2;i<=n;i++) \n                if (book[i] == 0 && f[i] < min){   //当第i个点未被加入到点集中 && f[i]<min \n                    min = f[i]; \n                    min_pos = i; \n                } \n            book[min_pos] = 1;  //找出当前步骤中最小值的位置为min_pos，即第min_pos个点加入到点集中，book[min_pos] = 1 \n            for (i=1;i<=n;i++) \n                if (d[min_pos][i] != 65535)   //根据上文讲解，f[i] = min{ f[i], f[min_pos] + d[min_pos][i] }  这一步是最重要的，一定要理解。比如上面讲解的第二步中，D（3）= min{D（3）， D（2）+ d（2,3）}，类比一下 \n                    f[i] = f[i] < (f[min_pos] + d[min_pos][i]) ? f[i] : (f[min_pos] + d[min_pos][i]);  \n            for (i=1;i<=n;i++){ \n                System.out.print(f[i] + \" \");  //打印本次运算结果 \n            } \n            System.out.println(); \n        }\n        System.out.println(\"最短路径： \" + f[n]);  //整个过程全部结束了，打印出第1个点到第n个点的最短路径 \n    }\n    //判断是否所有点都被加入到点集中了 \n    private static boolean containsAllNodes(int[] book, int n) { \n        for (int i=1;i<=n;i++){ \n            if (book[i] == 0) \n                return true; \n        } \n        return false; \n    } \n}\n \n```\n\n总结：如果可以熟练的手工算出那张动态表的话，就可以很好的理解迪杰斯特拉算法了。迪杰斯特拉本质上是一种动态规划，每次只能求出一个点到任意一个点的最短距离，而不是任意一个点到任意一个点的最短距离；同时又体现了贪心策略的思想，当一个新的点被加入到点集中时，下一步只需要更新与其直接相连（相邻）的点即可，而不是需要更新所有的点。至于使用什么语言来实现就都无所谓啦。还有如果需要记录最短路径所经过的节点，再增加相应数组编程实现即可。\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###本例代码托管地址:[https://github.com/icodeu/DijkstraForRouter](https://github.com/icodeu/DijkstraForRouter)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/2014-11-27-编程实现路由算法--迪杰斯特拉算法.markdown","raw":"---\nlayout: post\ntitle: \"编程实现路由算法--迪杰斯特拉算法\"\ndate: 2014-11-27 15:20:33 +0800\ncomments: true\ntags: [Java, 路由算法, 迪杰斯特拉]\n---\n\n路由算法有很多，本篇采用迪杰斯特拉最短路径法实现简单的路由算法。可能很多人一看到这个就会想到数据结构了，想到数据结构中必须要建立图的结构就很头疼，今天这种写法可以先不采用数据结构书上的写法，也可以实现相同的功能，毕竟，咱们的重点是要学习使用迪杰斯特拉算法，而不是构建图结构。\n\n<!--more-->\n\n首先先来说一下迪杰斯特拉算法，从大概念上来说，该方法属于一种贪心算法，即当加进一个点后，算其相邻所有点的最短路径。详细过程如下：\n\n如下图，要计算其中 点1 到其余各点的最短路径\n\n![image](http://img.blog.csdn.net/20141127161359885)\n\n总的计算过程见下表\n\n![image](http://img.blog.csdn.net/20141127161400447)\n\n表中红颜色代表当前行未加入到点集中的最小值，蓝颜色代表和上一个新加入点集中的点相邻的点，可能这样说还不是很清楚，就看下面的具体过程了。\n\n第一步：初始化，把和 点1 相连的所有点的D（i）初始化，从图中可以看出，1和2、4、5相连，所以D（2）=10，D（4）=30，D（5）=100，点1和点3不直接相连，所以D（3）=65535，代表无穷大（在java里，可以用Integer.MAX_VALUE来表示无穷大）。由于现在点集中只有点1，所以找出刚才步骤1那行中D（i）最小的点，为点2（图中红色标明），将其加入到点集中。\n\n第二步：此时点集中新加入了点2，则以点2为出发点，从图中看到只有点3与其相连，所以这一步中只需要更新D（3）即可，D（3）= min{D（3）， D（2）+ d（2,3）}，即D（3）= min{65535， 10+ 50} = 60，更新D（3）=60，其余点不变。这行更新完毕，发现未加入到点集中的D（4）最小，所以将点4加入到点集中。\n\n第三步： 此时点集中新加入了点4，则以点4为出发点，从图中看到点3和点5与其相连，所以这一步需要更新D（3）和D（5）的值，D（3）= min{D（3）， D（4）+ d（4,3）} ，即D（3） = min{60, 30+20} = 50；D（5） = min{D（5）， D（4）+ d（4,5）} = min {100， 30 + 60} = 90。此时这一行其他数据不用变，此行更新完毕，找出未加入到点集中的 点3、点5 中的最小值，应该是点3，加入到点集中。\n\n第四步，此时点集中新加入了点3，则以点3为出发点，发现点5与其相连，只需要更新D（5）即可。D（5） = min{D（5）， D（3）+ d（3,5）} = min {90， 50 + 10} = 60，此时这行更新完毕，只有最后一个 点5 未加入到点集中了，所以将其加入。\n\n第五步，此时点集中新加入了点5，则以点5为出发点，发现根本没有点与其相连，甚好，此行就不用再更新了。\n\n第六步，机智的我发现所有点都被包含在了点集中，所以本次迪杰斯特拉算法就到此结束了。\n\n剩下的就是代码实现了。\n\n用一个二维数组d[i][j]来存从第i个点到第j个点的路径权重，其中65535为无穷大； 用一个一维数组f[i]才表示从第1个节点到第i个节点的最短路径。\n\n```\n/* \n*王欢   12283013 \n*实验四 编程实现路由算法 \n*/ \npublic class Dijkstra_Router { \n    public static void main(String[] args) throws IOException { \n        Scanner scanner = new Scanner(System.in); \n        int i, j; \n        int n = scanner.nextInt(); \n        //因为第0个单元我不用，所以就多开了两个空间 \n        int[][] d = new int [n+2][n+2];  //二维矩阵存储点之间的距离 \n        int []book = new int [n+2];    //标志数组，book[i]=0代表第i个点未在点集中，book[i]=1代表第i个点在点集中 \n        int []f = new int[n+2];  //f[i]表示从第1个节点到第i个节点的最短路径 \n        int min = 65535, min_pos = 0;   //最小值设置为65535，为了比较出最小值， min_pos表示当前步骤中最小路径值的小标 \n        for (i=0;i<n+2;i++)   //初始化标志数组，并把第一个点添加到点集中，即book[1] = 1 \n            book[i] = 0; \n        book[1] = 1; \n        for (i=1;i<=n;i++) \n            for (j=1;j<=n;j++) \n                d[i][j] = scanner.nextInt();   //读入二维矩阵，表示各个点的连接情况 \n        for (i=2;i<=n;i++) \n            f[i] = d[1][i];   //按照上文所说的第一步进行初始化 \n        System.out.println(\"运算过程：\"); \n        while (containsAllNodes(book, n)){ \n            min = 65535;  //每一步都要比较出最小值，所以记得在每一步的开始初始化一下最小值 \n            for (i=2;i<=n;i++) \n                if (book[i] == 0 && f[i] < min){   //当第i个点未被加入到点集中 && f[i]<min \n                    min = f[i]; \n                    min_pos = i; \n                } \n            book[min_pos] = 1;  //找出当前步骤中最小值的位置为min_pos，即第min_pos个点加入到点集中，book[min_pos] = 1 \n            for (i=1;i<=n;i++) \n                if (d[min_pos][i] != 65535)   //根据上文讲解，f[i] = min{ f[i], f[min_pos] + d[min_pos][i] }  这一步是最重要的，一定要理解。比如上面讲解的第二步中，D（3）= min{D（3）， D（2）+ d（2,3）}，类比一下 \n                    f[i] = f[i] < (f[min_pos] + d[min_pos][i]) ? f[i] : (f[min_pos] + d[min_pos][i]);  \n            for (i=1;i<=n;i++){ \n                System.out.print(f[i] + \" \");  //打印本次运算结果 \n            } \n            System.out.println(); \n        }\n        System.out.println(\"最短路径： \" + f[n]);  //整个过程全部结束了，打印出第1个点到第n个点的最短路径 \n    }\n    //判断是否所有点都被加入到点集中了 \n    private static boolean containsAllNodes(int[] book, int n) { \n        for (int i=1;i<=n;i++){ \n            if (book[i] == 0) \n                return true; \n        } \n        return false; \n    } \n}\n \n```\n\n总结：如果可以熟练的手工算出那张动态表的话，就可以很好的理解迪杰斯特拉算法了。迪杰斯特拉本质上是一种动态规划，每次只能求出一个点到任意一个点的最短距离，而不是任意一个点到任意一个点的最短距离；同时又体现了贪心策略的思想，当一个新的点被加入到点集中时，下一步只需要更新与其直接相连（相邻）的点即可，而不是需要更新所有的点。至于使用什么语言来实现就都无所谓啦。还有如果需要记录最短路径所经过的节点，再增加相应数组编程实现即可。\n\n###个人github:  [http://github.com/icodeu](http://github.com/icodeu)\n\n###本例代码托管地址:[https://github.com/icodeu/DijkstraForRouter](https://github.com/icodeu/DijkstraForRouter)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"2014-11-27-编程实现路由算法--迪杰斯特拉算法","published":1,"updated":"2015-08-24T10:26:13.000Z","photos":[],"link":"","_id":"ciw22yo0t0050ek5xteodkndd"},{"layout":"post","title":"Java 实现 AES 算法","date":"2014-10-31T07:20:33.000Z","comments":1,"_content":"\n密码学课上学习了AES算法，balabala原理上有些听不懂，如果是日常应用，可以用java实现好的东西来搬过来用。\n\n<!--more-->\n\n首先建了一个自己的AES工具类，里面写上了静态的加密和解密函数供之后使用。\n\nAES工具类和加解密函数如下：\n{% codeblock lang:java %}\npublic class MyAESUtils {\n\tpublic static byte[] encrypt(String content, String password) {\n\t\ttry {\n\t\t\tKeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\t\t\tkgen.init(128, new SecureRandom(password.getBytes()));\t\t\tSecretKey secretKey = kgen.generateKey();\n\t\t\tbyte[] enCodeFormat = secretKey.getEncoded();\n\t\t\tSecretKeySpec key = new SecretKeySpec(enCodeFormat, \"AES\");\n\t\t\tCipher cipher = Cipher.getInstance(\"AES\");\n\t\t\tbyte[] byteContent = content.getBytes(\"utf-8\");\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, key);\n\t\t\tbyte[] result = cipher.doFinal(byteContent);\n\t\t\treturn result;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static byte[] decrypt(byte[] content, String password) {\n\t\ttry {\n\t\t\tKeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\t\t\tkgen.init(128, new SecureRandom(password.getBytes()));\n\t\t\tSecretKey secretKey = kgen.generateKey();\n\t\t\tbyte[] enCodeFormat = secretKey.getEncoded();\n\t\t\tSecretKeySpec key = new SecretKeySpec(enCodeFormat, \"AES\");\n\t\t\tCipher cipher = Cipher.getInstance(\"AES\");\n\t\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n\t\t\tbyte[] result = cipher.doFinal(content);\n\t\t\treturn result;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\t\n}\n{% endcodeblock %}\n\n以上的类库不需要额外的jar包，直接在Eclipse里按`Ctrl+O`快捷键自动导入就好了。接下来实现主函数：\n\n\tpublic class AESMain {\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tSystem.out.println(\"请输入明文\");\n\t\t\tString content = in.nextLine();\n\t\t\tSystem.out.println(\"请输入密钥\");\n\t\t\tString key = in.nextLine();\n\t\t\t\n\t\t\tbyte[] encryptResult = MyAESUtils.encrypt(content, key);\n\t\t\tSystem.out.println(\"加密后密文为： \" + encryptResult);\n\t\t\t\n\t\t\tbyte[] decryptResult = MyAESUtils.decrypt(encryptResult, key);\n\t\t\tSystem.out.println(\"解密后原文为： \" + new String(decryptResult));\n\t\n\t\t}\n\t}\n\n很简单的一段代码就实现了基于AES算法的加解密，不过仅仅这样做还是不懂AES的原理的，就需要阅读源码看一下了。不过应用的话，这样基本上就行了。\n\n \n###个人github: [http://github.com/icodeu](http://github.com/icodeu)\n\n###代码托管地址:[https://github.com/icodeu/AES4JAVA](https://github.com/icodeu/AES4JAVA)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n\n\n","source":"_posts/2014-10-31-Java 实现 AES 算法.markdown","raw":"---\nlayout: post\ntitle: \"Java 实现 AES 算法\"\ndate: 2014-10-31 15:20:33 +0800\ncomments: true\ntags: [Java, AES]\n---\n\n密码学课上学习了AES算法，balabala原理上有些听不懂，如果是日常应用，可以用java实现好的东西来搬过来用。\n\n<!--more-->\n\n首先建了一个自己的AES工具类，里面写上了静态的加密和解密函数供之后使用。\n\nAES工具类和加解密函数如下：\n{% codeblock lang:java %}\npublic class MyAESUtils {\n\tpublic static byte[] encrypt(String content, String password) {\n\t\ttry {\n\t\t\tKeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\t\t\tkgen.init(128, new SecureRandom(password.getBytes()));\t\t\tSecretKey secretKey = kgen.generateKey();\n\t\t\tbyte[] enCodeFormat = secretKey.getEncoded();\n\t\t\tSecretKeySpec key = new SecretKeySpec(enCodeFormat, \"AES\");\n\t\t\tCipher cipher = Cipher.getInstance(\"AES\");\n\t\t\tbyte[] byteContent = content.getBytes(\"utf-8\");\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, key);\n\t\t\tbyte[] result = cipher.doFinal(byteContent);\n\t\t\treturn result;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static byte[] decrypt(byte[] content, String password) {\n\t\ttry {\n\t\t\tKeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\t\t\tkgen.init(128, new SecureRandom(password.getBytes()));\n\t\t\tSecretKey secretKey = kgen.generateKey();\n\t\t\tbyte[] enCodeFormat = secretKey.getEncoded();\n\t\t\tSecretKeySpec key = new SecretKeySpec(enCodeFormat, \"AES\");\n\t\t\tCipher cipher = Cipher.getInstance(\"AES\");\n\t\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n\t\t\tbyte[] result = cipher.doFinal(content);\n\t\t\treturn result;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\t\n}\n{% endcodeblock %}\n\n以上的类库不需要额外的jar包，直接在Eclipse里按`Ctrl+O`快捷键自动导入就好了。接下来实现主函数：\n\n\tpublic class AESMain {\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tSystem.out.println(\"请输入明文\");\n\t\t\tString content = in.nextLine();\n\t\t\tSystem.out.println(\"请输入密钥\");\n\t\t\tString key = in.nextLine();\n\t\t\t\n\t\t\tbyte[] encryptResult = MyAESUtils.encrypt(content, key);\n\t\t\tSystem.out.println(\"加密后密文为： \" + encryptResult);\n\t\t\t\n\t\t\tbyte[] decryptResult = MyAESUtils.decrypt(encryptResult, key);\n\t\t\tSystem.out.println(\"解密后原文为： \" + new String(decryptResult));\n\t\n\t\t}\n\t}\n\n很简单的一段代码就实现了基于AES算法的加解密，不过仅仅这样做还是不懂AES的原理的，就需要阅读源码看一下了。不过应用的话，这样基本上就行了。\n\n \n###个人github: [http://github.com/icodeu](http://github.com/icodeu)\n\n###代码托管地址:[https://github.com/icodeu/AES4JAVA](https://github.com/icodeu/AES4JAVA)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n\n\n","slug":"2014-10-31-Java 实现 AES 算法","published":1,"updated":"2015-08-24T10:26:00.000Z","photos":[],"link":"","_id":"ciw22yo0v0056ek5x2eqdl7x6"},{"layout":"post","title":"使用 Wireshark 抓包分析的思考","date":"2014-10-25T07:20:33.000Z","comments":1,"_content":"\n上一篇文章提到了一个问题，即为什么telnet登陆pop邮箱的时候用的是明文，至今不解，为了打消telnet会帮我进行加密传输的小疑问，所以就使用wireshark来看一下数据包的内容。\n\n<!--more-->\n\n依旧使用163邮箱作为实验。打开wireshark，让其抓取我本机网卡的数据包，开始抓包后，通过在cmd中 telnet pop.163.com 110 登陆163服务器，在wireshark里设置过滤规则:  tcp.port==110 (因为pop默认使用110号端口),我每在命令行里输入一个字符，（不用打回车），在wireshark里可以看到数据被封包后发出去了，这也印证了我上篇文章提到过的输入错了按空格是没用的，因为它已经发出去了！我测试输入 `user wanghuan`,`pass wanghuan`，可以明显看到telnet用明文把我输入的内容发送出去了，见下图：\n\n![image](http://img.blog.csdn.net/20141025175729755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n好了，对于为什么pop使用明文，我还是不明白，若谁能明白，希望能帮我讲解一下。\n\n接下来，我又实验了自己学校的邮箱服务器，通过网页形式登陆，发现传输的依旧是明文，实验过程为：wireshark开始抓包，打开邮箱网页，正常登陆，在wireshark中寻找数据包并设置过滤规则，查看数据包。结果如下图：\n\n![image](http://img.blog.csdn.net/20141025175804153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![image](http://img.blog.csdn.net/20141025175821984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n紧接着，我又测试了foxmail邮件客户端软件，尝试用其登陆我的新浪邮箱，对其进行抓包分析。发现foxmail在往外发数据的时候居然也是明文，结果如下：\n\n![image](http://img.blog.csdn.net/20141025175838036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n我顿时就蒙了，是对邮箱服务器本来就可以明文传输，还是我现在实验的对象都对安全问题考虑不周呢？\n\n然后，我选择了新浪邮箱，这个应该还算是国内比较常用的邮箱之一了，如果它都是用明文传输的话，我真是疯了。\n\n所以，赶紧实验，方法如上一样，继续用wireshark，结果如下图所示：\n\n![image](http://img.blog.csdn.net/20141025175856304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这时我发现，我在登陆新浪邮箱的时候，从我网卡里传输出去的数据包是经过`SSL`加密了的（Secure Socket Layer），`不是明文`。其实这才是我预想中的结果，我觉得像用户名密码这种东西在网络上传输必须加密,至少新浪邮箱给了我一点安慰。\n\nwireshark这个东西很强大，但是现在还抓不了局域网中的包，尤其是某些宿舍使用了360安全路由器后。。。\n \n###个人github: [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n\n\n\n","source":"_posts/2014-10-25-使用 Wireshark 抓包分析的思考.markdown","raw":"---\nlayout: post\ntitle: \"使用 Wireshark 抓包分析的思考\"\ndate: 2014-10-25 15:20:33 +0800\ncomments: true\ntags: [Wireshark]\n---\n\n上一篇文章提到了一个问题，即为什么telnet登陆pop邮箱的时候用的是明文，至今不解，为了打消telnet会帮我进行加密传输的小疑问，所以就使用wireshark来看一下数据包的内容。\n\n<!--more-->\n\n依旧使用163邮箱作为实验。打开wireshark，让其抓取我本机网卡的数据包，开始抓包后，通过在cmd中 telnet pop.163.com 110 登陆163服务器，在wireshark里设置过滤规则:  tcp.port==110 (因为pop默认使用110号端口),我每在命令行里输入一个字符，（不用打回车），在wireshark里可以看到数据被封包后发出去了，这也印证了我上篇文章提到过的输入错了按空格是没用的，因为它已经发出去了！我测试输入 `user wanghuan`,`pass wanghuan`，可以明显看到telnet用明文把我输入的内容发送出去了，见下图：\n\n![image](http://img.blog.csdn.net/20141025175729755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n好了，对于为什么pop使用明文，我还是不明白，若谁能明白，希望能帮我讲解一下。\n\n接下来，我又实验了自己学校的邮箱服务器，通过网页形式登陆，发现传输的依旧是明文，实验过程为：wireshark开始抓包，打开邮箱网页，正常登陆，在wireshark中寻找数据包并设置过滤规则，查看数据包。结果如下图：\n\n![image](http://img.blog.csdn.net/20141025175804153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![image](http://img.blog.csdn.net/20141025175821984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n紧接着，我又测试了foxmail邮件客户端软件，尝试用其登陆我的新浪邮箱，对其进行抓包分析。发现foxmail在往外发数据的时候居然也是明文，结果如下：\n\n![image](http://img.blog.csdn.net/20141025175838036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n我顿时就蒙了，是对邮箱服务器本来就可以明文传输，还是我现在实验的对象都对安全问题考虑不周呢？\n\n然后，我选择了新浪邮箱，这个应该还算是国内比较常用的邮箱之一了，如果它都是用明文传输的话，我真是疯了。\n\n所以，赶紧实验，方法如上一样，继续用wireshark，结果如下图所示：\n\n![image](http://img.blog.csdn.net/20141025175856304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这时我发现，我在登陆新浪邮箱的时候，从我网卡里传输出去的数据包是经过`SSL`加密了的（Secure Socket Layer），`不是明文`。其实这才是我预想中的结果，我觉得像用户名密码这种东西在网络上传输必须加密,至少新浪邮箱给了我一点安慰。\n\nwireshark这个东西很强大，但是现在还抓不了局域网中的包，尤其是某些宿舍使用了360安全路由器后。。。\n \n###个人github: [http://github.com/icodeu](http://github.com/icodeu)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n\n\n\n","slug":"2014-10-25-使用 Wireshark 抓包分析的思考","published":1,"updated":"2015-08-24T10:25:45.000Z","photos":[],"link":"","_id":"ciw22yo0x005aek5x1xxzz6fg"},{"layout":"post","title":"再谈用 Java 实现 SMTP 发送邮件之 Socket 编程","date":"2014-10-20T07:20:33.000Z","comments":1,"_content":"\n&nbsp;&nbsp;&nbsp;&nbsp;前几天利用Socket实现了用java语言搭建web服务器，全程下来应该会对Socket这个东西已经使用的非常熟悉了，虽然抽象，但是使用过一次之后就会感受到它在网络通信上的作用是多么的强大！正好，今天就继续用Socket来练习使用以下Smtp协议发送一封简单的电子邮件。今天的故事呢，是我要约我女神出去吃饭啦啦啦~~~所以，面对Smtp，只许成功，不许失败！\n\n<!--more-->\n\n&nbsp;&nbsp;&nbsp;&nbsp;全局假定我的邮箱为`cnsmtp01@163.com`   女神的邮箱为`cnsmtp02@163.com`  密码都是 `computer` （呦，还是个情侣邮箱~）\n\n&nbsp;&nbsp;&nbsp;&nbsp;为了更加体现程序员的高大上，所以我选择使用命令行的方式（SB程序员。。。）。打开cmd，在命令行里输入telnet，“嗯，居然给我显示telnet不是内部或外部命令”！完蛋，怎么办，这才第一步，就出师不利啊，看来今天要跪，赶快想解决办法。进入 控制面板---程序和功能---启动或关闭windows功能---telnet客户端，勾选上然后确定即可（有些人的电脑还会看到“telnet服务端”，注意别选错了，服务端是指你的电脑作为服务器让别人登陆的，而咱们现在要做的是自己的电脑作为客户端登陆邮箱服务器）\n\n![image](http://img.blog.csdn.net/20141020210951406)\n\n&nbsp;&nbsp;&nbsp;&nbsp;再在cmd中试一下，直接输入 `telnet smtp.163.com 25` ,第一行会显示邮件服务器返回的欢迎信息，我这里返回的就是 “220 163.com Anti-spam GT for Coremail System (163com[20121016])” 其中220说明邮件服务器跟我已经建立了连接，它已经开始想要帮帮我了，哈哈。友好一点，跟服务器大哥打个招呼吧，输入`HELO huan` ，（huan是随便输入的，输入什么都行，服务器是不会鸟你到底输入的是什么），这时服务器返回的是“250 OK”，说明现在服务器等着我继续发送命令了。输入 `MAIL FROM:<cnsmtp01@163.com>` 这时服务器居然给我返回了553，并告诉我需要认证。也是，既然登陆人家的服务器，总得有个人家的账号吧。所以接下来输入`AUTH LOGIN`，服务器返回了334和我看不懂的东西，这是要求咱们要输入用户名和密码信息了。但是都知道，像用户名密码这种信息是不能在互联网里进行明文传输的，而smtp服务器用户名和密码采用的是base64编码加密方式，所以在百度搜一个在线base64加密网站就好了，（比如http://base64.xpcha.com/），如图\n\n![image](http://img.blog.csdn.net/20141020211334751)\n\n&nbsp;&nbsp;&nbsp;&nbsp;把得到的密文往控制台中粘贴后回车，这时服务器会再要求我输入密码，跟刚才的方式一样即可，如果正确的话，会返回235，并告诉我认证成功了。Perfect！已经进展到一半了，继续！我下面就要告诉服务器从哪个邮箱发，发给谁，所以依次输入`MAIL FROM:<cnsmtp01@163.com>`  回车 `RCPT TO:<cnsmtp02@163.com>` 回车   发件人和收件人设置好后，自然该告诉服务器我要发的内容是什么了，所以输入`DATA`后回车，服务器返回给我354，并让我输入，以`<CR><LF>.<CR><LF>`结尾，好，那就直接输入正文： Can I date with you?   然后`“回车” “.” “回车”`来告诉服务器我的内容输入完毕了，它可以发送了。这个时候触目惊心的一幕出现了，服务器并没有给我返回2XX的正确码，而是给我返回了554，这是为什么，服务器大哥不肯帮我了？\n![image](http://img.blog.csdn.net/20141020211335234)\n\n&nbsp;&nbsp;&nbsp;&nbsp;看着它给我的链接，像是163自己的错误说明文档，我就复制下来了，打开浏览器查看了一下，原来是163服务器认为我发的是垃圾邮件，所以它拒绝给我发信。可是大哥，我这是真心的啊，哪是什么垃圾邮件啊，求求你就让我发送吧（想想也是，如果好多人都这样给女神发了一堆的垃圾邮件，我会不高兴的%>_<%）。分析一下为什么会被认为是垃圾邮件吧：邮件得有主题（subject），发件人（from），收件人（to），邮件正文等，可是我只写了个邮件正文，也许服务器就把这个当成是垃圾邮件了。嗯，越臆想就觉得越有道理，来试一下吧。这次我输入了`DATA`后，服务器让我输入内容，我先输入了`subject:Would you go on a date with me ?`  然后回车 `from:cnsmtp01@163.com`  回车  `to:cnsmtp02@163.com` 回车 `Can you eat a meal together?`    `回车 . 回车`    哈哈，这个时候服务器给我返回的是Mail OK，我发送成功了！接下来就是要等待女神的答复了。。。全部过程见下图：（留个问题，女神的邮箱里肯定会收到这封邮件，但是会收到我原本想发的正文“Can you eat a meal together?  ”吗？如果不知道，查一下报文格式，或见下面的java程序，对比一下正文部分后面的数据格式区别）\n![image](http://img.blog.csdn.net/20141020211335827)\n\n&nbsp;&nbsp;&nbsp;&nbsp;全部过程：\n\n\ttelnet smtp.163.com 25\n\tS: 220 163.com Anti-spam GT for Coremail System <163com[20121016]>\n\tC: HELO huan\n\tS: 250 OK\n\tC: AUTH LOGIN\n\tS: 334 dXNlcm5hbWU6\n\tC: Y25zbXRwMDE=\n\tS: 334 UGFzc3dvcmQ6\n\tC: Y29tcHV0ZXI=\n\tS: 235 Authentication successful\n\tC: MAIL FROM:<cnsmtp01@163.com>\n\tS: 250 Mail OK\n\tC: RCPT TO:<cnsmtp02@163.com>\n\tS: 250 Mail OK\n\tC: DATA\n\tS: 354 End data with <CR><LF>.<CR><LF>\n\tC: subject:Would you go on a date with me ?\n\tC: from:cnsmtp01@163.com\n\tC: to:cnsmtp02@163.com\n\tC: Can you eat a meal together?\n\tC: .\n\tS: 250 Mail OK queued as smtp7,C8CowEDpwFYP_ERUQxX8AA--.14S2 1413807190\n\tC: RSET\n\tS: 250 OK\n\tC: QUIT\n\tS: 221 Bye\n\n&nbsp;&nbsp;&nbsp;&nbsp;时候差不多了，我觉得女神应该会给我回复邮件了，怎么看，打开浏览器进入163邮箱吗？太out、太low了，直接命令行吧！ `telnet pop.163.com 110` ，刚才已经演示了全部的smtp命令，所以操作起来pop的应该很简单了，直接上图：\n![image](http://img.blog.csdn.net/20141020211336498)\n\n&nbsp;&nbsp;&nbsp;&nbsp;看到女神回复我什么了吗。。。简直狗血。。。\n\n&nbsp;&nbsp;&nbsp;&nbsp;好了，一次的收发邮件过程全都解决了，而且结果是，，，被拒了。其实呢，刚才没说，我的女神是编号的，从女神0号，女神1号…女神n号，难道刚刚第0个女神拒绝我后我就颓了吗？那怎么行，我得越挫越勇啊，继续给剩下的女神发邮件。可是，我这么多女神，我不能给每个女神发邮件都用这种命令行方式吧，那不虚死我，那么问题来了——发邮件技术哪家强？ 既然咱们是学计算机的，那就编软件呗，让软件替咱们批量发，简直Perfect！\n\n&nbsp;&nbsp;&nbsp;&nbsp;所以又回到这次的议题上来了，怎么用java实现smtp发送邮件？对，还是要请出大神`Socket`来帮忙。经历了上次Socket的折磨和刚才命令行的磨练，接下来就是把他们巧妙融合的时候了，所以，别走开。\n\n&nbsp;&nbsp;&nbsp;&nbsp;1、定义一些咱们一会会用到的邮箱名，用户名密码等信息（正常编程没人会把用户名和密码写的这么明白。。。）：\n\n\tString sender = \"cnsmtp01@163.com\"; \n\tString receiver = \"cnsmtp02@163.com\"; \n\tString password = \"computer\";\n\t//上文说过，这个用户名和密码是要使用base64进行加密的，加密方法见下文附录1详解 \n\tString user = new BASE64Encoder().encode(sender.substring(0, sender.indexOf(\"@\")).getBytes());  //截取出“cnsmtp01”并加密 \n\tString pass = new BASE64Encoder().encode(password.getBytes());   //加密 “computer”\n\n&nbsp;&nbsp;&nbsp;&nbsp;2、建立Socket连接:\n\n\tSocket socket = new Socket(\"smtp.163.com\", 25);  //smtp服务使用25号端口监听\n\n&nbsp;&nbsp;&nbsp;&nbsp;3、获取该socket的输入输出流\n\n\tInputStream inputStream = socket.getInputStream(); \n\tOutputStream outputStream = socket.getOutputStream(); \n\tBufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); \n\tPrintWriter writter = new PrintWriter(outputStream, true);  //我TM去 这个true太关键了，我刚才没写这个别坑了!你可以不加这个试下效果，下文附录2会写到为什么加true\n\n&nbsp;&nbsp;&nbsp;&nbsp;4、发送HELO信息\n\n\t//HELO \n\twritter.println(\"HELO huan\"); \n\tSystem.out.println(reader.readLine());\n\n&nbsp;&nbsp;&nbsp;&nbsp;5、发送AUTH LOGIN信息\n\n\t//AUTH LOGIN \n\twritter.println(\"auth login\"); \n\tSystem.out.println(reader.readLine()); \n\twritter.println(user); \n\tSystem.out.println(reader.readLine()); \n\twritter.println(pass); \n\tSystem.out.println(reader.readLine()); \n\t//Above   Authentication successful\n\n&nbsp;&nbsp;&nbsp;&nbsp;6、发送发件人和收件人信息\n\n\t//Set mail from   and   rcpt to \n\twritter.println(\"mail from:<\" + sender +\">\"); \n\tSystem.out.println(reader.readLine()); \n\twritter.println(\"rcpt to:<\" + receiver +\">\"); \n\tSystem.out.println(reader.readLine());\n\n&nbsp;&nbsp;&nbsp;&nbsp;7、告诉服务器我要传数据\n\n\t//Set data \n\twritter.println(\"data\"); \n\tSystem.out.println(reader.readLine());\n\n&nbsp;&nbsp;&nbsp;&nbsp;8、发邮件主题，收件人，发件人，正文\n\n\twritter.println(\"subject:女神，是我\");   \n\twritter.println(\"from:\" + sender);   \n\twritter.println(\"to:\" + receiver);   \n\twritter.println(\"Content-Type: text/plain;charset=\\\"gb2312\\\"\");//如果发送正文必须加这个，而且下面要有一个空行   \n\twritter.println();   \n\twritter.println(\"女神，晚上可以共进晚餐吗？\");   \n\twritter.println(\".\");//告诉服务器我发送的内容完毕了   \n\twritter.println(\"\");   \n\tSystem.out.println(reader.readLine());  \n\n&nbsp;&nbsp;&nbsp;&nbsp;9、帮你发了邮件，感谢服务器，和它Say Goodbye吧，都不用请它吃饭，多好\n\n\twritter.println(\"rset\"); \n\tSystem.out.println(reader.readLine()); \n\twritter.println(\"quit\"); \n\tSystem.out.println(reader.readLine());\n\n&nbsp;&nbsp;&nbsp;&nbsp;所以，加上异常等操作，所有的代码如下：\n\n\tpublic class SMTPMain {\n    public static void main(String[] args) { \n        String sender = \"cnsmtp01@163.com\"; \n        String receiver = \"cnsmtp02@163.com\"; \n        String password = \"computer\"; \n        String user = new BASE64Encoder().encode(sender.substring(0, sender.indexOf(\"@\")).getBytes()); \n        String pass = new BASE64Encoder().encode(password.getBytes());\n        try { \n            Socket socket = new Socket(\"smtp.163.com\", 25); \n            InputStream inputStream = socket.getInputStream(); \n            OutputStream outputStream = socket.getOutputStream(); \n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); \n            PrintWriter writter = new PrintWriter(outputStream, true);  //我TM去 这个true太关键了! \n            System.out.println(reader.readLine()); \n            //HELO \n            writter.println(\"HELO huan\"); \n            System.out.println(reader.readLine()); \n            //AUTH LOGIN \n            writter.println(\"auth login\"); \n            System.out.println(reader.readLine()); \n            writter.println(user); \n            System.out.println(reader.readLine()); \n            writter.println(pass); \n            System.out.println(reader.readLine()); \n            //Above   Authentication successful             \n\t\t\t\n\t\t\t//Set mail from   and   rcpt to \n            writter.println(\"mail from:<\" + sender +\">\"); \n            System.out.println(reader.readLine()); \n            writter.println(\"rcpt to:<\" + receiver +\">\"); \n            System.out.println(reader.readLine()); \n           \n            //Set data \n            writter.println(\"data\"); \n            System.out.println(reader.readLine()); \n            writter.println(\"subject:女神，是我\"); \n            writter.println(\"from:\" + sender); \n            writter.println(\"to:\" + receiver); \n            writter.println(\"Content-Type: text/plain;charset=\\\"gb2312\\\"\"); \n            writter.println(); \n            writter.println(\"女神，晚上可以共进晚餐吗？\"); \n            writter.println(\".\"); \n            writter.println(\"\"); \n            System.out.println(reader.readLine()); \n\n            //Say GoodBye\n            writter.println(\"rset\"); \n            System.out.println(reader.readLine()); \n            writter.println(\"quit\"); \n            System.out.println(reader.readLine()); \n            } catch (Exception e) {\n                 e.printStackTrace(); \n            } \n        } \n\t}\n\n&nbsp;&nbsp;&nbsp;&nbsp;这下，我完全不怵蓝翔的挖掘机了，这简直就是我的约会神器，只要把女神x号的邮箱一改，程序一运行，我这邮件就瞬间发出去了，哈哈，简直机智如狗。\n现在运行程序，看控制台输出\n![image](http://img.blog.csdn.net/20141020231432656)\n\n&nbsp;&nbsp;&nbsp;&nbsp;多次运行程序，女神1号，2号…的邮箱里都收到了如下图的邮件（可以把多个女神的邮箱加到集合[list map vector…]里，然后再一循环，分分钟搞定）\n![image](http://img.blog.csdn.net/20141020231433437)\n\n&nbsp;&nbsp;&nbsp;&nbsp;至于什么界面什么的，就仁者见仁智者见智吧，习惯java的就swing，习惯android也可以xml，其实我是觉得android更方便一些，控件更容易用一些。若是用java写界面忘了的话，推荐使用 `windows builder` ， 可以帮你很快绘制出界面来，然后你要做的就是获取控件，写监听器等等。\n \n* 附录1：\n关于base64加密：\n具体什么是base64加密，这种概念性的东西能在百度百科找到的我就不说了，说一下在java里怎么去用它。\n1、首先下载一个工具jar文件，叫做“sun.misc.BASE64Decoder.jar” （百度搜就能找到，如果找不到可以到我最后提供的本人github上去下载下来使用）\n2、有了jar文件后，需要把jar包导入工程，方法为：右键工程名—Build Path—Configure Build Path—Add External JARS，选择你刚下载的jar包后确定就可以了\n3、之后在java文件里写到 new BASE64Encoder().encode(password.getBytes());  时，会提示没有导入对应的包，可以按Ctrl + Shift + O(欧)来让IDE自动为我们导入（前提是你的jar包导入没问题）\n \n* 附录2：\n说说PrintWriter.println()方法(或write()方法，其实就差了一个换行，剩下参数什么的都一样)。PrintWriter writter = new PrintWriter(outputStream, true);  在PrintWritter的构造函数中，可以不加true，也可以加true，区别在于：加了true的话，在下面进行writter.println(“helloworld”);后，“helloworld”就会立即发送出去；相反，不加true的话，必须在writter.println(“helloworld”);后 再调用writter.flush();来清空缓冲区，强制发送出去。我开始就没有加true，而且没调用flush()方法，我以为是服务器SB了，结果。。。。\n \n>* 附录3：\n为什么telnet pop协议时登录服务器输入用户名和密码时会明文，这让我很奇怪，希望有人帮我解答。\n \n* 附录4：\n有没有注意到在使用smtp协议时，认证的时候需要你输入发送人信息，输入data后又要写一遍发件人的信息？难道服务器傻吗，非要让你输入两遍？可以想一想为什么，然后自己亲自尝试一下，由于咱们平时用的邮件代理都把这两个认为是同一个了，所以掩盖了一个发送邮件时候的小技巧，即可以伪装欺骗，具体的自己试一下，印象才会更深刻。\n \n* 附录5：\n大小写问题。有没有注意到我在cmd里输入的命令部分都是大写，而在java程序里输出的命令部分都是小写？我是想说，命令部分是不区分大小写的，但是命令后面的参数是严格区分大小写的，自己可以试一下。（例如邮箱用户名和密码本来就是区分大小写的吧）\n \n* 附录6：\n关于telnet本身的问题。在telnet里的一行输入了错误的数据，我想删除，然后再继续输入正确的，回车。这个时候你会发现明明输入的没有问题，可是服务器返回的却是错误代码，比如 500 Error：bad syntax    原因就在于命令你要一次性输入正确，如果中途输错了，不用退格，已经晚了，直接打个回车，肯定会报错，再出入正确的就好了。如果总是打错，像163服务器就直接给你断开连接，它以为你恶意要攻击它呢。像新浪的邮箱服务器，就很忠诚，在有效连接时间内一直等着你输入正确的命令，这点可以自己试一下。\n\n* 附录7：\n记得之前在linux中用shell发送邮件时，并没有强制要求我必须用合法的身份登录邮箱服务器才能进行发邮件操作，为什么？因为那个时候我自己的本机相当于是SMTP服务器，我自己当然就不用验证身份了。而现在是想用SMTP协议登录别人的服务器（如163），此时163就必须要合法的用户身份才能使其登录并发邮件了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;针对此篇文章还要说明的：这只是为了理解SMTP的一篇很基础性的讲解，对于代码部分，为了体现主体，明显缺少通过服务器返回代码判断语句，因而以上程序缺少健壮性，自己在理解好实际编程时应该考虑到真正的网络请求情况，考虑丢包情况，根据服务器返回代码进行相应判断。\n \n&nbsp;&nbsp;&nbsp;&nbsp;好了，就写到这了，我要去和女神吃饭饭了~哪里有问题可以在下面留言~\n \n###个人github: [http://github.com/icodeu](http://github.com/icodeu)\n\n###代码托管地址:[http://github.com/icodeu/JavaForSMTP](http://github.com/icodeu/JavaForSMTP)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n\n","source":"_posts/2014-10-20-再谈用 Java 实现 SMTP 发送邮件之 Socket 编程.markdown","raw":"---\nlayout: post\ntitle: \"再谈用 Java 实现 SMTP 发送邮件之 Socket 编程\"\ndate: 2014-10-20 15:20:33 +0800\ncomments: true\ntags: [Java, Socket, SMTP]\n---\n\n&nbsp;&nbsp;&nbsp;&nbsp;前几天利用Socket实现了用java语言搭建web服务器，全程下来应该会对Socket这个东西已经使用的非常熟悉了，虽然抽象，但是使用过一次之后就会感受到它在网络通信上的作用是多么的强大！正好，今天就继续用Socket来练习使用以下Smtp协议发送一封简单的电子邮件。今天的故事呢，是我要约我女神出去吃饭啦啦啦~~~所以，面对Smtp，只许成功，不许失败！\n\n<!--more-->\n\n&nbsp;&nbsp;&nbsp;&nbsp;全局假定我的邮箱为`cnsmtp01@163.com`   女神的邮箱为`cnsmtp02@163.com`  密码都是 `computer` （呦，还是个情侣邮箱~）\n\n&nbsp;&nbsp;&nbsp;&nbsp;为了更加体现程序员的高大上，所以我选择使用命令行的方式（SB程序员。。。）。打开cmd，在命令行里输入telnet，“嗯，居然给我显示telnet不是内部或外部命令”！完蛋，怎么办，这才第一步，就出师不利啊，看来今天要跪，赶快想解决办法。进入 控制面板---程序和功能---启动或关闭windows功能---telnet客户端，勾选上然后确定即可（有些人的电脑还会看到“telnet服务端”，注意别选错了，服务端是指你的电脑作为服务器让别人登陆的，而咱们现在要做的是自己的电脑作为客户端登陆邮箱服务器）\n\n![image](http://img.blog.csdn.net/20141020210951406)\n\n&nbsp;&nbsp;&nbsp;&nbsp;再在cmd中试一下，直接输入 `telnet smtp.163.com 25` ,第一行会显示邮件服务器返回的欢迎信息，我这里返回的就是 “220 163.com Anti-spam GT for Coremail System (163com[20121016])” 其中220说明邮件服务器跟我已经建立了连接，它已经开始想要帮帮我了，哈哈。友好一点，跟服务器大哥打个招呼吧，输入`HELO huan` ，（huan是随便输入的，输入什么都行，服务器是不会鸟你到底输入的是什么），这时服务器返回的是“250 OK”，说明现在服务器等着我继续发送命令了。输入 `MAIL FROM:<cnsmtp01@163.com>` 这时服务器居然给我返回了553，并告诉我需要认证。也是，既然登陆人家的服务器，总得有个人家的账号吧。所以接下来输入`AUTH LOGIN`，服务器返回了334和我看不懂的东西，这是要求咱们要输入用户名和密码信息了。但是都知道，像用户名密码这种信息是不能在互联网里进行明文传输的，而smtp服务器用户名和密码采用的是base64编码加密方式，所以在百度搜一个在线base64加密网站就好了，（比如http://base64.xpcha.com/），如图\n\n![image](http://img.blog.csdn.net/20141020211334751)\n\n&nbsp;&nbsp;&nbsp;&nbsp;把得到的密文往控制台中粘贴后回车，这时服务器会再要求我输入密码，跟刚才的方式一样即可，如果正确的话，会返回235，并告诉我认证成功了。Perfect！已经进展到一半了，继续！我下面就要告诉服务器从哪个邮箱发，发给谁，所以依次输入`MAIL FROM:<cnsmtp01@163.com>`  回车 `RCPT TO:<cnsmtp02@163.com>` 回车   发件人和收件人设置好后，自然该告诉服务器我要发的内容是什么了，所以输入`DATA`后回车，服务器返回给我354，并让我输入，以`<CR><LF>.<CR><LF>`结尾，好，那就直接输入正文： Can I date with you?   然后`“回车” “.” “回车”`来告诉服务器我的内容输入完毕了，它可以发送了。这个时候触目惊心的一幕出现了，服务器并没有给我返回2XX的正确码，而是给我返回了554，这是为什么，服务器大哥不肯帮我了？\n![image](http://img.blog.csdn.net/20141020211335234)\n\n&nbsp;&nbsp;&nbsp;&nbsp;看着它给我的链接，像是163自己的错误说明文档，我就复制下来了，打开浏览器查看了一下，原来是163服务器认为我发的是垃圾邮件，所以它拒绝给我发信。可是大哥，我这是真心的啊，哪是什么垃圾邮件啊，求求你就让我发送吧（想想也是，如果好多人都这样给女神发了一堆的垃圾邮件，我会不高兴的%>_<%）。分析一下为什么会被认为是垃圾邮件吧：邮件得有主题（subject），发件人（from），收件人（to），邮件正文等，可是我只写了个邮件正文，也许服务器就把这个当成是垃圾邮件了。嗯，越臆想就觉得越有道理，来试一下吧。这次我输入了`DATA`后，服务器让我输入内容，我先输入了`subject:Would you go on a date with me ?`  然后回车 `from:cnsmtp01@163.com`  回车  `to:cnsmtp02@163.com` 回车 `Can you eat a meal together?`    `回车 . 回车`    哈哈，这个时候服务器给我返回的是Mail OK，我发送成功了！接下来就是要等待女神的答复了。。。全部过程见下图：（留个问题，女神的邮箱里肯定会收到这封邮件，但是会收到我原本想发的正文“Can you eat a meal together?  ”吗？如果不知道，查一下报文格式，或见下面的java程序，对比一下正文部分后面的数据格式区别）\n![image](http://img.blog.csdn.net/20141020211335827)\n\n&nbsp;&nbsp;&nbsp;&nbsp;全部过程：\n\n\ttelnet smtp.163.com 25\n\tS: 220 163.com Anti-spam GT for Coremail System <163com[20121016]>\n\tC: HELO huan\n\tS: 250 OK\n\tC: AUTH LOGIN\n\tS: 334 dXNlcm5hbWU6\n\tC: Y25zbXRwMDE=\n\tS: 334 UGFzc3dvcmQ6\n\tC: Y29tcHV0ZXI=\n\tS: 235 Authentication successful\n\tC: MAIL FROM:<cnsmtp01@163.com>\n\tS: 250 Mail OK\n\tC: RCPT TO:<cnsmtp02@163.com>\n\tS: 250 Mail OK\n\tC: DATA\n\tS: 354 End data with <CR><LF>.<CR><LF>\n\tC: subject:Would you go on a date with me ?\n\tC: from:cnsmtp01@163.com\n\tC: to:cnsmtp02@163.com\n\tC: Can you eat a meal together?\n\tC: .\n\tS: 250 Mail OK queued as smtp7,C8CowEDpwFYP_ERUQxX8AA--.14S2 1413807190\n\tC: RSET\n\tS: 250 OK\n\tC: QUIT\n\tS: 221 Bye\n\n&nbsp;&nbsp;&nbsp;&nbsp;时候差不多了，我觉得女神应该会给我回复邮件了，怎么看，打开浏览器进入163邮箱吗？太out、太low了，直接命令行吧！ `telnet pop.163.com 110` ，刚才已经演示了全部的smtp命令，所以操作起来pop的应该很简单了，直接上图：\n![image](http://img.blog.csdn.net/20141020211336498)\n\n&nbsp;&nbsp;&nbsp;&nbsp;看到女神回复我什么了吗。。。简直狗血。。。\n\n&nbsp;&nbsp;&nbsp;&nbsp;好了，一次的收发邮件过程全都解决了，而且结果是，，，被拒了。其实呢，刚才没说，我的女神是编号的，从女神0号，女神1号…女神n号，难道刚刚第0个女神拒绝我后我就颓了吗？那怎么行，我得越挫越勇啊，继续给剩下的女神发邮件。可是，我这么多女神，我不能给每个女神发邮件都用这种命令行方式吧，那不虚死我，那么问题来了——发邮件技术哪家强？ 既然咱们是学计算机的，那就编软件呗，让软件替咱们批量发，简直Perfect！\n\n&nbsp;&nbsp;&nbsp;&nbsp;所以又回到这次的议题上来了，怎么用java实现smtp发送邮件？对，还是要请出大神`Socket`来帮忙。经历了上次Socket的折磨和刚才命令行的磨练，接下来就是把他们巧妙融合的时候了，所以，别走开。\n\n&nbsp;&nbsp;&nbsp;&nbsp;1、定义一些咱们一会会用到的邮箱名，用户名密码等信息（正常编程没人会把用户名和密码写的这么明白。。。）：\n\n\tString sender = \"cnsmtp01@163.com\"; \n\tString receiver = \"cnsmtp02@163.com\"; \n\tString password = \"computer\";\n\t//上文说过，这个用户名和密码是要使用base64进行加密的，加密方法见下文附录1详解 \n\tString user = new BASE64Encoder().encode(sender.substring(0, sender.indexOf(\"@\")).getBytes());  //截取出“cnsmtp01”并加密 \n\tString pass = new BASE64Encoder().encode(password.getBytes());   //加密 “computer”\n\n&nbsp;&nbsp;&nbsp;&nbsp;2、建立Socket连接:\n\n\tSocket socket = new Socket(\"smtp.163.com\", 25);  //smtp服务使用25号端口监听\n\n&nbsp;&nbsp;&nbsp;&nbsp;3、获取该socket的输入输出流\n\n\tInputStream inputStream = socket.getInputStream(); \n\tOutputStream outputStream = socket.getOutputStream(); \n\tBufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); \n\tPrintWriter writter = new PrintWriter(outputStream, true);  //我TM去 这个true太关键了，我刚才没写这个别坑了!你可以不加这个试下效果，下文附录2会写到为什么加true\n\n&nbsp;&nbsp;&nbsp;&nbsp;4、发送HELO信息\n\n\t//HELO \n\twritter.println(\"HELO huan\"); \n\tSystem.out.println(reader.readLine());\n\n&nbsp;&nbsp;&nbsp;&nbsp;5、发送AUTH LOGIN信息\n\n\t//AUTH LOGIN \n\twritter.println(\"auth login\"); \n\tSystem.out.println(reader.readLine()); \n\twritter.println(user); \n\tSystem.out.println(reader.readLine()); \n\twritter.println(pass); \n\tSystem.out.println(reader.readLine()); \n\t//Above   Authentication successful\n\n&nbsp;&nbsp;&nbsp;&nbsp;6、发送发件人和收件人信息\n\n\t//Set mail from   and   rcpt to \n\twritter.println(\"mail from:<\" + sender +\">\"); \n\tSystem.out.println(reader.readLine()); \n\twritter.println(\"rcpt to:<\" + receiver +\">\"); \n\tSystem.out.println(reader.readLine());\n\n&nbsp;&nbsp;&nbsp;&nbsp;7、告诉服务器我要传数据\n\n\t//Set data \n\twritter.println(\"data\"); \n\tSystem.out.println(reader.readLine());\n\n&nbsp;&nbsp;&nbsp;&nbsp;8、发邮件主题，收件人，发件人，正文\n\n\twritter.println(\"subject:女神，是我\");   \n\twritter.println(\"from:\" + sender);   \n\twritter.println(\"to:\" + receiver);   \n\twritter.println(\"Content-Type: text/plain;charset=\\\"gb2312\\\"\");//如果发送正文必须加这个，而且下面要有一个空行   \n\twritter.println();   \n\twritter.println(\"女神，晚上可以共进晚餐吗？\");   \n\twritter.println(\".\");//告诉服务器我发送的内容完毕了   \n\twritter.println(\"\");   \n\tSystem.out.println(reader.readLine());  \n\n&nbsp;&nbsp;&nbsp;&nbsp;9、帮你发了邮件，感谢服务器，和它Say Goodbye吧，都不用请它吃饭，多好\n\n\twritter.println(\"rset\"); \n\tSystem.out.println(reader.readLine()); \n\twritter.println(\"quit\"); \n\tSystem.out.println(reader.readLine());\n\n&nbsp;&nbsp;&nbsp;&nbsp;所以，加上异常等操作，所有的代码如下：\n\n\tpublic class SMTPMain {\n    public static void main(String[] args) { \n        String sender = \"cnsmtp01@163.com\"; \n        String receiver = \"cnsmtp02@163.com\"; \n        String password = \"computer\"; \n        String user = new BASE64Encoder().encode(sender.substring(0, sender.indexOf(\"@\")).getBytes()); \n        String pass = new BASE64Encoder().encode(password.getBytes());\n        try { \n            Socket socket = new Socket(\"smtp.163.com\", 25); \n            InputStream inputStream = socket.getInputStream(); \n            OutputStream outputStream = socket.getOutputStream(); \n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); \n            PrintWriter writter = new PrintWriter(outputStream, true);  //我TM去 这个true太关键了! \n            System.out.println(reader.readLine()); \n            //HELO \n            writter.println(\"HELO huan\"); \n            System.out.println(reader.readLine()); \n            //AUTH LOGIN \n            writter.println(\"auth login\"); \n            System.out.println(reader.readLine()); \n            writter.println(user); \n            System.out.println(reader.readLine()); \n            writter.println(pass); \n            System.out.println(reader.readLine()); \n            //Above   Authentication successful             \n\t\t\t\n\t\t\t//Set mail from   and   rcpt to \n            writter.println(\"mail from:<\" + sender +\">\"); \n            System.out.println(reader.readLine()); \n            writter.println(\"rcpt to:<\" + receiver +\">\"); \n            System.out.println(reader.readLine()); \n           \n            //Set data \n            writter.println(\"data\"); \n            System.out.println(reader.readLine()); \n            writter.println(\"subject:女神，是我\"); \n            writter.println(\"from:\" + sender); \n            writter.println(\"to:\" + receiver); \n            writter.println(\"Content-Type: text/plain;charset=\\\"gb2312\\\"\"); \n            writter.println(); \n            writter.println(\"女神，晚上可以共进晚餐吗？\"); \n            writter.println(\".\"); \n            writter.println(\"\"); \n            System.out.println(reader.readLine()); \n\n            //Say GoodBye\n            writter.println(\"rset\"); \n            System.out.println(reader.readLine()); \n            writter.println(\"quit\"); \n            System.out.println(reader.readLine()); \n            } catch (Exception e) {\n                 e.printStackTrace(); \n            } \n        } \n\t}\n\n&nbsp;&nbsp;&nbsp;&nbsp;这下，我完全不怵蓝翔的挖掘机了，这简直就是我的约会神器，只要把女神x号的邮箱一改，程序一运行，我这邮件就瞬间发出去了，哈哈，简直机智如狗。\n现在运行程序，看控制台输出\n![image](http://img.blog.csdn.net/20141020231432656)\n\n&nbsp;&nbsp;&nbsp;&nbsp;多次运行程序，女神1号，2号…的邮箱里都收到了如下图的邮件（可以把多个女神的邮箱加到集合[list map vector…]里，然后再一循环，分分钟搞定）\n![image](http://img.blog.csdn.net/20141020231433437)\n\n&nbsp;&nbsp;&nbsp;&nbsp;至于什么界面什么的，就仁者见仁智者见智吧，习惯java的就swing，习惯android也可以xml，其实我是觉得android更方便一些，控件更容易用一些。若是用java写界面忘了的话，推荐使用 `windows builder` ， 可以帮你很快绘制出界面来，然后你要做的就是获取控件，写监听器等等。\n \n* 附录1：\n关于base64加密：\n具体什么是base64加密，这种概念性的东西能在百度百科找到的我就不说了，说一下在java里怎么去用它。\n1、首先下载一个工具jar文件，叫做“sun.misc.BASE64Decoder.jar” （百度搜就能找到，如果找不到可以到我最后提供的本人github上去下载下来使用）\n2、有了jar文件后，需要把jar包导入工程，方法为：右键工程名—Build Path—Configure Build Path—Add External JARS，选择你刚下载的jar包后确定就可以了\n3、之后在java文件里写到 new BASE64Encoder().encode(password.getBytes());  时，会提示没有导入对应的包，可以按Ctrl + Shift + O(欧)来让IDE自动为我们导入（前提是你的jar包导入没问题）\n \n* 附录2：\n说说PrintWriter.println()方法(或write()方法，其实就差了一个换行，剩下参数什么的都一样)。PrintWriter writter = new PrintWriter(outputStream, true);  在PrintWritter的构造函数中，可以不加true，也可以加true，区别在于：加了true的话，在下面进行writter.println(“helloworld”);后，“helloworld”就会立即发送出去；相反，不加true的话，必须在writter.println(“helloworld”);后 再调用writter.flush();来清空缓冲区，强制发送出去。我开始就没有加true，而且没调用flush()方法，我以为是服务器SB了，结果。。。。\n \n>* 附录3：\n为什么telnet pop协议时登录服务器输入用户名和密码时会明文，这让我很奇怪，希望有人帮我解答。\n \n* 附录4：\n有没有注意到在使用smtp协议时，认证的时候需要你输入发送人信息，输入data后又要写一遍发件人的信息？难道服务器傻吗，非要让你输入两遍？可以想一想为什么，然后自己亲自尝试一下，由于咱们平时用的邮件代理都把这两个认为是同一个了，所以掩盖了一个发送邮件时候的小技巧，即可以伪装欺骗，具体的自己试一下，印象才会更深刻。\n \n* 附录5：\n大小写问题。有没有注意到我在cmd里输入的命令部分都是大写，而在java程序里输出的命令部分都是小写？我是想说，命令部分是不区分大小写的，但是命令后面的参数是严格区分大小写的，自己可以试一下。（例如邮箱用户名和密码本来就是区分大小写的吧）\n \n* 附录6：\n关于telnet本身的问题。在telnet里的一行输入了错误的数据，我想删除，然后再继续输入正确的，回车。这个时候你会发现明明输入的没有问题，可是服务器返回的却是错误代码，比如 500 Error：bad syntax    原因就在于命令你要一次性输入正确，如果中途输错了，不用退格，已经晚了，直接打个回车，肯定会报错，再出入正确的就好了。如果总是打错，像163服务器就直接给你断开连接，它以为你恶意要攻击它呢。像新浪的邮箱服务器，就很忠诚，在有效连接时间内一直等着你输入正确的命令，这点可以自己试一下。\n\n* 附录7：\n记得之前在linux中用shell发送邮件时，并没有强制要求我必须用合法的身份登录邮箱服务器才能进行发邮件操作，为什么？因为那个时候我自己的本机相当于是SMTP服务器，我自己当然就不用验证身份了。而现在是想用SMTP协议登录别人的服务器（如163），此时163就必须要合法的用户身份才能使其登录并发邮件了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;针对此篇文章还要说明的：这只是为了理解SMTP的一篇很基础性的讲解，对于代码部分，为了体现主体，明显缺少通过服务器返回代码判断语句，因而以上程序缺少健壮性，自己在理解好实际编程时应该考虑到真正的网络请求情况，考虑丢包情况，根据服务器返回代码进行相应判断。\n \n&nbsp;&nbsp;&nbsp;&nbsp;好了，就写到这了，我要去和女神吃饭饭了~哪里有问题可以在下面留言~\n \n###个人github: [http://github.com/icodeu](http://github.com/icodeu)\n\n###代码托管地址:[http://github.com/icodeu/JavaForSMTP](http://github.com/icodeu/JavaForSMTP)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n\n","slug":"2014-10-20-再谈用 Java 实现 SMTP 发送邮件之 Socket 编程","published":1,"updated":"2015-08-24T10:21:44.000Z","photos":[],"link":"","_id":"ciw22yo0z005cek5xrljwat2u"},{"layout":"post","title":"浅谈用 Java 搭建 web 服务器之 Socket 编程——更好的理解 Apache、Tomcat 等软件的工作模式","date":"2014-10-18T07:20:33.000Z","comments":1,"_content":"\n之前做web应用一直是在本地装个Apache、Tomcat之类的软件，然后把做好的网页文件放在他们的工作目录下（如Apache的htdocs），然后打开浏览器输入127.0.0.1或localhost就可以直接访问了，好神奇，可是为什么，怎么实现的呢，早就知道有Socket（套接字）这个东西，可之前就是没有把这两方面结合起来，今天我们就一起来看一看这究竟是为什么。\n\n<!--more-->\n\n有同学说还不懂Socket是什么，这东西很抽象，在计算机网络原理里讲协议时才会看到，今天咱们完全忽略太严谨、学术的定义，就来看看Socket到底是什么。想象一下，你把电脑的电源插在插座上，你的电脑就可以使用了，为什么？“这不是废话吗！”确实，咱们来想一下这个过程，你拿着插头插在了插座上，然后你的电脑和千里之外的供电厂就能“通信”了，把你的电脑想成是客户端，把千里之外的供电厂想成是服务器，通过插座和很长很长的线缆你们就可以勾搭上了，那么Socket在这其中相当于什么呢？“插座！”没错，就是插座！对于我的电脑来说，我想让它通电工作，我只需要个插座就行了啊，什么插座是什么材质的，线缆是什么型号的，供电厂到底在什么经纬度，电力到底怎么传输，我管它干嘛呢，都跟我没关系！我只要知道我需要的不是整个世界，而是。。。一个插座！读到这里，想必同学已经对“插座”有了很森的理解了；再举一个例子，你和基友的电脑通过有线的方式连上了同一个路由器，这个时候你们就可以直接通过内网IP地址进行访问了，在这个过程中，那个方方的接口（RJ45接口）就是“Socket”，反正插上“Socket”就能用，我不用管到底通过Socket怎么能够实现通信。在计算机编程的网络世界里，作为应用程序，我只需要一个“插座”就可以和任何服务器通信了，想想都有点小激动呢~~~\n\n接下来要讲的就是，电脑电源需要一个socket去插上，那么发电厂呢，也同样需要一个插座插上去来给你供电——也就是说，发电厂需要一个“插座”！。。。废话，，，，没错，确实是这样，服务器端也需要一个“插座”，只不过它叫做ServerSocket（这看起来像是继承自Socket，我也不知道，待查）。\n\n有了“插座”（Socket）的概念之后，我们就可以愉快地让电脑（客户端）与发电厂（服务器）通信了。无论是客户端还是服务器，都需要Socket，鉴于咱们今天的题目是“搭建web服务器”，所以咱们接下来就来看一下怎么创建服务器的ServerSocket。说道这里，有同学就会问到了，“难道客户端不需要Socket吗？”，确实需要，因为我们是用浏览器访问本机IP“127.0.0.1”，所以客户端的Socket就由浏览器自己维护了，不需要咱们动手写的。“可是我还是不明白为什么在浏览器里输入127.0.0.1之后就可以看到我的网页了？求解释” 好，那咱们慢慢来，先动手编写一个服务器端的ServerSocket吧啦啦啦~\n\n创建服务器端Socket的步骤如下：\n\n1、创建ServerSocket对象\n\n\tServerSocket serverSocket = new ServerSocket(“80”);  \n\t//这里只需要指明当前程序监听80号端口就可以了，至于为什么是80，因为我喜欢！“好霸道。。。”因为我们要监听web请求，默认就是80号端口。其实，1-1024端口被操作系统占用了，1025-65535的端口你随便用，只要不会和其他应用程序冲突就可以（别用什么类似3389这么常用的端口就好了。。。）  \n\n2、作为服务器，我要知道，我的使命就是要等待客户端发来请求，也就是客户端发来Socket，我首先要把它Hold住！\n\n\tSocket socket = serverSocket.accept(); \n\t//这里需要特别说明一下，accept方法比较特殊，它是一个阻塞方法(block method)，因为只要它等不来客户端发来的请求（Socket），它就一直等下去而不会继续执行它下面的代码。唉，此等痴情人怎么跟我一样O(∩_∩)O  \n\n3、客户端要向我表白，给我发来情书，那我作为服务器只要得到它的输入就好了\n            \n\tInputStream inputStream = socket.getInputStream(); \n\t//注意，客户端发来的表白信息都在socket里面，而不是serverSocket里面，这点要是弄错了，读不到情书内容，活该你单身。（我只有冷笑。。。）  \n\n4、收到了情书，我好想知道里面究竟写了什么啊！迫！不！及！待！ 好，开始解析情书内容\n       \n\tBufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));  \n\t//java包装类，只为读到写给我的情书，耶~  \n\tString line = “”;  \n\twhile ( (line = reader.readLine()) != null ){   \n       System.out.println(line);   \n\t}  \n\n5、组装前4步的代码，会要求try catch一下异常，正常捕获就好 下面贴代码\n\n\tpublic class MultiWebServer {   \n    public static void main(String[] args) {   \n        try {   \n            ServerSocket serverSocket = new ServerSocket(80);  \n            System.out.println(\"正在等待情书中...\");   \n            Socket socket = serverSocket.accept();  \n            System.out.println(\"收到情书，我要开始解析！\");   \n            InputStream inputStream = socket.getInputStream();   \n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));  \n            String line = \"\";   \n            while ( (line = reader.readLine()) != null ){   \n                System.out.println(line);   \n            }   \n        } catch (Exception e) {   \n            e.printStackTrace();   \n          }   \n    \t}   \n\t}  \n\n好了，服务器端的代码咱们写完了，那接下来干啥？不知道。。。不过还记得刚才提出的问题吗——“可是我还是不明白为什么在浏览器里输入127.0.0.1之后就可以看到我的网页了？”那就试试呗，看看咱们如果在浏览器里输入127.0.0.1或者localhost会怎么样\n\n首先必须把刚才咱们编写的服务器端程序运行起来，然后再打开浏览器，记住，必须先运行服务器端程序，不然情书就发丢了。。。运行服务器端程序，如图：\n\n![](http://img.blog.csdn.net/20141018222024890)\n\n注意红圈中的两点：由于此时没有客户端发来情书，还记得刚才的accept()阻塞方法吗，它就一直等啊等，等不来我还等，所以红圈中会显示“正在等待情书中…”；那么右面那个箭头指向的是什么意思呢，一个红色停止的图标，也就是说，这个程序现在一直在执行着，没有结束，就好像死循环一样（当然这里绝对不是死循环，其实是阻塞，只是死的样子好像死循环，一会咱们会谈到死循环的，别着急，迟早会死的）\n\n接下来打开浏览器，在地址栏输入127.0.0.1/index.html后回车，看看浏览器什么反应。。。。。一段时间过去了，浏览器居然一点反应都没有，然后告诉我该页无法显示。我去。。。难道讲了这么多咱们就这么失败了吗，我哭。那就打开eclipse看一眼吧，看看服务器端有没有什么动静啊。打开服务器端一看，卧槽，瞬间世界向我问好了！\n\n![](http://img.blog.csdn.net/20141018222026250)\n\n注意看红笔标注，我收到了情书！我要开始解析了！那到底情书里是什么内容，别问我，继续向下看。“好熟悉的一段报文，我们好像在哪见过，还记得吗，那是一个春天，你刚发芽儿。。。”没错，这就是计算机网络原理讲的http请求报文。没有学过计网怎么办，没关系，看前两行（其实我们一会用到的也只有第一行而已），“我看到了index.html” 是的，这是刚才我们在浏览器里面输入的地址；第二行，“我也看到了127.0.0.1”，是的，也是我们刚刚在浏览器里面输入的。这说明了什么？激动的我无法说出这到底说明了什么，但想必读者你已经揣测出了什么。\n \n写到这里，作为服务器的我已经收到了从客户端发来的情书，那客户端（浏览器）为什么一点反应都没有呢，甚至过了一会就“该页无法显示”了。因为啊，人家给你写了情书，你没回复人家，人家等了一会觉得没戏了就伤心欲绝了！是啊，喜不喜欢人家都要和他说一声的，给他个答复，哪怕只说：“对不起，你是个好人。。。”\n走神了吧？好像说到自己了吧？回来吧，咱们现在的任务呢，就是怎么给人家个答复。\n\n怎么给，怎么给，怎么给。。。快想快想，既然人家都指明了想和127.0.0.1里的“index.html”表白，那当然就得由index.html来给他答复喽。怎么答，怎么答，怎么答。。。快想快想，既然index.html是个文件，那我读出文件内容后直接发给客户端不就行了吗？可是用什么发？没错，是socket！我们用socket把文件的内容返回给客户端就好了。\n\n那么问题来了。。。“说的非常好，关键是怎么做！”——首先怎么读出文件来？\n\n假定咱们的index.html在我电脑的E://课件/计算机网络原理/实验/实验1/ 文件夹下，并且假定不会跨域访问，则：\n\n1、定义一个字符串，用来存咱们的工作目录\n            \n\tString base_url = \"E://课件/计算机网络原理/实验/实验1/\";   \n\t//这只是我本机的目录，至于到了你的电脑上，你可以自己更改</span>  \n\n2、我怎么通过报文知道客户端要和index.html表白？看情书第一行  GET /index.html HTTP/1.1，所以只需要获取情书的第一行字符串并解析出index.html就好办啦，easy，开始吧\n\n    //由于目前只需要第一行，所以咱们就不像上面那样循环读取了，读一行就够了         \n\tString line = reader.readLine();  \n\t//用字符串截取函数，把“index.html”这个字符串给揪出来\n\tString url = line.substring(5, line.indexOf(\"HTTP\") - 1);    \n\n3、所以咱们index.html的绝对路径就是 base_url + url 了，终于把我爱的人从人山人海中找到了，看看她怎么答复我吧——获取文件内容\n\n\tinputStream = new FileInputStream(base_url + url);   \n\tOutputStream outputStream = socket.getOutputStream();   //我要从服务器给客户端答复了，对于服务器来说，这是发出去的内容，所以是Out！  \n\tbyte[] buffer = new byte[4 * 1024];  //定义字节缓冲区   \n\tint len = 0;   \n\twhile ((len = inputStream.read(buffer)) != -1) {   \n        outputStream.write(buffer, 0, len);  //很重要！通过socket的outputStream把咱们解析出来的文件内容一字不落的发出去 如果没写这个，导致你爱的跟你表白的抑郁而死，活该你单身  \n\t}   \n\toutputStream.flush(); //如果最后一次write时没有把buffer写满，是不会自动发出去的，需要调用flush方法强制把内容从缓冲区发出去  \n\n \n好了，文件读取出来了，也返回给客户端了，亲爱哒他能收到吗？还是一样，务必先运行服务器端程序，然后打开浏览器输入127.0.0.1/index.html 后回车。我紧张，我激动，能不能收到回复，会给我什么样的回复？如图。。。\n\n![](http://img.blog.csdn.net/20141018222413101)\n\n为什么会这样？？？！！！ 好吧，看看女神的index.html文件里都写了些什么。。。\n\t\n\t<html>   \n\t    <head>   \n\t        <meta charset=\"utf-8\" />   \n\t        <title>Welcome</title>   \n\t    </head>   \n\t    <body>      \n\t        <h1>王欢，你是个好人... </h1>   \n\t    </body>  \n\t</html>  \n\n \n看到这里，我到底应该高兴还是欲绝。。。高兴的是，我女神给我答复了；欲绝的是。。。那么问题来了，，，学表白技术哪家强？\n \n玩笑归玩笑，那我们的针对这次的浅谈题目是不是就完成了？可以说是的，但是我表白一次失败就算了？我还要表白第二次！（其实我倒不是这样的，这里只能牺牲我的人品来为了大家更好的理解了，呵呵）。好吧，我刚才的工作目录下还有个another.html，这次我来跟她表白吧！好！继续在浏览器中输入127.0.0.1/another.html后回车，期待这次会表白成功。可是我等啊等，浏览器在那里打圈圈，难道浏览器都知道我太花心了，拒绝帮我传递情书？好吧，我再打开浏览器试一下，输入127.0.0.1/index.html ，嗯？连第一个女神都不理我了？！我靠！为毛！\n\n冲动是魔鬼！冷静！我打开eclipse控制台，发现服务器根本就没有“正在等待情书中…”，所以我拜托浏览器发过去的情书当然就发丢了，因为根本没人在接收啊。（窃喜，还好不是因为我太花心了所以浏览器没有帮我投递情书）可是为什么呢？\n\n冷静吧，分析代码。其实我们可以想到，这段代码执行完一次后不就结束了吗，那我第二次给她发请求她当然会收不到了。对啊，那为了解决这个问题，怎么办呢？跪求红娘支招！\n\n红娘说：“给服务器程序个死循环吧，让她反复在等客户端的请求就好了。”（其实红娘就一直在死循环中）\n\n红娘果然是红娘（不然是谁。。。），那就按照她的说法试一试呗！改代码，加入 while (true) 死循环：\n\n\tpublic class MultiWebServer {   \n\t  \n\t    public static void main(String[] args) {   \n\t  \n\t        String base_url = \"E://课件/计算机网络原理/实验/实验1/\";   \n\t  \n\t        while (true) {   \n\t            try {   \n\t                ServerSocket serverSocket = new ServerSocket(80);   \n\t                System.out.println(\"正在等待情书中...\");   \n\t                Socket socket = serverSocket.accept();   \n\t                System.out.println(\"收到情书，我要开始解析！\");   \n\t                InputStream inputStream = socket.getInputStream();   \n\t                BufferedReader reader = new BufferedReader(   \n\t                        new InputStreamReader(inputStream));   \n\t                String line = reader.readLine();   \n\t                System.out.println(line);   \n\t                String url = line.substring(5, line.indexOf(\"HTTP\") - 1);  \n\t  \n\t                System.out.println(\"情书解析完毕，我要想想怎么回复了...\");   \n\t     \n\t  \n\t                // 获取文件内容   \n\t                inputStream = new FileInputStream(base_url + url);   \n\t                OutputStream outputStream = socket.getOutputStream();   \n\t                byte[] buffer = new byte[4 * 1024];   \n\t                int len = 0;   \n\t                while ((len = inputStream.read(buffer)) != -1) {   \n\t                    outputStream.write(buffer, 0, len);   \n\t                }   \n\t                outputStream.flush();   \n\t  \n\t                System.out.println(\"情书请求已发送给客户端\");  \n\t   \n\t                //关闭对应的资源   \n\t                serverSocket.close();   \n\t                socket.shutdownInput();   \n\t                socket.close();   \n\t                inputStream.close();   \n\t                reader.close();   \n\t                outputStream.close();   \n\t            } catch (Exception e) {   \n\t            }   \n\t        }   \n\t    }   \n\t}\n  \n这样，这位红娘就在这里一直等啊等，来了一个客户端我就处理他的情书请求，处理完这个继续循环以相同的方式等，处理，等，处理。。。。\n\n好吧，咱们接下来试一下，还是务必先运行服务器端程序，然后先和第一个女神表白，即 127.0.0.1/index.html 还是好朋友的话，就别问我返回结果。。。这个时候打开eclipse的控制台，有没有发现右上角的红色暂停标志可以点击，那就说明咱们的红娘还在兢兢业业的工作着！好了，抓紧时间赶紧向第二个女神表白，看她怎么说， 浏览器输入 127.0.0.1/another.html ，回车！好快啊，女神给我答复了。。。\n\n![](http://img.blog.csdn.net/20141018222413725)\n\n这。。。（她怎么知道不到十分钟？你是不是突然想到了cookie可以记录客户端的信息，不过咱们这里没用到cookie）还是看看another.html文件里写了什么吧\n\n\t<html>   \n\t    <head>   \n\t        <meta charset=\"utf-8\" />   \n\t        <title>Welcome</title>   \n\t    </head>   \n\t    <body>      \n\t        <h1>我记得你刚和别人表白吧，还不过十分钟，你怎么会是个好人！</h1>   \n\t    </body>  \n\t</html>  \n\n \n好吧，我啥也不说了，亲们，我还要向第三个女神表白吗。。。？浏览器主动跟我说：“你表白吧，这次你发多少封表白信我都能给你送到服务器那里，因为她一直在等待着我给她发送呢！”想想，还是算了，人生如此，何须多言。。。\n \n代码都贴出来了，其实看起来挺简单的，但是实际操作中会碰到各种各样的问题。\n \n还有一些要再继续唠叨的边角料：\n\n* 1、Q：什么是端口？\n* \nA：这是一个比较抽象的概念，是为了进程间通信，每一个进程只能占用一个端口，也就是说多个进程绝不能同时占用一个端口\n\n* 2、Q：既然多个进程不能同时占用一个端口，那么咱们常说的web服务默认使用的是80端口，我电脑有三个浏览器，谷歌，360，IE他们却可以同时上网，这不是端口冲突了吗？\n* \nA：常说的web服务使用80端口指的是服务器监听web请求的端口，是服务器，不是你自己的客户机。一般来说，一个应用程序打开后访问网络本地操作系统为其分配的端口号是随机的，所以三个浏览器虽然同时接收web服务器的回复报文，由于他们三个各自占用的端口不一样，所以不会产生冲突。\n\n* 3、Q：既然我的应用程序使用的端口都是随机的，服务器接收到请求后怎么知道它要把应答报文发给谁？\n* \nA：靠Socket！通过刚才的编程实战，在我理解，Socket肯定会至少包括四部分内容：IP地址，端口号，输入流和输出流。也就是说，从客户机发给服务器的Socket里一定会有客户机的IP地址和相应应用程序的端口号，这样服务器自然就知道应该把应答报文发给谁了。\n\n* 4、Q：非要使用80端口吗？\n* \nA：不一定。我们刚才在编程的时候确实使用的是80端口，所以我们在浏览器中输入127.0.0.1/index.html，浏览器会默认认为我们会向127.0.0.1主机的80号端口发送请求。但是，这个80端口号只是默认的而已，我们完全可以自己改掉，比如在java代码里把服务器端的ServerSocket改成   ServerSocket serverSocket = new ServerSocket(3456);  这时候我们在浏览器中就要输入 127.0.0.1:3456/index.html  了，效果是一样的，可以浅尝辄止一下。\n\n* 5、Q：谁是客户端，谁是服务器？\n* \nA：咱们只有一台电脑，这台电脑既充当着客户端的角色，又充当着服务器的角色。当浏览器请求网页时，它是客户端；当80端口收到请求报文并应答时，它就是服务器。实在不理解，就想想什么是自恋吧，或者，自交也勉强可以。。\n\n* 6、Q：还有什么问题，欢迎留言~\n \n对于此用java编写的web服务器的一点简单说明：此段代码非常简单，所以肯定不会是真正web服务器所用到的代码，咱们这个只是能够应答最最基本的web请求，不能检测是否跨域访问等等。不过最基本的，用的socket编程是肯定的。另外，对于此段程序，只给出了处理输入输出流的一种方式。对于输入流，除了咱们刚才用到的BufferedReader包装类，还可以直接用InputStream的read()方法等；对于输出流，除了咱们刚才用的OutputStream的write()方法，还可用BufferedWritter，PrintWritter等，这些都是java IO的基本用法，根据网络环境，根据所要读取的文件大小来时时变通，这就是仁者见仁智者见智了。\n \n文章写到了最后，不知道该怎么收尾了，安安静静做个程序员吧，挺好。\n\n \n###个人github: [http://github.com/icodeu](http://github.com/icodeu)\n\n###代码托管地址:[https://github.com/icodeu/JavaForWebServer](https://github.com/icodeu/JavaForWebServer)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n\n\n","source":"_posts/2014-10-18-浅谈用 Java 搭建 web 服务器之 Socket 编程——更好的理解 Apache、Tomcat 等软件的工作模式.markdown","raw":"---\nlayout: post\ntitle: \"浅谈用 Java 搭建 web 服务器之 Socket 编程——更好的理解 Apache、Tomcat 等软件的工作模式\"\ndate: 2014-10-18 15:20:33 +0800\ncomments: true\ntags: [Java, Socket]\n---\n\n之前做web应用一直是在本地装个Apache、Tomcat之类的软件，然后把做好的网页文件放在他们的工作目录下（如Apache的htdocs），然后打开浏览器输入127.0.0.1或localhost就可以直接访问了，好神奇，可是为什么，怎么实现的呢，早就知道有Socket（套接字）这个东西，可之前就是没有把这两方面结合起来，今天我们就一起来看一看这究竟是为什么。\n\n<!--more-->\n\n有同学说还不懂Socket是什么，这东西很抽象，在计算机网络原理里讲协议时才会看到，今天咱们完全忽略太严谨、学术的定义，就来看看Socket到底是什么。想象一下，你把电脑的电源插在插座上，你的电脑就可以使用了，为什么？“这不是废话吗！”确实，咱们来想一下这个过程，你拿着插头插在了插座上，然后你的电脑和千里之外的供电厂就能“通信”了，把你的电脑想成是客户端，把千里之外的供电厂想成是服务器，通过插座和很长很长的线缆你们就可以勾搭上了，那么Socket在这其中相当于什么呢？“插座！”没错，就是插座！对于我的电脑来说，我想让它通电工作，我只需要个插座就行了啊，什么插座是什么材质的，线缆是什么型号的，供电厂到底在什么经纬度，电力到底怎么传输，我管它干嘛呢，都跟我没关系！我只要知道我需要的不是整个世界，而是。。。一个插座！读到这里，想必同学已经对“插座”有了很森的理解了；再举一个例子，你和基友的电脑通过有线的方式连上了同一个路由器，这个时候你们就可以直接通过内网IP地址进行访问了，在这个过程中，那个方方的接口（RJ45接口）就是“Socket”，反正插上“Socket”就能用，我不用管到底通过Socket怎么能够实现通信。在计算机编程的网络世界里，作为应用程序，我只需要一个“插座”就可以和任何服务器通信了，想想都有点小激动呢~~~\n\n接下来要讲的就是，电脑电源需要一个socket去插上，那么发电厂呢，也同样需要一个插座插上去来给你供电——也就是说，发电厂需要一个“插座”！。。。废话，，，，没错，确实是这样，服务器端也需要一个“插座”，只不过它叫做ServerSocket（这看起来像是继承自Socket，我也不知道，待查）。\n\n有了“插座”（Socket）的概念之后，我们就可以愉快地让电脑（客户端）与发电厂（服务器）通信了。无论是客户端还是服务器，都需要Socket，鉴于咱们今天的题目是“搭建web服务器”，所以咱们接下来就来看一下怎么创建服务器的ServerSocket。说道这里，有同学就会问到了，“难道客户端不需要Socket吗？”，确实需要，因为我们是用浏览器访问本机IP“127.0.0.1”，所以客户端的Socket就由浏览器自己维护了，不需要咱们动手写的。“可是我还是不明白为什么在浏览器里输入127.0.0.1之后就可以看到我的网页了？求解释” 好，那咱们慢慢来，先动手编写一个服务器端的ServerSocket吧啦啦啦~\n\n创建服务器端Socket的步骤如下：\n\n1、创建ServerSocket对象\n\n\tServerSocket serverSocket = new ServerSocket(“80”);  \n\t//这里只需要指明当前程序监听80号端口就可以了，至于为什么是80，因为我喜欢！“好霸道。。。”因为我们要监听web请求，默认就是80号端口。其实，1-1024端口被操作系统占用了，1025-65535的端口你随便用，只要不会和其他应用程序冲突就可以（别用什么类似3389这么常用的端口就好了。。。）  \n\n2、作为服务器，我要知道，我的使命就是要等待客户端发来请求，也就是客户端发来Socket，我首先要把它Hold住！\n\n\tSocket socket = serverSocket.accept(); \n\t//这里需要特别说明一下，accept方法比较特殊，它是一个阻塞方法(block method)，因为只要它等不来客户端发来的请求（Socket），它就一直等下去而不会继续执行它下面的代码。唉，此等痴情人怎么跟我一样O(∩_∩)O  \n\n3、客户端要向我表白，给我发来情书，那我作为服务器只要得到它的输入就好了\n            \n\tInputStream inputStream = socket.getInputStream(); \n\t//注意，客户端发来的表白信息都在socket里面，而不是serverSocket里面，这点要是弄错了，读不到情书内容，活该你单身。（我只有冷笑。。。）  \n\n4、收到了情书，我好想知道里面究竟写了什么啊！迫！不！及！待！ 好，开始解析情书内容\n       \n\tBufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));  \n\t//java包装类，只为读到写给我的情书，耶~  \n\tString line = “”;  \n\twhile ( (line = reader.readLine()) != null ){   \n       System.out.println(line);   \n\t}  \n\n5、组装前4步的代码，会要求try catch一下异常，正常捕获就好 下面贴代码\n\n\tpublic class MultiWebServer {   \n    public static void main(String[] args) {   \n        try {   \n            ServerSocket serverSocket = new ServerSocket(80);  \n            System.out.println(\"正在等待情书中...\");   \n            Socket socket = serverSocket.accept();  \n            System.out.println(\"收到情书，我要开始解析！\");   \n            InputStream inputStream = socket.getInputStream();   \n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));  \n            String line = \"\";   \n            while ( (line = reader.readLine()) != null ){   \n                System.out.println(line);   \n            }   \n        } catch (Exception e) {   \n            e.printStackTrace();   \n          }   \n    \t}   \n\t}  \n\n好了，服务器端的代码咱们写完了，那接下来干啥？不知道。。。不过还记得刚才提出的问题吗——“可是我还是不明白为什么在浏览器里输入127.0.0.1之后就可以看到我的网页了？”那就试试呗，看看咱们如果在浏览器里输入127.0.0.1或者localhost会怎么样\n\n首先必须把刚才咱们编写的服务器端程序运行起来，然后再打开浏览器，记住，必须先运行服务器端程序，不然情书就发丢了。。。运行服务器端程序，如图：\n\n![](http://img.blog.csdn.net/20141018222024890)\n\n注意红圈中的两点：由于此时没有客户端发来情书，还记得刚才的accept()阻塞方法吗，它就一直等啊等，等不来我还等，所以红圈中会显示“正在等待情书中…”；那么右面那个箭头指向的是什么意思呢，一个红色停止的图标，也就是说，这个程序现在一直在执行着，没有结束，就好像死循环一样（当然这里绝对不是死循环，其实是阻塞，只是死的样子好像死循环，一会咱们会谈到死循环的，别着急，迟早会死的）\n\n接下来打开浏览器，在地址栏输入127.0.0.1/index.html后回车，看看浏览器什么反应。。。。。一段时间过去了，浏览器居然一点反应都没有，然后告诉我该页无法显示。我去。。。难道讲了这么多咱们就这么失败了吗，我哭。那就打开eclipse看一眼吧，看看服务器端有没有什么动静啊。打开服务器端一看，卧槽，瞬间世界向我问好了！\n\n![](http://img.blog.csdn.net/20141018222026250)\n\n注意看红笔标注，我收到了情书！我要开始解析了！那到底情书里是什么内容，别问我，继续向下看。“好熟悉的一段报文，我们好像在哪见过，还记得吗，那是一个春天，你刚发芽儿。。。”没错，这就是计算机网络原理讲的http请求报文。没有学过计网怎么办，没关系，看前两行（其实我们一会用到的也只有第一行而已），“我看到了index.html” 是的，这是刚才我们在浏览器里面输入的地址；第二行，“我也看到了127.0.0.1”，是的，也是我们刚刚在浏览器里面输入的。这说明了什么？激动的我无法说出这到底说明了什么，但想必读者你已经揣测出了什么。\n \n写到这里，作为服务器的我已经收到了从客户端发来的情书，那客户端（浏览器）为什么一点反应都没有呢，甚至过了一会就“该页无法显示”了。因为啊，人家给你写了情书，你没回复人家，人家等了一会觉得没戏了就伤心欲绝了！是啊，喜不喜欢人家都要和他说一声的，给他个答复，哪怕只说：“对不起，你是个好人。。。”\n走神了吧？好像说到自己了吧？回来吧，咱们现在的任务呢，就是怎么给人家个答复。\n\n怎么给，怎么给，怎么给。。。快想快想，既然人家都指明了想和127.0.0.1里的“index.html”表白，那当然就得由index.html来给他答复喽。怎么答，怎么答，怎么答。。。快想快想，既然index.html是个文件，那我读出文件内容后直接发给客户端不就行了吗？可是用什么发？没错，是socket！我们用socket把文件的内容返回给客户端就好了。\n\n那么问题来了。。。“说的非常好，关键是怎么做！”——首先怎么读出文件来？\n\n假定咱们的index.html在我电脑的E://课件/计算机网络原理/实验/实验1/ 文件夹下，并且假定不会跨域访问，则：\n\n1、定义一个字符串，用来存咱们的工作目录\n            \n\tString base_url = \"E://课件/计算机网络原理/实验/实验1/\";   \n\t//这只是我本机的目录，至于到了你的电脑上，你可以自己更改</span>  \n\n2、我怎么通过报文知道客户端要和index.html表白？看情书第一行  GET /index.html HTTP/1.1，所以只需要获取情书的第一行字符串并解析出index.html就好办啦，easy，开始吧\n\n    //由于目前只需要第一行，所以咱们就不像上面那样循环读取了，读一行就够了         \n\tString line = reader.readLine();  \n\t//用字符串截取函数，把“index.html”这个字符串给揪出来\n\tString url = line.substring(5, line.indexOf(\"HTTP\") - 1);    \n\n3、所以咱们index.html的绝对路径就是 base_url + url 了，终于把我爱的人从人山人海中找到了，看看她怎么答复我吧——获取文件内容\n\n\tinputStream = new FileInputStream(base_url + url);   \n\tOutputStream outputStream = socket.getOutputStream();   //我要从服务器给客户端答复了，对于服务器来说，这是发出去的内容，所以是Out！  \n\tbyte[] buffer = new byte[4 * 1024];  //定义字节缓冲区   \n\tint len = 0;   \n\twhile ((len = inputStream.read(buffer)) != -1) {   \n        outputStream.write(buffer, 0, len);  //很重要！通过socket的outputStream把咱们解析出来的文件内容一字不落的发出去 如果没写这个，导致你爱的跟你表白的抑郁而死，活该你单身  \n\t}   \n\toutputStream.flush(); //如果最后一次write时没有把buffer写满，是不会自动发出去的，需要调用flush方法强制把内容从缓冲区发出去  \n\n \n好了，文件读取出来了，也返回给客户端了，亲爱哒他能收到吗？还是一样，务必先运行服务器端程序，然后打开浏览器输入127.0.0.1/index.html 后回车。我紧张，我激动，能不能收到回复，会给我什么样的回复？如图。。。\n\n![](http://img.blog.csdn.net/20141018222413101)\n\n为什么会这样？？？！！！ 好吧，看看女神的index.html文件里都写了些什么。。。\n\t\n\t<html>   \n\t    <head>   \n\t        <meta charset=\"utf-8\" />   \n\t        <title>Welcome</title>   \n\t    </head>   \n\t    <body>      \n\t        <h1>王欢，你是个好人... </h1>   \n\t    </body>  \n\t</html>  \n\n \n看到这里，我到底应该高兴还是欲绝。。。高兴的是，我女神给我答复了；欲绝的是。。。那么问题来了，，，学表白技术哪家强？\n \n玩笑归玩笑，那我们的针对这次的浅谈题目是不是就完成了？可以说是的，但是我表白一次失败就算了？我还要表白第二次！（其实我倒不是这样的，这里只能牺牲我的人品来为了大家更好的理解了，呵呵）。好吧，我刚才的工作目录下还有个another.html，这次我来跟她表白吧！好！继续在浏览器中输入127.0.0.1/another.html后回车，期待这次会表白成功。可是我等啊等，浏览器在那里打圈圈，难道浏览器都知道我太花心了，拒绝帮我传递情书？好吧，我再打开浏览器试一下，输入127.0.0.1/index.html ，嗯？连第一个女神都不理我了？！我靠！为毛！\n\n冲动是魔鬼！冷静！我打开eclipse控制台，发现服务器根本就没有“正在等待情书中…”，所以我拜托浏览器发过去的情书当然就发丢了，因为根本没人在接收啊。（窃喜，还好不是因为我太花心了所以浏览器没有帮我投递情书）可是为什么呢？\n\n冷静吧，分析代码。其实我们可以想到，这段代码执行完一次后不就结束了吗，那我第二次给她发请求她当然会收不到了。对啊，那为了解决这个问题，怎么办呢？跪求红娘支招！\n\n红娘说：“给服务器程序个死循环吧，让她反复在等客户端的请求就好了。”（其实红娘就一直在死循环中）\n\n红娘果然是红娘（不然是谁。。。），那就按照她的说法试一试呗！改代码，加入 while (true) 死循环：\n\n\tpublic class MultiWebServer {   \n\t  \n\t    public static void main(String[] args) {   \n\t  \n\t        String base_url = \"E://课件/计算机网络原理/实验/实验1/\";   \n\t  \n\t        while (true) {   \n\t            try {   \n\t                ServerSocket serverSocket = new ServerSocket(80);   \n\t                System.out.println(\"正在等待情书中...\");   \n\t                Socket socket = serverSocket.accept();   \n\t                System.out.println(\"收到情书，我要开始解析！\");   \n\t                InputStream inputStream = socket.getInputStream();   \n\t                BufferedReader reader = new BufferedReader(   \n\t                        new InputStreamReader(inputStream));   \n\t                String line = reader.readLine();   \n\t                System.out.println(line);   \n\t                String url = line.substring(5, line.indexOf(\"HTTP\") - 1);  \n\t  \n\t                System.out.println(\"情书解析完毕，我要想想怎么回复了...\");   \n\t     \n\t  \n\t                // 获取文件内容   \n\t                inputStream = new FileInputStream(base_url + url);   \n\t                OutputStream outputStream = socket.getOutputStream();   \n\t                byte[] buffer = new byte[4 * 1024];   \n\t                int len = 0;   \n\t                while ((len = inputStream.read(buffer)) != -1) {   \n\t                    outputStream.write(buffer, 0, len);   \n\t                }   \n\t                outputStream.flush();   \n\t  \n\t                System.out.println(\"情书请求已发送给客户端\");  \n\t   \n\t                //关闭对应的资源   \n\t                serverSocket.close();   \n\t                socket.shutdownInput();   \n\t                socket.close();   \n\t                inputStream.close();   \n\t                reader.close();   \n\t                outputStream.close();   \n\t            } catch (Exception e) {   \n\t            }   \n\t        }   \n\t    }   \n\t}\n  \n这样，这位红娘就在这里一直等啊等，来了一个客户端我就处理他的情书请求，处理完这个继续循环以相同的方式等，处理，等，处理。。。。\n\n好吧，咱们接下来试一下，还是务必先运行服务器端程序，然后先和第一个女神表白，即 127.0.0.1/index.html 还是好朋友的话，就别问我返回结果。。。这个时候打开eclipse的控制台，有没有发现右上角的红色暂停标志可以点击，那就说明咱们的红娘还在兢兢业业的工作着！好了，抓紧时间赶紧向第二个女神表白，看她怎么说， 浏览器输入 127.0.0.1/another.html ，回车！好快啊，女神给我答复了。。。\n\n![](http://img.blog.csdn.net/20141018222413725)\n\n这。。。（她怎么知道不到十分钟？你是不是突然想到了cookie可以记录客户端的信息，不过咱们这里没用到cookie）还是看看another.html文件里写了什么吧\n\n\t<html>   \n\t    <head>   \n\t        <meta charset=\"utf-8\" />   \n\t        <title>Welcome</title>   \n\t    </head>   \n\t    <body>      \n\t        <h1>我记得你刚和别人表白吧，还不过十分钟，你怎么会是个好人！</h1>   \n\t    </body>  \n\t</html>  \n\n \n好吧，我啥也不说了，亲们，我还要向第三个女神表白吗。。。？浏览器主动跟我说：“你表白吧，这次你发多少封表白信我都能给你送到服务器那里，因为她一直在等待着我给她发送呢！”想想，还是算了，人生如此，何须多言。。。\n \n代码都贴出来了，其实看起来挺简单的，但是实际操作中会碰到各种各样的问题。\n \n还有一些要再继续唠叨的边角料：\n\n* 1、Q：什么是端口？\n* \nA：这是一个比较抽象的概念，是为了进程间通信，每一个进程只能占用一个端口，也就是说多个进程绝不能同时占用一个端口\n\n* 2、Q：既然多个进程不能同时占用一个端口，那么咱们常说的web服务默认使用的是80端口，我电脑有三个浏览器，谷歌，360，IE他们却可以同时上网，这不是端口冲突了吗？\n* \nA：常说的web服务使用80端口指的是服务器监听web请求的端口，是服务器，不是你自己的客户机。一般来说，一个应用程序打开后访问网络本地操作系统为其分配的端口号是随机的，所以三个浏览器虽然同时接收web服务器的回复报文，由于他们三个各自占用的端口不一样，所以不会产生冲突。\n\n* 3、Q：既然我的应用程序使用的端口都是随机的，服务器接收到请求后怎么知道它要把应答报文发给谁？\n* \nA：靠Socket！通过刚才的编程实战，在我理解，Socket肯定会至少包括四部分内容：IP地址，端口号，输入流和输出流。也就是说，从客户机发给服务器的Socket里一定会有客户机的IP地址和相应应用程序的端口号，这样服务器自然就知道应该把应答报文发给谁了。\n\n* 4、Q：非要使用80端口吗？\n* \nA：不一定。我们刚才在编程的时候确实使用的是80端口，所以我们在浏览器中输入127.0.0.1/index.html，浏览器会默认认为我们会向127.0.0.1主机的80号端口发送请求。但是，这个80端口号只是默认的而已，我们完全可以自己改掉，比如在java代码里把服务器端的ServerSocket改成   ServerSocket serverSocket = new ServerSocket(3456);  这时候我们在浏览器中就要输入 127.0.0.1:3456/index.html  了，效果是一样的，可以浅尝辄止一下。\n\n* 5、Q：谁是客户端，谁是服务器？\n* \nA：咱们只有一台电脑，这台电脑既充当着客户端的角色，又充当着服务器的角色。当浏览器请求网页时，它是客户端；当80端口收到请求报文并应答时，它就是服务器。实在不理解，就想想什么是自恋吧，或者，自交也勉强可以。。\n\n* 6、Q：还有什么问题，欢迎留言~\n \n对于此用java编写的web服务器的一点简单说明：此段代码非常简单，所以肯定不会是真正web服务器所用到的代码，咱们这个只是能够应答最最基本的web请求，不能检测是否跨域访问等等。不过最基本的，用的socket编程是肯定的。另外，对于此段程序，只给出了处理输入输出流的一种方式。对于输入流，除了咱们刚才用到的BufferedReader包装类，还可以直接用InputStream的read()方法等；对于输出流，除了咱们刚才用的OutputStream的write()方法，还可用BufferedWritter，PrintWritter等，这些都是java IO的基本用法，根据网络环境，根据所要读取的文件大小来时时变通，这就是仁者见仁智者见智了。\n \n文章写到了最后，不知道该怎么收尾了，安安静静做个程序员吧，挺好。\n\n \n###个人github: [http://github.com/icodeu](http://github.com/icodeu)\n\n###代码托管地址:[https://github.com/icodeu/JavaForWebServer](https://github.com/icodeu/JavaForWebServer)\n\n###CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n###个人微信号：`qqwanghuan`  只为技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)\n\n\n","slug":"2014-10-18-浅谈用 Java 搭建 web 服务器之 Socket 编程——更好的理解 Apache、Tomcat 等软件的工作模式","published":1,"updated":"2015-08-24T10:21:15.000Z","photos":[],"link":"","_id":"ciw22yo11005iek5xzkfdfnks"},{"_content":"记录的AS快捷键\n\n1. 书签（Bookmarks）\n调用：Menu → Navigate → Bookmarks\n添加/移除书签：F3(OS X) 、F11(Windows/Linux);\n添加/移除书签(带标记)：Alt + F3(OS X)、Ctrl + F11(Windows/Linux);\n\n4. 与剪切板比对（Compare With Clipboard）  Compare with Branch\n\n8. 隐藏所有面板（Hide All Panels）\n调用：Menu → Window → Active Tool Window → Hide All Windows；\n快捷键：Cmd +Shift + F12(OS X)、\n\n9. 高亮一切（Hightlight All the Things）\n调用：Menu → Edit → Find → Highlight Usages in File；\n\n上一个编辑位置（Last Edit Location）\n快捷键： Cmd + Shift + Delete(OS X)\n\n12. 在方法和内部类之间跳转\n调用：Navigate → Next Method/Previous Method;\n快捷键：Ctrl + Up/Down﻿(OS X)\n\n描述：如果光标是在一个继承父类重写的方法里，这个操作将定位到父类实现的地方。如果光标是在类名上，则定位到父类类名。\nMenu → Navigate → Super Class/Method\n快捷键：Cmd + U(OS X)\n\n16. 在外部打开文件\n快捷键：Cmd + 单击Tab(OS X)\n\n18. 快速查看定义（Quick Definition Lookup）\n描述：你曾经是否想查看一个方法或者类的具体实现，但是不想离开当前界面？ 该操作可以帮你搞定。\n快捷键：Alt + Space / Cmd + Y(OS X)\n\n19. 最近修改的文件（Recently Changed Files）\n描述：该操作类似于“最近访问（Recents）”弹窗，会显示最近本地修改过的文件列表，根据修改时间排列。可以输入字符来过滤列表结果。\n快捷键：Cmd + Shift + E(OS X)  Cmd + E\n\n23. Select In\n描述：拿着当前文件然后问你在哪里选中该文件。恕我直言，最有用的就是在项目结构或者资源管理器中打开该文件。每一个操作都有数字或者字母作为前缀，可以通过这个前缀来快速跳转。通常，我会 Alt + F1 然后 回车(Enter) 来打开项目视图，然后 再用 Alt + F1 在OS X的Finder里找到文件。你可以在文件中或者直接在项目视图里使用该操作。\n快捷键：Alt + F1；\n\n25. Sublime Text式的多处选择（Sublime Text Multi Selection）\n描述：这个功能超级赞！该操作会识别当前选中字符串，选择下一个同样的字符串，并且添加一个光标。这意味着你可以在同一个文件里拥有多个光标，你可以同时在所有光标处输入任何东西。\n快捷键：Ctrl + G(OS X)\n\n","source":"_drafts/记录的AS快捷键.markdown","raw":"记录的AS快捷键\n\n1. 书签（Bookmarks）\n调用：Menu → Navigate → Bookmarks\n添加/移除书签：F3(OS X) 、F11(Windows/Linux);\n添加/移除书签(带标记)：Alt + F3(OS X)、Ctrl + F11(Windows/Linux);\n\n4. 与剪切板比对（Compare With Clipboard）  Compare with Branch\n\n8. 隐藏所有面板（Hide All Panels）\n调用：Menu → Window → Active Tool Window → Hide All Windows；\n快捷键：Cmd +Shift + F12(OS X)、\n\n9. 高亮一切（Hightlight All the Things）\n调用：Menu → Edit → Find → Highlight Usages in File；\n\n上一个编辑位置（Last Edit Location）\n快捷键： Cmd + Shift + Delete(OS X)\n\n12. 在方法和内部类之间跳转\n调用：Navigate → Next Method/Previous Method;\n快捷键：Ctrl + Up/Down﻿(OS X)\n\n描述：如果光标是在一个继承父类重写的方法里，这个操作将定位到父类实现的地方。如果光标是在类名上，则定位到父类类名。\nMenu → Navigate → Super Class/Method\n快捷键：Cmd + U(OS X)\n\n16. 在外部打开文件\n快捷键：Cmd + 单击Tab(OS X)\n\n18. 快速查看定义（Quick Definition Lookup）\n描述：你曾经是否想查看一个方法或者类的具体实现，但是不想离开当前界面？ 该操作可以帮你搞定。\n快捷键：Alt + Space / Cmd + Y(OS X)\n\n19. 最近修改的文件（Recently Changed Files）\n描述：该操作类似于“最近访问（Recents）”弹窗，会显示最近本地修改过的文件列表，根据修改时间排列。可以输入字符来过滤列表结果。\n快捷键：Cmd + Shift + E(OS X)  Cmd + E\n\n23. Select In\n描述：拿着当前文件然后问你在哪里选中该文件。恕我直言，最有用的就是在项目结构或者资源管理器中打开该文件。每一个操作都有数字或者字母作为前缀，可以通过这个前缀来快速跳转。通常，我会 Alt + F1 然后 回车(Enter) 来打开项目视图，然后 再用 Alt + F1 在OS X的Finder里找到文件。你可以在文件中或者直接在项目视图里使用该操作。\n快捷键：Alt + F1；\n\n25. Sublime Text式的多处选择（Sublime Text Multi Selection）\n描述：这个功能超级赞！该操作会识别当前选中字符串，选择下一个同样的字符串，并且添加一个光标。这意味着你可以在同一个文件里拥有多个光标，你可以同时在所有光标处输入任何东西。\n快捷键：Ctrl + G(OS X)\n\n","slug":"记录的AS快捷键","published":0,"date":"2016-03-20T07:39:01.000Z","updated":"2016-03-20T07:39:01.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yo1e005lek5xrjbqayho"},{"title":"聊聊貌似谁都懂的时间戳","date":"2016-02-27T07:04:44.000Z","_content":"\n问下你自己，真的知道时间戳是什么吗？如果你知道的话，那知道怎么在程序中(如Java)获取时间戳吗，你获取到的是真的『时间戳』吗？\n\n<!--more-->\n\n其实我本身开始对时间戳的概念也很模糊，我就知道是从1970年1月1号到现在经历的时间，我以为这就够了，直到有个需求是关于事件统计的，所以必须要有时间的记录，我一看这个简单啊，不就是时间戳吗，所以在Java里获取时间戳很容易，一行代码搞定，如下\n\n```java\n\tlong curTime = System.currentTimeMillis();\n```\n我就把这个当成\"时间戳\"给后台了，然后PM直接提了个Bug给我，说我给的时间戳格式不对，原因是我获取的是13位的，他要的是10位的时间戳，然后我就上网查了一下关于时间戳的真正定义，如下\n\n> 时间戳是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。\n\n注意最后是\"秒数\"，而我用 System.currentTimeMillis() 获取到的是\"毫秒数\"，所以是13位，然后我就 /1000 就变成了10位的\"时间戳\"。\n\n好像这样时间戳的问题就解决了，不过注意上面一行最后我把\"时间戳\"三个字用引号引起来了，就是说 System.currentTimeMillis() /1000 获取到的还不是真正的时间戳！为什么呢，继续往下看。\n\n测试找到我说，他看到的我传的时间戳用换算工具计算后并不是当时北京的真正时间，而是比当时北京的时间快了整整四个小时，我当时第一反应这肯定是时区问题，然后查了一下他手机的时区和北京的确实是相差了整整四个小时，后来就给他解释是时区问题，如果时区设置无误那就没问题了。\n\n然后故事结束了吗，并没有，后来我就在想，时间戳真的和时区有关系吗？我又仔细读了一下关于时间戳的定义，要不你也来仔细品读一下：\n\n>  时间戳是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。\n\n好好看『格林威治时间』，说白了，不管你身在哪里，处于哪个时区，在这个地球上的同一时刻时间戳一定是相同的，时间戳跟所谓的时区没有半毛钱关系！\n\n所以说真正的时间戳和时区是没有关系的，同一时刻时间戳就是一个定值而不会受任何其他因素影响。那么在Java中怎么能获取当前准确的真正的时间戳呢？\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_drafts/timestamp-android.markdown","raw":"title: 聊聊貌似谁都懂的时间戳\ndate: 2016-02-27 15:04:44 \ntags: Android\n----\n\n问下你自己，真的知道时间戳是什么吗？如果你知道的话，那知道怎么在程序中(如Java)获取时间戳吗，你获取到的是真的『时间戳』吗？\n\n<!--more-->\n\n其实我本身开始对时间戳的概念也很模糊，我就知道是从1970年1月1号到现在经历的时间，我以为这就够了，直到有个需求是关于事件统计的，所以必须要有时间的记录，我一看这个简单啊，不就是时间戳吗，所以在Java里获取时间戳很容易，一行代码搞定，如下\n\n```java\n\tlong curTime = System.currentTimeMillis();\n```\n我就把这个当成\"时间戳\"给后台了，然后PM直接提了个Bug给我，说我给的时间戳格式不对，原因是我获取的是13位的，他要的是10位的时间戳，然后我就上网查了一下关于时间戳的真正定义，如下\n\n> 时间戳是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。\n\n注意最后是\"秒数\"，而我用 System.currentTimeMillis() 获取到的是\"毫秒数\"，所以是13位，然后我就 /1000 就变成了10位的\"时间戳\"。\n\n好像这样时间戳的问题就解决了，不过注意上面一行最后我把\"时间戳\"三个字用引号引起来了，就是说 System.currentTimeMillis() /1000 获取到的还不是真正的时间戳！为什么呢，继续往下看。\n\n测试找到我说，他看到的我传的时间戳用换算工具计算后并不是当时北京的真正时间，而是比当时北京的时间快了整整四个小时，我当时第一反应这肯定是时区问题，然后查了一下他手机的时区和北京的确实是相差了整整四个小时，后来就给他解释是时区问题，如果时区设置无误那就没问题了。\n\n然后故事结束了吗，并没有，后来我就在想，时间戳真的和时区有关系吗？我又仔细读了一下关于时间戳的定义，要不你也来仔细品读一下：\n\n>  时间戳是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。\n\n好好看『格林威治时间』，说白了，不管你身在哪里，处于哪个时区，在这个地球上的同一时刻时间戳一定是相同的，时间戳跟所谓的时区没有半毛钱关系！\n\n所以说真正的时间戳和时区是没有关系的，同一时刻时间戳就是一个定值而不会受任何其他因素影响。那么在Java中怎么能获取当前准确的真正的时间戳呢？\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"timestamp-android","published":0,"updated":"2016-02-28T13:46:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yo1g005mek5x81ze3xhh"},{"_content":"title: listview-optimize\n\n## tags: Android\n\n打算写个系列文章好好说一下 ListView 的优化问题（或GridView，其实差不了多少）。\n\n\n\n如果 ListView 里只有文字，其实对于内存占用方面来说也没有什么可优化的，滚动起来也不会明显卡顿，关键就在于如果 ListView 中有图片了，这个时候就要好好想想需要怎么来进行优化了，所以本系列文章就分层次分别说说 ListView 图片加载优化问题，包含两个层次：ListView 本身的优化问题，图片的内存加载问题。\n\n\n\n## ListView 本身的优化\n\n1、一定要利用好 convertView，减少 inflate 布局的时间\n\n2、使用 ViewHolder，减少 findViewById 的时间\n\n3、滚动不加载、停止才加载，按需加载，减少滑动卡顿\n\n\n\n## 图片的内存加载优化\n\n1、减小图片本身占用内存大小\n\n2、防止图片错位\n\n3、使用内存缓存\n\n4、使用外存缓存","source":"_drafts/listview-optimize.md","raw":"title: listview-optimize\n\n## tags: Android\n\n打算写个系列文章好好说一下 ListView 的优化问题（或GridView，其实差不了多少）。\n\n\n\n如果 ListView 里只有文字，其实对于内存占用方面来说也没有什么可优化的，滚动起来也不会明显卡顿，关键就在于如果 ListView 中有图片了，这个时候就要好好想想需要怎么来进行优化了，所以本系列文章就分层次分别说说 ListView 图片加载优化问题，包含两个层次：ListView 本身的优化问题，图片的内存加载问题。\n\n\n\n## ListView 本身的优化\n\n1、一定要利用好 convertView，减少 inflate 布局的时间\n\n2、使用 ViewHolder，减少 findViewById 的时间\n\n3、滚动不加载、停止才加载，按需加载，减少滑动卡顿\n\n\n\n## 图片的内存加载优化\n\n1、减小图片本身占用内存大小\n\n2、防止图片错位\n\n3、使用内存缓存\n\n4、使用外存缓存","slug":"listview-optimize","published":0,"date":"2015-11-05T12:09:08.000Z","updated":"2015-11-05T12:09:08.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yo1i005oek5xgquory1o"},{"title":"Android TextView 上下自带空白边距坑的我好惨","date":"2016-01-23T07:04:44.000Z","_content":"\nUI 给了张图，断章取义简单来说就是两个竖直排列的文本之间的距离是10px，我看这个简单啊，直接给下面那个TextView设置一个 marginTop = 10 px(暂时不考虑单位具体用什么)，每个字体的间距我都是这么设计的，结果只要跟文字间距相关的，UI都给我打回来了。我并没觉得自己错了啊，程序里就那么写的怎么会错呢，我还打开了开发者选项去给UI看，UI说她不按开发者选项框出来的红边量，就按上边文本最下面的像素和下边文本最上面的像素量，下面给张图意思一下。如果你也打开开发者选项看TextView的话，你会发现文字上下都有空白的部分，怎么能按照UI的要求，把空白距离也计算到给的尺寸当中呢？我真是研究了好大一半天，现在也把过程和结果写出来供后面踩同样的坑的人参考。\n\n<!--more-->\n\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_drafts/android-textview-fontmetrics.markdown","raw":"title: Android TextView 上下自带空白边距坑的我好惨\ndate: 2016-01-23 15:04:44 \ntags: Android\n----\n\nUI 给了张图，断章取义简单来说就是两个竖直排列的文本之间的距离是10px，我看这个简单啊，直接给下面那个TextView设置一个 marginTop = 10 px(暂时不考虑单位具体用什么)，每个字体的间距我都是这么设计的，结果只要跟文字间距相关的，UI都给我打回来了。我并没觉得自己错了啊，程序里就那么写的怎么会错呢，我还打开了开发者选项去给UI看，UI说她不按开发者选项框出来的红边量，就按上边文本最下面的像素和下边文本最上面的像素量，下面给张图意思一下。如果你也打开开发者选项看TextView的话，你会发现文字上下都有空白的部分，怎么能按照UI的要求，把空白距离也计算到给的尺寸当中呢？我真是研究了好大一半天，现在也把过程和结果写出来供后面踩同样的坑的人参考。\n\n<!--more-->\n\n\n\n\n\n\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"android-textview-fontmetrics","published":0,"updated":"2016-01-25T01:34:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yo1j005pek5x3owpzqr4"},{"title":"Android 踩坑奇遇记之 getLocationOnScreen - 获取View在屏幕上的位置","date":"2016-02-27T07:04:44.000Z","_content":"\n有个需求，将某个View置于整个屏幕三分之一的地方，Android又不像CSS那样直接有一个 %33 就可以实现，所以获取这个View当前在屏幕中的位置是必不可少的一个步骤，也就是今天要说的 getLocationOnScreen。\n\n<!--more-->\n\n其实这个函数 getLocationOnScreen 应该是见名知意的，就是获取View在屏幕上的位置，让我们也来一睹官方的文档\n\n```文档```\n\n所以简单使用的话代码也很简单，如下\n\n所以location[2]这个数组就保存了当前View相对整个屏幕的绝对坐标\n\n这样一看很简单啊，可是我确遇到了一个问题，用这段代码算出来的不准！我直接说原因了，因为我要测量的View上面还有一个设置了GONE属性的其他View。\n\n先看我的xml文件，可以看到是一个vertical方向的LinearLayout，其中有上下两个view，我要测量的是下面那个view在屏幕上的位置，同时注意上面那个view的visibility=\"GONE\"，所以程序跑起来界面也很简单，如下，我顺便把具体像素值也标注出来了\n\n好了，那么下面咱们就在Java代码里测量一下下面那个view的位置，代码刚才简要说过了，具体如下：\n\n你会发现 Log 中显示的像素值和咱们用 PS 实际测出来的 不一样！Log中打出来的像素值其实是包括了那个Visibility=\"GONE\"的那个view的。\n\n此时如果你再试着把xml中visibility=\"GONE\"的元素给删掉，再运行一遍原来的Java代码，你会发现Log中打出来的和PS实际测量的结果完全一致了。\n\n那么到此，我就在想，既然它上面view已经gone了（注意是gone，而不是visible），为什么还要在screen上占着location，从而导致下面元素的 getLocationOnScreen 结果都不准确，不得其解，看看源码怎么写的吧。\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_drafts/android-getlocationonscreen.markdown","raw":"title: Android 踩坑奇遇记之 getLocationOnScreen - 获取View在屏幕上的位置\ndate: 2016-02-27 15:04:44 \ntags: Android\n----\n\n有个需求，将某个View置于整个屏幕三分之一的地方，Android又不像CSS那样直接有一个 %33 就可以实现，所以获取这个View当前在屏幕中的位置是必不可少的一个步骤，也就是今天要说的 getLocationOnScreen。\n\n<!--more-->\n\n其实这个函数 getLocationOnScreen 应该是见名知意的，就是获取View在屏幕上的位置，让我们也来一睹官方的文档\n\n```文档```\n\n所以简单使用的话代码也很简单，如下\n\n所以location[2]这个数组就保存了当前View相对整个屏幕的绝对坐标\n\n这样一看很简单啊，可是我确遇到了一个问题，用这段代码算出来的不准！我直接说原因了，因为我要测量的View上面还有一个设置了GONE属性的其他View。\n\n先看我的xml文件，可以看到是一个vertical方向的LinearLayout，其中有上下两个view，我要测量的是下面那个view在屏幕上的位置，同时注意上面那个view的visibility=\"GONE\"，所以程序跑起来界面也很简单，如下，我顺便把具体像素值也标注出来了\n\n好了，那么下面咱们就在Java代码里测量一下下面那个view的位置，代码刚才简要说过了，具体如下：\n\n你会发现 Log 中显示的像素值和咱们用 PS 实际测出来的 不一样！Log中打出来的像素值其实是包括了那个Visibility=\"GONE\"的那个view的。\n\n此时如果你再试着把xml中visibility=\"GONE\"的元素给删掉，再运行一遍原来的Java代码，你会发现Log中打出来的和PS实际测量的结果完全一致了。\n\n那么到此，我就在想，既然它上面view已经gone了（注意是gone，而不是visible），为什么还要在screen上占着location，从而导致下面元素的 getLocationOnScreen 结果都不准确，不得其解，看看源码怎么写的吧。\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"android-getlocationonscreen","published":0,"updated":"2016-02-27T02:26:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw22yo1k005rek5xff0j678r"},{"title":"Python远程调试及frp内网穿透","date":"2018-11-22T14:00:00.000Z","_content":"\n讲述利用Pycharm进行远程调试，及内网环境下如何打通内网和外网。\n\n<!--more-->\n\n# 先说Python远程调试\n\n### 依赖pycharm-debug.egg\n\n需要pycharm-debug.egg库，位置在`应用程序->右键PyCharm->显示包内容->Content/debug-eggs/pycharm-debug.egg`(还有一个pycharm-debug-py3k.egg，是用于python3.x版本的)。注意一定要用当前Pycharm包中的，否则有可能会出现版本不一致的问题。将其拷贝到项目目录，并加入到依赖，具体代码如下：\n\n```\nimport sys\nimport os\n\nWORK_SPACE = os.path.split(os.path.abspath(__file__))[0]\nsys.path.append(WORK_SPACE + \"/pycharm-debug.egg\")\n```\n\n### 使用pycharm-debug.egg\n\n只需要两行代码，具体如下：\n\n```\nimport pydevd\npydevd.settrace('your-local-ip', port=your-local-port, stdoutToServer=True, stderrToServer=True)\n```\n\n注意ip和port都需要填写本机的，因为pycharm debug的原理是:`本机监听远端，远端主动连接本机`。\n\n刚才的settrace是为了远端在执行这个代码时，主动连接your-local-ip:your-local-port，即只完成了`远程主动连接本机`，现在还需要配置一下`本机监听远端`，点击Edit Configurations...，，左侧 + -> Python Remote Debug，名字随意写，主要是 Local host name 配置成 your-local-ip，port 配置成 your-local-port(此时会发现上面提示的内容就是刚才的settrace)，点击OK保存即可。之后切换到remotedebug，点击Debug按钮，本机即可在your-local-ip监听your-local-port端口，如图\n![python](http://qiniu.icodeyou.com/python-remotedebug-0.png)\n\n![python](http://qiniu.icodeyou.com/python-remotedebug-1.png)\n\n\n### 上传代码至远端并debug\n\n先看一下最终的代码\n![python](http://qiniu.icodeyou.com/python-remotedebug-2.png)\n\n将代码上传到远端，直接 python Main.py 执行，远端会根据settrace主动连接本机，如果没问题的话，本机就可以进入debug了(记得先在本机打断点)。\n\n需要注意一点，可能会弹出这个窗口，意味着虽然连接上了，但是远端和本地的文件没有映射上，解决办法是点击 Auto-detect\n![python](http://qiniu.icodeyou.com/python-remotedebug-3.png)\n\n\n\n# 再说内网穿透\n\n如果本机和远端都是在一个网段内，即都是公网或都是局域网，那么上述方法就可以完成调试了；但如果远端是公网，本机是局域网，就要稍微麻烦点了，原因是公网机器无法直接连接上局域网机器(试想10.x.x.x的公网是肯定连不上192.x.x.x的)。\n\n若想公网主动连接局域网，可以使用内网穿透技术。内网穿透依赖NAT的相关知识，关于NAT直接看图\n![python](http://qiniu.icodeyou.com/python-remotedebug-4.png)\n\n内网穿透原理\n![python](http://qiniu.icodeyou.com/python-remotedebug-5.png)\n\n\n结论如图所示：\n\n- 公网不能直接访问内网ip\n\n- 内网可以直接访问公网ip，因为有路由器的NAT转换，且连接一旦建立便可双向通信\n\n- 内网可以先向\"中间代理公网\"\"注册\"自己的ip和端口，由\"中间代理公网\"和内网ip直接通信，做端口转发\n\n那么为了实现内网穿透，需要两个条件：\n\n- 一台公网可访问的主机，假设公网ip为10.0.0.2\n\n- 内网穿透软件，以frp为例\n\nfrp的地址见[github](https://github.com/fatedier/frp/releases)，在其release页面下载对应的版本。对于Linux它提供了很多版本，可以执行`lsb_release -a`查看机器具体版本，下载即可。\n\n### frp的配置\n\n看文档的话可以直接略过这一节。\n\n#### frps服务端\n\n即公网机器的配置，`vi frps.ini`\n\n```\n[common]\nbind_port = 8018\n```\n\n代表公网的frps程序开放8018端口与内网的frpc通信，执行 `./frps -c ./frps.ini &` 启动frps，等待内网机器连接。\n![python](http://qiniu.icodeyou.com/python-remotedebug-7.png)\n\n\n#### frpc客户端\n\n即内网机器的配置，`vi frpc.ini`\n\n```\n[common]\nserver_addr = 10.0.0.2\nserver_port = 8018\n\n[ssh]\ntype = tcp\nlocal_ip = 192.0.0.1\nlocal_port = 22\nremote_port = 6000\n```\n\n客户端将访问 10.0.0.2:8018 与公网 frps 建立连接，并告诉公网 frps: `所有访问你6000的都转发到我的22号端口来`，具体流程可参考上面内网穿透原理图。执行 `./frpc -c ./frpc.ini &` 启动frpc，即可完成内网穿透。\n![python](http://qiniu.icodeyou.com/python-remotedebug-8.png)\n\n那么至此所完成的功能是：`另一台公网主机10.0.0.1访问10.0.0.2:6000端口即可与内网192.0.0.1:22端口建立双向通信`。\n\n内网穿透搞定了，接下来回到python远程调试，还是对于上面ip和端口的例子\n\n- 假定本机是192.0.0.1\n\n- 内网穿透\"中间代理\"是公网10.0.0.2\n\n- 远程执行代码的是公网10.0.0.1\n\n\n那么在本机的remote configuration中，Local host name应配置为192.0.0.1，Port配置为22。\n\n那么在远程的10.0.0.1中，代码应为\n\n```\npydevd.settrace('10.0.0.2', port=6000, stdoutToServer=True, stderrToServer=True)\n```\n\n这样，远端代码在settrace访问10.0.0.2:6000时，便可以与192.0.0.1:22建立双向通信。\n\n至此，内网和公网环境下的python远程调试得以解决。\n\n上述例子中有两台公网机器，分别为10.0.0.1和10.0.0.2，真的需要两台才可以完成内网穿透吗？\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/python-remotedebug.markdown","raw":"title: Python远程调试及frp内网穿透\ndate: 2018-11-22 22:00:00\ntags: [Python, Pycharm, frp]\n----\n\n讲述利用Pycharm进行远程调试，及内网环境下如何打通内网和外网。\n\n<!--more-->\n\n# 先说Python远程调试\n\n### 依赖pycharm-debug.egg\n\n需要pycharm-debug.egg库，位置在`应用程序->右键PyCharm->显示包内容->Content/debug-eggs/pycharm-debug.egg`(还有一个pycharm-debug-py3k.egg，是用于python3.x版本的)。注意一定要用当前Pycharm包中的，否则有可能会出现版本不一致的问题。将其拷贝到项目目录，并加入到依赖，具体代码如下：\n\n```\nimport sys\nimport os\n\nWORK_SPACE = os.path.split(os.path.abspath(__file__))[0]\nsys.path.append(WORK_SPACE + \"/pycharm-debug.egg\")\n```\n\n### 使用pycharm-debug.egg\n\n只需要两行代码，具体如下：\n\n```\nimport pydevd\npydevd.settrace('your-local-ip', port=your-local-port, stdoutToServer=True, stderrToServer=True)\n```\n\n注意ip和port都需要填写本机的，因为pycharm debug的原理是:`本机监听远端，远端主动连接本机`。\n\n刚才的settrace是为了远端在执行这个代码时，主动连接your-local-ip:your-local-port，即只完成了`远程主动连接本机`，现在还需要配置一下`本机监听远端`，点击Edit Configurations...，，左侧 + -> Python Remote Debug，名字随意写，主要是 Local host name 配置成 your-local-ip，port 配置成 your-local-port(此时会发现上面提示的内容就是刚才的settrace)，点击OK保存即可。之后切换到remotedebug，点击Debug按钮，本机即可在your-local-ip监听your-local-port端口，如图\n![python](http://qiniu.icodeyou.com/python-remotedebug-0.png)\n\n![python](http://qiniu.icodeyou.com/python-remotedebug-1.png)\n\n\n### 上传代码至远端并debug\n\n先看一下最终的代码\n![python](http://qiniu.icodeyou.com/python-remotedebug-2.png)\n\n将代码上传到远端，直接 python Main.py 执行，远端会根据settrace主动连接本机，如果没问题的话，本机就可以进入debug了(记得先在本机打断点)。\n\n需要注意一点，可能会弹出这个窗口，意味着虽然连接上了，但是远端和本地的文件没有映射上，解决办法是点击 Auto-detect\n![python](http://qiniu.icodeyou.com/python-remotedebug-3.png)\n\n\n\n# 再说内网穿透\n\n如果本机和远端都是在一个网段内，即都是公网或都是局域网，那么上述方法就可以完成调试了；但如果远端是公网，本机是局域网，就要稍微麻烦点了，原因是公网机器无法直接连接上局域网机器(试想10.x.x.x的公网是肯定连不上192.x.x.x的)。\n\n若想公网主动连接局域网，可以使用内网穿透技术。内网穿透依赖NAT的相关知识，关于NAT直接看图\n![python](http://qiniu.icodeyou.com/python-remotedebug-4.png)\n\n内网穿透原理\n![python](http://qiniu.icodeyou.com/python-remotedebug-5.png)\n\n\n结论如图所示：\n\n- 公网不能直接访问内网ip\n\n- 内网可以直接访问公网ip，因为有路由器的NAT转换，且连接一旦建立便可双向通信\n\n- 内网可以先向\"中间代理公网\"\"注册\"自己的ip和端口，由\"中间代理公网\"和内网ip直接通信，做端口转发\n\n那么为了实现内网穿透，需要两个条件：\n\n- 一台公网可访问的主机，假设公网ip为10.0.0.2\n\n- 内网穿透软件，以frp为例\n\nfrp的地址见[github](https://github.com/fatedier/frp/releases)，在其release页面下载对应的版本。对于Linux它提供了很多版本，可以执行`lsb_release -a`查看机器具体版本，下载即可。\n\n### frp的配置\n\n看文档的话可以直接略过这一节。\n\n#### frps服务端\n\n即公网机器的配置，`vi frps.ini`\n\n```\n[common]\nbind_port = 8018\n```\n\n代表公网的frps程序开放8018端口与内网的frpc通信，执行 `./frps -c ./frps.ini &` 启动frps，等待内网机器连接。\n![python](http://qiniu.icodeyou.com/python-remotedebug-7.png)\n\n\n#### frpc客户端\n\n即内网机器的配置，`vi frpc.ini`\n\n```\n[common]\nserver_addr = 10.0.0.2\nserver_port = 8018\n\n[ssh]\ntype = tcp\nlocal_ip = 192.0.0.1\nlocal_port = 22\nremote_port = 6000\n```\n\n客户端将访问 10.0.0.2:8018 与公网 frps 建立连接，并告诉公网 frps: `所有访问你6000的都转发到我的22号端口来`，具体流程可参考上面内网穿透原理图。执行 `./frpc -c ./frpc.ini &` 启动frpc，即可完成内网穿透。\n![python](http://qiniu.icodeyou.com/python-remotedebug-8.png)\n\n那么至此所完成的功能是：`另一台公网主机10.0.0.1访问10.0.0.2:6000端口即可与内网192.0.0.1:22端口建立双向通信`。\n\n内网穿透搞定了，接下来回到python远程调试，还是对于上面ip和端口的例子\n\n- 假定本机是192.0.0.1\n\n- 内网穿透\"中间代理\"是公网10.0.0.2\n\n- 远程执行代码的是公网10.0.0.1\n\n\n那么在本机的remote configuration中，Local host name应配置为192.0.0.1，Port配置为22。\n\n那么在远程的10.0.0.1中，代码应为\n\n```\npydevd.settrace('10.0.0.2', port=6000, stdoutToServer=True, stderrToServer=True)\n```\n\n这样，远端代码在settrace访问10.0.0.2:6000时，便可以与192.0.0.1:22建立双向通信。\n\n至此，内网和公网环境下的python远程调试得以解决。\n\n上述例子中有两台公网机器，分别为10.0.0.1和10.0.0.2，真的需要两台才可以完成内网穿透吗？\n\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"python-remotedebug","published":1,"updated":"2018-11-23T09:17:06.635Z","_id":"cjotrvcj800008r5xi4tvlvu3","comments":1,"layout":"post","photos":[],"link":""},{"title":"在AndroidStudio中使用FindBugs","date":"2017-04-06T07:04:44.000Z","_content":"\n本篇文章讲解使用配置gradle task的方式集成findbugs插件，不用在AndroidStudio的插件系统中安装任何东西，同步下gradle就可以使用，方便团队内成员写完代码后用FindBugs进行检查。\n\n<!--more-->\n\n## 基本配置\n\n在 app/build.gradle 中最上面指明使用的plugin，如下\n\n```\n\tapply plugin: \"findbugs\"\n```\n\n再添加一个task，如下\n\n```\n\ttask findbugs(type: FindBugs, dependsOn: 'assembleDebug') {\n    // 过滤器\n    excludeFilter file(\"findbugs-filter.xml\")\n    // 有警告错误的时候允许构建\n    ignoreFailures = true\n    effort = \"default\"\n    // 报告级别 low|medium|high\n    reportLevel = \"medium\"\n    println(\"$project.buildDir\")\n    classes = files(\"$project.buildDir/intermediates/classes\")\n    source = fileTree(\"src/main/java/\")\n    classpath = files()\n    reports {\n        xml.enabled = false\n        html.enabled = true\n        xml {\n            destination \"$project.buildDir/findbugs.xml\"\n        }\n        html {\n            destination \"$project.buildDir/findbugs.html\"\n        }\n    }\n}\n\n```\n\n其中各项参数含义为\nexcludeFilter\neffort\nreportLevel\nclasses\nsource\nreports\n\n我也试图在网上找一些关于使用 JitPack.io 的教程，但是搜出来的基本是[这篇](http://www.tuicool.com/articles/Vv6jEb)的复制品，根本没讲什么实质性的东西，所以一切只好自己来了。\n\n本项目源码地址: [GitHub/icodeu/HelloLibrary](https://github.com/icodeu/HelloLibrary)\n\n## 如何写 library\n\n在本节，我们一起来新建个 library，打开 Android Studio，New Project，在此工程名为 Hellolibrary，此后一直点击 next 直至 finish 即可。此时应该是只有一个 module 名为 app，一会我们会把它当做依赖 library 的示例模块来使用，暂时先不管，我们先来创建一个 library，File->New->Module，选择 Android library，之后起个名字，在此叫做 library，finish 即可，此时工程目录如下所示，其中 app 用来依赖使用 library。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack00.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack01.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack02.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack03.png)\n\n怎么指定一个 module 到底是普通的 application 还是 library 呢？打开 module 对应的 build.gradle 文件，看第一行 `apply plugin: xxx`，如果是 application 的话，plugin 就是 'com.android.application'，library 的话就是 'com.android.library'，就这么简单，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack22.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack23.png)\n\n接下来在 library 中 New->Java Class，在此就是演示，所以我们就尽可能把不重要的东西简单化，名字就叫做 CustomUtil，只有一个静态方法，如下图所示：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack04.png)\n\n其实到此最简单的 library 就写好了，下面就在 app 中来依赖刚才的这个 library 看看效果。打开 app 的 build.gradle，在最后的 dependencies 节点添加一行，`compile project(':library')`，再 Sync 一下 Gradle即可，这样 app 就完成了对 library 的依赖。另外还有一种方法去依赖 library，右键 app 这个 module，选择 Open Module Settings，切换到最后一个Tab:Dependencies，点击左下角的加号->Module dependency->选择 library，这样也能完成 app 对 library 的依赖。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack05.png)\n\n那怎么能在代码上看出来 app 确实成功依赖了 library 呢？我们打开 app 中的 MainActivity，输入 CustomUtil 试一下，如果发现像下图那样给你智能提示了，那就OK了，从下图还能看到 CustomUtil 类所在的包是 com.icodeyou.library。我们调用一下它吧，如下图也很简单，不解释了。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack06.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack07.png)\n\n到此为止我们就自己写了一个最简单的 library 并完成了自己本地的依赖调用，这都是自己玩玩，那怎么能让别人也用上咱们刚才那个高大上的 library 呢，继续往下看。\n\n\n## 如何在 JitPack.io Publish Android Library\n\n首先来概览一下我们要完成的最终效果是什么，我之前有一个开源库，地址在 [https://github.com/icodeu/CommonAdapter](https://github.com/icodeu/CommonAdapter)，打开 JitPack.io 的网站，将我的开源库地址粘贴进去，Look up->Get it，即可看到熟悉的 compile 了，按照下面那个提示复制到相应的 build.gradle 文件中就可以完成 library 的依赖了，不信你试试啊。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack08.png)\n\n下面就来具体讲解一下如何将刚才本地的 library 与 JitPack.io 结合起来，JitPack 的官方文档在这里 [Publish Android library](https://jitpack.io/docs/ANDROID/)\n\n打开 Project 的 root build.gradle，在 dependencies 节点添加一个 classpath：`classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'`，再打开 library 的 build.gradle，在文件起始添加如下两行 `apply plugin: 'com.github.dcendents.android-maven'` `group='com.github.icodeu'`(注意这是你GitHub的用户名)，两个文件的示意图如下：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack09.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack10.png)\n\n下面检查你的Project目录是否存在 gradle/wrapper/gradle-wrapper.jar、gradle-wrapper.properties 这两个文件，如果存在可跳过下面这步，如果不存在，请按下面的进行操作。打开当前项目的 Terminal，先后执行 `gradle wrapper` 和 `./gradlew install` 两个命令，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack11.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack20.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack21.png)\n\n\n从 JitPack 首页也能看出来，其实我们是要粘贴一个 GitHub 项目地址进去，所以我们接下来就要把 library 先上传到 GitHub 上面。\n\n在 GitHub 上新建一个仓库，这里命名为 HelloLibrary，之后 clone 到本地，再把 Project 目录所有的文件复制进去，比如在我这里，仓库 clone 到了桌面的 HelloLibrary 文件夹，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack12.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack13.png)\n\n把这些文件 push 到 GitHub 上，push 成功之后，点击项目的 releases->Create a new release，填写好版本号等内容，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack15.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack16.png)\n\n填写好后点击 Publish release 即可，然后我们复制下图红框中的项目地址，粘贴到 JitPack.io 上面，Look up->Get it，在下面就能看到使用方法了。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack17.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack18.png)\n\n首先打开 Project root 的 build.gradle，在 repositories 节点添加上 `maven { url \"https://jitpack.io\" }`，之后打开想依赖这个 library 的模块，比如这里我们是 app 这个 module，在 dependencies 节点添加上 `compile 'com.github.icodeu:Hellolibrary:v1.0'`，Sync 一下 Gradle，这样就可以了。如果 Sync 成功了，那我们在 app 中就成功依赖了 GitHub 上的 library，此时可以打开 app 的 Module Settings，看一下它的 Dependencies，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack24.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack25.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack19.png)\n\n好了，到此就完成了使用 JitPack.io + GitHub 发布开源库了，相比 jCenter 和 MavenCentral 方式简直爽的不要不要的\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","source":"_posts/AndroidStudioFindBugs.markdown","raw":"title: 在AndroidStudio中使用FindBugs\ndate: 2017-04-06 15:04:44 \ntags: android\n----\n\n本篇文章讲解使用配置gradle task的方式集成findbugs插件，不用在AndroidStudio的插件系统中安装任何东西，同步下gradle就可以使用，方便团队内成员写完代码后用FindBugs进行检查。\n\n<!--more-->\n\n## 基本配置\n\n在 app/build.gradle 中最上面指明使用的plugin，如下\n\n```\n\tapply plugin: \"findbugs\"\n```\n\n再添加一个task，如下\n\n```\n\ttask findbugs(type: FindBugs, dependsOn: 'assembleDebug') {\n    // 过滤器\n    excludeFilter file(\"findbugs-filter.xml\")\n    // 有警告错误的时候允许构建\n    ignoreFailures = true\n    effort = \"default\"\n    // 报告级别 low|medium|high\n    reportLevel = \"medium\"\n    println(\"$project.buildDir\")\n    classes = files(\"$project.buildDir/intermediates/classes\")\n    source = fileTree(\"src/main/java/\")\n    classpath = files()\n    reports {\n        xml.enabled = false\n        html.enabled = true\n        xml {\n            destination \"$project.buildDir/findbugs.xml\"\n        }\n        html {\n            destination \"$project.buildDir/findbugs.html\"\n        }\n    }\n}\n\n```\n\n其中各项参数含义为\nexcludeFilter\neffort\nreportLevel\nclasses\nsource\nreports\n\n我也试图在网上找一些关于使用 JitPack.io 的教程，但是搜出来的基本是[这篇](http://www.tuicool.com/articles/Vv6jEb)的复制品，根本没讲什么实质性的东西，所以一切只好自己来了。\n\n本项目源码地址: [GitHub/icodeu/HelloLibrary](https://github.com/icodeu/HelloLibrary)\n\n## 如何写 library\n\n在本节，我们一起来新建个 library，打开 Android Studio，New Project，在此工程名为 Hellolibrary，此后一直点击 next 直至 finish 即可。此时应该是只有一个 module 名为 app，一会我们会把它当做依赖 library 的示例模块来使用，暂时先不管，我们先来创建一个 library，File->New->Module，选择 Android library，之后起个名字，在此叫做 library，finish 即可，此时工程目录如下所示，其中 app 用来依赖使用 library。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack00.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack01.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack02.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack03.png)\n\n怎么指定一个 module 到底是普通的 application 还是 library 呢？打开 module 对应的 build.gradle 文件，看第一行 `apply plugin: xxx`，如果是 application 的话，plugin 就是 'com.android.application'，library 的话就是 'com.android.library'，就这么简单，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack22.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack23.png)\n\n接下来在 library 中 New->Java Class，在此就是演示，所以我们就尽可能把不重要的东西简单化，名字就叫做 CustomUtil，只有一个静态方法，如下图所示：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack04.png)\n\n其实到此最简单的 library 就写好了，下面就在 app 中来依赖刚才的这个 library 看看效果。打开 app 的 build.gradle，在最后的 dependencies 节点添加一行，`compile project(':library')`，再 Sync 一下 Gradle即可，这样 app 就完成了对 library 的依赖。另外还有一种方法去依赖 library，右键 app 这个 module，选择 Open Module Settings，切换到最后一个Tab:Dependencies，点击左下角的加号->Module dependency->选择 library，这样也能完成 app 对 library 的依赖。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack05.png)\n\n那怎么能在代码上看出来 app 确实成功依赖了 library 呢？我们打开 app 中的 MainActivity，输入 CustomUtil 试一下，如果发现像下图那样给你智能提示了，那就OK了，从下图还能看到 CustomUtil 类所在的包是 com.icodeyou.library。我们调用一下它吧，如下图也很简单，不解释了。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack06.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack07.png)\n\n到此为止我们就自己写了一个最简单的 library 并完成了自己本地的依赖调用，这都是自己玩玩，那怎么能让别人也用上咱们刚才那个高大上的 library 呢，继续往下看。\n\n\n## 如何在 JitPack.io Publish Android Library\n\n首先来概览一下我们要完成的最终效果是什么，我之前有一个开源库，地址在 [https://github.com/icodeu/CommonAdapter](https://github.com/icodeu/CommonAdapter)，打开 JitPack.io 的网站，将我的开源库地址粘贴进去，Look up->Get it，即可看到熟悉的 compile 了，按照下面那个提示复制到相应的 build.gradle 文件中就可以完成 library 的依赖了，不信你试试啊。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack08.png)\n\n下面就来具体讲解一下如何将刚才本地的 library 与 JitPack.io 结合起来，JitPack 的官方文档在这里 [Publish Android library](https://jitpack.io/docs/ANDROID/)\n\n打开 Project 的 root build.gradle，在 dependencies 节点添加一个 classpath：`classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'`，再打开 library 的 build.gradle，在文件起始添加如下两行 `apply plugin: 'com.github.dcendents.android-maven'` `group='com.github.icodeu'`(注意这是你GitHub的用户名)，两个文件的示意图如下：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack09.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack10.png)\n\n下面检查你的Project目录是否存在 gradle/wrapper/gradle-wrapper.jar、gradle-wrapper.properties 这两个文件，如果存在可跳过下面这步，如果不存在，请按下面的进行操作。打开当前项目的 Terminal，先后执行 `gradle wrapper` 和 `./gradlew install` 两个命令，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack11.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack20.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack21.png)\n\n\n从 JitPack 首页也能看出来，其实我们是要粘贴一个 GitHub 项目地址进去，所以我们接下来就要把 library 先上传到 GitHub 上面。\n\n在 GitHub 上新建一个仓库，这里命名为 HelloLibrary，之后 clone 到本地，再把 Project 目录所有的文件复制进去，比如在我这里，仓库 clone 到了桌面的 HelloLibrary 文件夹，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack12.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack13.png)\n\n把这些文件 push 到 GitHub 上，push 成功之后，点击项目的 releases->Create a new release，填写好版本号等内容，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack15.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack16.png)\n\n填写好后点击 Publish release 即可，然后我们复制下图红框中的项目地址，粘贴到 JitPack.io 上面，Look up->Get it，在下面就能看到使用方法了。\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack17.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack18.png)\n\n首先打开 Project root 的 build.gradle，在 repositories 节点添加上 `maven { url \"https://jitpack.io\" }`，之后打开想依赖这个 library 的模块，比如这里我们是 app 这个 module，在 dependencies 节点添加上 `compile 'com.github.icodeu:Hellolibrary:v1.0'`，Sync 一下 Gradle，这样就可以了。如果 Sync 成功了，那我们在 app 中就成功依赖了 GitHub 上的 library，此时可以打开 app 的 Module Settings，看一下它的 Dependencies，如下图：\n\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack24.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack25.png)\n![img](http://7xivx9.com1.z0.glb.clouddn.com/jitpack19.png)\n\n好了，到此就完成了使用 JitPack.io + GitHub 发布开源库了，相比 jCenter 和 MavenCentral 方式简直爽的不要不要的\n\n### 个人GitHub:  [http://github.com/icodeu](http://github.com/icodeu)\n\n### CSDN博客：[http://blog.csdn.net/icodeyou](http://blog.csdn.net/icodeyou)\n\n### 个人微信号：`qqwanghuan`  技术交流\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/wxqrcode_260.png)","slug":"AndroidStudioFindBugs","published":1,"updated":"2017-04-06T03:16:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjotrvcjt00038r5xdvcjjbw4"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciw22ynxi0006ek5x9847gi72","tag_id":"ciw22ynxn0007ek5xha0nmge5","_id":"ciw22ynxo0008ek5xbm02apyf"},{"post_id":"ciw22ynxp0009ek5x92j3is2e","tag_id":"ciw22ynxq000aek5xgipcfies","_id":"ciw22ynxq000bek5xkq8lmaxp"},{"post_id":"ciw22ynxr000cek5xf0a9m3g2","tag_id":"ciw22ynxs000dek5xdnmnjv4e","_id":"ciw22ynxs000eek5xuiyfmd2k"},{"post_id":"ciw22ynxs000fek5x7crmf8tl","tag_id":"ciw22ynxs000dek5xdnmnjv4e","_id":"ciw22ynxt000gek5x2okdia2j"},{"post_id":"ciw22ynxu000hek5x1yns4n8u","tag_id":"ciw22ynxs000dek5xdnmnjv4e","_id":"ciw22ynxv000iek5xo59sb389"},{"post_id":"ciw22ynxv000jek5x84h0rw4s","tag_id":"ciw22ynxw000kek5xcm4kz56f","_id":"ciw22ynxx000lek5x6v11qps5"},{"post_id":"ciw22ynxx000mek5xbfgr9lzn","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynxy000oek5xc41xjxwe"},{"post_id":"ciw22yny0000pek5xcopcohz0","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yny1000qek5xzs5vys60"},{"post_id":"ciw22yny3000rek5xcadxlyjx","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yny3000sek5x4o7taya8"},{"post_id":"ciw22yny4000tek5xaq0xci77","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yny5000uek5x3hmdmrbr"},{"post_id":"ciw22yny6000vek5xctr5uu75","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yny6000wek5x3wgtdu5x"},{"post_id":"ciw22yny7000xek5xh52ttodx","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yny8000yek5xjnw7a083"},{"post_id":"ciw22yny9000zek5xdycaklnj","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynyb0010ek5xs3u9qobp"},{"post_id":"ciw22ynyc0011ek5x4d5e9wu0","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynyd0013ek5xgopn0lqv"},{"post_id":"ciw22ynyf0014ek5xha1crzfr","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynyf0015ek5xn196nglm"},{"post_id":"ciw22ynyh0016ek5x3qlhm9nl","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynyh0017ek5xogsou2l8"},{"post_id":"ciw22ynyi0018ek5x4vjxfmsz","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynyk0019ek5xk9383f19"},{"post_id":"ciw22ynyk001aek5xnfyj5eou","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynyl001bek5xp1tl5kkm"},{"post_id":"ciw22ynym001cek5xf16sv6hx","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynym001dek5x8wlzf268"},{"post_id":"ciw22ynyn001eek5xnb16qgzg","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynyo001fek5x0lg3fepu"},{"post_id":"ciw22ynyp001gek5x09m8to28","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynyq001hek5xqnezh7aq"},{"post_id":"ciw22ynys001iek5xqgxm57ck","tag_id":"ciw22ynyt001jek5xdj3if5tb","_id":"ciw22ynyt001kek5xay31mkea"},{"post_id":"ciw22ynyu001lek5x4f093rvj","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynyv001mek5x2w98fuj9"},{"post_id":"ciw22ynyv001nek5x48mygs4l","tag_id":"ciw22ynyw001oek5xjsw4s7pl","_id":"ciw22ynyw001pek5xno9mvzev"},{"post_id":"ciw22ynyx001qek5xj6q6htej","tag_id":"ciw22ynyx001rek5x9a84vcys","_id":"ciw22ynyy001sek5x5zmotug9"},{"post_id":"ciw22ynyy001tek5xn9tw2dv3","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynyz001uek5xgfbzjahn"},{"post_id":"ciw22ynz1001vek5xnbvgblzu","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynz3001wek5xaym1r3k0"},{"post_id":"ciw22ynz4001xek5xtv20c3yk","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynz5001yek5x5qyzgfbg"},{"post_id":"ciw22ynz6001zek5xab9cvlc7","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynz70020ek5xjql1pi0k"},{"post_id":"ciw22ynz90021ek5xl1733yqb","tag_id":"ciw22ynxq000aek5xgipcfies","_id":"ciw22ynz90022ek5xo7s28qdu"},{"post_id":"ciw22ynzb0023ek5xpbusnwhy","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynzb0024ek5xbbrisr80"},{"post_id":"ciw22ynzc0025ek5x4rggh3v3","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22ynzd0027ek5xmxqqqtbj"},{"post_id":"ciw22ynzc0025ek5x4rggh3v3","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynzd0028ek5xop658se6"},{"post_id":"ciw22ynze0029ek5xrorp0fzy","tag_id":"ciw22ynxq000aek5xgipcfies","_id":"ciw22ynzf002aek5xs3f9t552"},{"post_id":"ciw22ynzf002bek5xo0dzjhxy","tag_id":"ciw22ynzg002cek5xfag902io","_id":"ciw22ynzg002dek5x21cc4p73"},{"post_id":"ciw22ynzh002eek5xmrxtw6s3","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22ynzh002gek5xx6lxfqo2"},{"post_id":"ciw22ynzh002eek5xmrxtw6s3","tag_id":"ciw22ynzh002fek5x5732ucky","_id":"ciw22ynzh002hek5xp9at86wy"},{"post_id":"ciw22ynzh002eek5xmrxtw6s3","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynzh002iek5xzwoiuco9"},{"post_id":"ciw22ynzi002jek5xj5iip7ob","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22ynzj002kek5xozlj7uj4"},{"post_id":"ciw22ynzi002jek5xj5iip7ob","tag_id":"ciw22ynzh002fek5x5732ucky","_id":"ciw22ynzj002lek5xrtjbb3bf"},{"post_id":"ciw22ynzi002jek5xj5iip7ob","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynzj002mek5xcr22cnt8"},{"post_id":"ciw22ynzk002nek5x8u06ym4b","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22ynzl002oek5xy72u247c"},{"post_id":"ciw22ynzk002nek5x8u06ym4b","tag_id":"ciw22ynzh002fek5x5732ucky","_id":"ciw22ynzl002pek5xa6zoccr4"},{"post_id":"ciw22ynzk002nek5x8u06ym4b","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynzl002qek5xfp1lzdvp"},{"post_id":"ciw22ynzl002rek5x9jno8hgb","tag_id":"ciw22ynzm002sek5xiidenb97","_id":"ciw22ynzn002uek5xb3t22cpk"},{"post_id":"ciw22ynzl002rek5x9jno8hgb","tag_id":"ciw22ynzn002tek5xsd7v600e","_id":"ciw22ynzn002vek5xemwj7hb7"},{"post_id":"ciw22ynzo002wek5xn2uds239","tag_id":"ciw22ynzo002xek5xjsfujir7","_id":"ciw22ynzo002zek5x8vcboeq0"},{"post_id":"ciw22ynzo002wek5xn2uds239","tag_id":"ciw22ynzo002yek5xo782dshl","_id":"ciw22ynzp0030ek5xug4lbbe0"},{"post_id":"ciw22ynzp0031ek5xmdlohhcq","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynzq0032ek5xqiprwnmw"},{"post_id":"ciw22ynzr0033ek5xkl0c4bgl","tag_id":"ciw22ynxw000kek5xcm4kz56f","_id":"ciw22ynzs0034ek5xudpyvdth"},{"post_id":"ciw22ynzs0035ek5x5o89d1px","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22ynzt0036ek5xliqzbg1z"},{"post_id":"ciw22ynzs0035ek5x5o89d1px","tag_id":"ciw22ynzh002fek5x5732ucky","_id":"ciw22ynzt0037ek5xhb1ow2w1"},{"post_id":"ciw22ynzs0035ek5x5o89d1px","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynzt0038ek5xwkie5956"},{"post_id":"ciw22ynzu0039ek5xghlhx5mh","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22ynzv003aek5xumf755jz"},{"post_id":"ciw22ynzu0039ek5xghlhx5mh","tag_id":"ciw22ynzh002fek5x5732ucky","_id":"ciw22ynzv003bek5xnapazdim"},{"post_id":"ciw22ynzu0039ek5xghlhx5mh","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynzv003cek5xdd1wgs8q"},{"post_id":"ciw22ynzw003dek5x9qjqu0q7","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22ynzw003eek5x5txuuz8q"},{"post_id":"ciw22ynzw003dek5x9qjqu0q7","tag_id":"ciw22ynzh002fek5x5732ucky","_id":"ciw22ynzx003fek5x7jiokuc7"},{"post_id":"ciw22ynzw003dek5x9qjqu0q7","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22ynzx003gek5xs6gubzw9"},{"post_id":"ciw22ynzx003hek5xqxhongxr","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22ynzy003iek5xt6jo5xnk"},{"post_id":"ciw22ynzz003jek5xkqedqwhl","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22yo00003lek5x1x7hna35"},{"post_id":"ciw22ynzz003jek5xkqedqwhl","tag_id":"ciw22yo00003kek5xordq22w6","_id":"ciw22yo00003mek5xfgg6e2pi"},{"post_id":"ciw22yo01003nek5xex8t6l7l","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22yo04003oek5x4oke4zz1"},{"post_id":"ciw22yo01003nek5xex8t6l7l","tag_id":"ciw22ynzh002fek5x5732ucky","_id":"ciw22yo04003pek5xla1n7e7b"},{"post_id":"ciw22yo01003nek5xex8t6l7l","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22yo04003qek5xhy8qkk99"},{"post_id":"ciw22yo05003rek5xjwwbnsvg","tag_id":"ciw22ynzo002xek5xjsfujir7","_id":"ciw22yo05003sek5xxdflavoc"},{"post_id":"ciw22yo06003tek5x79muv858","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22yo07003uek5x0tdpsagu"},{"post_id":"ciw22yo06003tek5x79muv858","tag_id":"ciw22ynzh002fek5x5732ucky","_id":"ciw22yo07003vek5xr4pt6z5c"},{"post_id":"ciw22yo06003tek5x79muv858","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22yo07003wek5x6hfxisrj"},{"post_id":"ciw22yo07003xek5x2gc434cu","tag_id":"ciw22yo08003yek5xyaivos10","_id":"ciw22yo08003zek5x6y99i8tx"},{"post_id":"ciw22yo090040ek5xr6abun4p","tag_id":"ciw22ynyx001rek5x9a84vcys","_id":"ciw22yo090041ek5x024ro6e2"},{"post_id":"ciw22yo0a0042ek5xogmxdgjc","tag_id":"ciw22ynyx001rek5x9a84vcys","_id":"ciw22yo0a0043ek5x2tk2tn2b"},{"post_id":"ciw22yo0b0044ek5x0570b1ra","tag_id":"ciw22ynyx001rek5x9a84vcys","_id":"ciw22yo0c0045ek5xeph71ez0"},{"post_id":"ciw22yo0c0046ek5x33s4ysa7","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22yo0d0047ek5xqq1m3v5y"},{"post_id":"ciw22yo0c0046ek5x33s4ysa7","tag_id":"ciw22ynzh002fek5x5732ucky","_id":"ciw22yo0d0048ek5x713fyoxu"},{"post_id":"ciw22yo0c0046ek5x33s4ysa7","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22yo0d0049ek5x9zxgdixp"},{"post_id":"ciw22yo0e004aek5x98w94p1l","tag_id":"ciw22ynzg002cek5xfag902io","_id":"ciw22yo0f004cek5xx0vtyidb"},{"post_id":"ciw22yo0e004aek5x98w94p1l","tag_id":"ciw22yo0f004bek5xrfhty9dy","_id":"ciw22yo0f004dek5x4yorxpp3"},{"post_id":"ciw22yo0g004eek5x06tq67rl","tag_id":"ciw22ynzo002xek5xjsfujir7","_id":"ciw22yo0g004fek5xxsgo97pv"},{"post_id":"ciw22yo0h004gek5x1xa2suy5","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22yo0i004hek5xs5sr1gl4"},{"post_id":"ciw22yo0h004gek5x1xa2suy5","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yo0i004iek5xqy5mneqr"},{"post_id":"ciw22yo0j004jek5x9tmksw79","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22yo0k004kek5x6aoqvi6v"},{"post_id":"ciw22yo0j004jek5x9tmksw79","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yo0k004lek5xrvb98z4t"},{"post_id":"ciw22yo0k004mek5xlvtx4zgt","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22yo0l004nek5xuenyt2al"},{"post_id":"ciw22yo0k004mek5xlvtx4zgt","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yo0l004oek5x2g1l1drm"},{"post_id":"ciw22yo0m004pek5x7krwonvj","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yo0n004qek5x7q3ivai0"},{"post_id":"ciw22yo0o004rek5xrjeacp6q","tag_id":"ciw22ynzd0026ek5xp4e70bza","_id":"ciw22yo0p004sek5xm6yxbypn"},{"post_id":"ciw22yo0o004rek5xrjeacp6q","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yo0p004tek5x716xefwn"},{"post_id":"ciw22yo0q004uek5xuov7u7vx","tag_id":"ciw22ynxw000kek5xcm4kz56f","_id":"ciw22yo0q004vek5xwwo2bt52"},{"post_id":"ciw22yo0r004wek5xp04cjknm","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22yo0s004yek5x9s5h3yho"},{"post_id":"ciw22yo0r004wek5xp04cjknm","tag_id":"ciw22yo0s004xek5x4folfoxx","_id":"ciw22yo0s004zek5xa9qxvg0v"},{"post_id":"ciw22yo0t0050ek5xteodkndd","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22yo0u0053ek5xstpakfud"},{"post_id":"ciw22yo0t0050ek5xteodkndd","tag_id":"ciw22yo0t0051ek5xu0rpsn3y","_id":"ciw22yo0u0054ek5xa9wbxb4f"},{"post_id":"ciw22yo0t0050ek5xteodkndd","tag_id":"ciw22yo0u0052ek5x1u5jhcex","_id":"ciw22yo0v0055ek5xa9v8qy13"},{"post_id":"ciw22yo0v0056ek5x2eqdl7x6","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22yo0w0058ek5xh0s795pm"},{"post_id":"ciw22yo0v0056ek5x2eqdl7x6","tag_id":"ciw22yo0w0057ek5xh148uvfs","_id":"ciw22yo0w0059ek5xv332lv8k"},{"post_id":"ciw22yo0x005aek5x1xxzz6fg","tag_id":"ciw22ynzo002yek5xo782dshl","_id":"ciw22yo0y005bek5xfw01q13f"},{"post_id":"ciw22yo0z005cek5xrljwat2u","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22yo10005fek5xeh1hiaju"},{"post_id":"ciw22yo0z005cek5xrljwat2u","tag_id":"ciw22yo10005dek5xubt88gps","_id":"ciw22yo10005gek5xqwnnvbml"},{"post_id":"ciw22yo0z005cek5xrljwat2u","tag_id":"ciw22yo10005eek5x7vaj3mrz","_id":"ciw22yo10005hek5xlcqetlrd"},{"post_id":"ciw22yo11005iek5xzkfdfnks","tag_id":"ciw22ynyd0012ek5x84q2cbm5","_id":"ciw22yo12005jek5xiyij73at"},{"post_id":"ciw22yo11005iek5xzkfdfnks","tag_id":"ciw22yo10005dek5xubt88gps","_id":"ciw22yo1c005kek5xw42c23t1"},{"post_id":"ciw22yo1g005mek5x81ze3xhh","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yo1h005nek5x8ol7igv4"},{"post_id":"ciw22yo1j005pek5x3owpzqr4","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yo1k005qek5x9v0z5kv9"},{"post_id":"ciw22yo1k005rek5xff0j678r","tag_id":"ciw22ynxy000nek5xil4wwawf","_id":"ciw22yo1l005sek5xmkej3409"},{"post_id":"cjotrvcjt00038r5xdvcjjbw4","tag_id":"ciw22ynxs000dek5xdnmnjv4e","_id":"cjotrvcju00048r5xs2lmbq19"},{"post_id":"cjotrvcj800008r5xi4tvlvu3","tag_id":"ciw22ynzg002cek5xfag902io","_id":"cjottb1tm0002ov5x88l5r1zf"},{"post_id":"cjotrvcj800008r5xi4tvlvu3","tag_id":"cjottb1ry0000ov5x3lce8wkh","_id":"cjottb1tm0003ov5x5anx86oq"},{"post_id":"cjotrvcj800008r5xi4tvlvu3","tag_id":"cjottb1tl0001ov5xxyytndjc","_id":"cjottb1tm0004ov5xpbcvd4xo"}],"Tag":[{"name":"Git","_id":"ciw22ynxn0007ek5xha0nmge5"},{"name":"Mac","_id":"ciw22ynxq000aek5xgipcfies"},{"name":"android","_id":"ciw22ynxs000dek5xdnmnjv4e"},{"name":"icodeyou","_id":"ciw22ynxw000kek5xcm4kz56f"},{"name":"Android","_id":"ciw22ynxy000nek5xil4wwawf"},{"name":"Java","_id":"ciw22ynyd0012ek5x84q2cbm5"},{"name":"设计模式","_id":"ciw22ynyt001jek5xdj3if5tb"},{"name":"数据结构","_id":"ciw22ynyw001oek5xjsw4s7pl"},{"name":"数据结构与算法","_id":"ciw22ynyx001rek5x9a84vcys"},{"name":"极客学院","_id":"ciw22ynzd0026ek5xp4e70bza"},{"name":"Python","_id":"ciw22ynzg002cek5xfag902io"},{"name":"密码学","_id":"ciw22ynzh002fek5x5732ucky"},{"name":"TCP","_id":"ciw22ynzm002sek5xiidenb97"},{"name":"netwox","_id":"ciw22ynzn002tek5xsd7v600e"},{"name":"Linux","_id":"ciw22ynzo002xek5xjsfujir7"},{"name":"Wireshark","_id":"ciw22ynzo002yek5xo782dshl"},{"name":"Octopress","_id":"ciw22yo00003kek5xordq22w6"},{"name":"算法","_id":"ciw22yo08003yek5xyaivos10"},{"name":"Mysql","_id":"ciw22yo0f004bek5xrfhty9dy"},{"name":"GBN","_id":"ciw22yo0s004xek5x4folfoxx"},{"name":"路由算法","_id":"ciw22yo0t0051ek5xu0rpsn3y"},{"name":"迪杰斯特拉","_id":"ciw22yo0u0052ek5x1u5jhcex"},{"name":"AES","_id":"ciw22yo0w0057ek5xh148uvfs"},{"name":"Socket","_id":"ciw22yo10005dek5xubt88gps"},{"name":"SMTP","_id":"ciw22yo10005eek5x7vaj3mrz"},{"name":"Python Pycharm frp","_id":"cjotrvcjd00018r5xpciytxn0"},{"name":"Pycharm","_id":"cjottb1ry0000ov5x3lce8wkh"},{"name":"frp","_id":"cjottb1tl0001ov5xxyytndjc"}]}}